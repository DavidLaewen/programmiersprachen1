% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\usepackage{hyperref}
\hypersetup{
  pdftitle={Skript Programmiersprachen 1},
  hidelinks,
  pdfcreator={David Läwen},
  colorlinks=true,
  urlcolor=blue,
  linkcolor=violet}
\usepackage{titleref}



\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi



\title{Skript Programmiersprachen 1}
\author{David Läwen}
\date{\today}

\begin{document}
\maketitle

GitHub-Repository mit Code und weiteren Materialien: \\
\url{https://github.com/davidlaewen/programmiersprachen1}

CodiMD-Version mit schönerer Formatierung: \\
\url{https://pad.its-amazing.de/programmiersprachen1}

\tableofcontents

\hypertarget{vorlesungsinhalte}{%
\section{Vorlesungsinhalte}}

\begin{itemize}
\tightlist
\item
  Verständnis von Programmiersprachen (allgemein, über aktuelle
  ``Trends'' hinweg) und deren Qualitäten, Vor- und Nachteile
\item
  Zerlegung von Programmiersprachen in Features sowie deren Analyse
\item
  Erlernen von strukturiertem Programmdesign durch Abstraktionen
\item
  Befähigung, auf informierte Art Programmiersprachen einzuschätzen und
  zu diskutieren
\item
  Implementieren von Programmiersprachen(-features) durch Interpreter in
  Scala
\item
  Zweck/Nutzen verschiedener Sprachfeatures, mögliche Implementationen
  und deren Vorzüge/Probleme
\end{itemize}

\hypertarget{scala-grundlagen}{%
\section{Scala-Grundlagen}\label{scala-grundlagen}}

\href{https://scala-lang.org/}{Scala} ist statisch getypt, funktional
und objekt-orientiert. Scala-Programme werden zu Java-Bytecode
kompiliert und in der JVM ausgeführt. Auswertung ist \emph{eager}
(\emph{Call By Value}). - \textbf{Konstanten} werden mit \texttt{val}
und mutierbare \textbf{Variablen} mit \texttt{var} definiert. Der Typ
muss dabei nicht deklariert werden (wird aber dennoch von Scala
festgelegt), also bspw. \texttt{var\ n\ =\ 1} oder
\texttt{var\ s\ =\ "abc"}. Der Typ kann aber auch explizit deklariert
werden, also bspw. \texttt{var\ n:\ Int\ =\ 1} oder
\texttt{var\ s:\ String\ =\ "abc"}.

\begin{itemize}
\tightlist
\item
  \textbf{Funktionen} haben die Form
  \texttt{def\ f(param:\ Type,\ ...)\ =\ body} und werden durch
  \texttt{f(arg,...)} aufgerufen. Der Rückgabetyp kann optional
  angegeben werden:
  \texttt{def\ f(param:\ Type,\ ...):\ ReturnType\ =\ body}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{square}\NormalTok{(n: Int) : Int = n*n}
\KeywordTok{val}\NormalTok{ x = }\FunctionTok{square}\NormalTok{(}\DecValTok{4}\NormalTok{)}

\KeywordTok{def} \FunctionTok{concat}\NormalTok{(a: String, b: String): String = a + b}
\KeywordTok{val}\NormalTok{ y = }\FunctionTok{concat}\NormalTok{(}\StringTok{"Heiner"}\NormalTok{, }\FunctionTok{concat}\NormalTok{(}\StringTok{" "}\NormalTok{, }\StringTok{"Hacker"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{datentypen}{%
\subsection{Datentypen}\label{datentypen}}

\begin{itemize}
\item
  Es gibt die gängigen Datentypen \texttt{Int}, \texttt{String},
  \texttt{Boolean}, \texttt{Double}, etc.
\item
  \texttt{Unit} entspricht dem Rückgabetyp \texttt{void} in Java (kein
  Rückgabewert, sondern ``Seiteneffekt'', bspw. bei der
  \texttt{print}-Funktion)
\item
  \textbf{Map:} Abbildung mit Key-Value-Paaren.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ map: Map[Int,String] = Map(}\DecValTok{1}\NormalTok{ {-}\textgreater{} }\StringTok{"a"}\NormalTok{, }\DecValTok{2}\NormalTok{ {-}\textgreater{} }\StringTok{"b"}\NormalTok{)}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{map}\NormalTok{(}\DecValTok{1}\NormalTok{) == }\StringTok{"a"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{Tupel:} Erlauben Gruppierung heterogener Daten. Können
  zwischen 2 und 22 Werte beliebigen Typs enthalten.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ t: (Int,String,Boolean) = (}\DecValTok{1}\NormalTok{, }\StringTok{"abc"}\NormalTok{, }\KeywordTok{true}\NormalTok{)}
\KeywordTok{val}\NormalTok{ firstEntry = t.}\FunctionTok{\_1}
\KeywordTok{val}\NormalTok{ (}\DataTypeTok{int}\NormalTok{, string, }\DataTypeTok{boolean}\NormalTok{) = t }\CommentTok{// binds all three fields}
\FunctionTok{assert}\NormalTok{(firstEntry == }\DataTypeTok{int}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{Listen:} Besitzen einen einheitlichen Typ, bspw.
  \texttt{List{[}Int{]}}, Einträge sind nicht mutierbar.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ nums = List(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{nums}\NormalTok{(}\DecValTok{0}\NormalTok{) == }\DecValTok{1}\NormalTok{)}

\KeywordTok{val}\NormalTok{ nums = List.}\FunctionTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\KeywordTok{val}\NormalTok{ nums = (}\DecValTok{1}\NormalTok{ to }\DecValTok{10}\NormalTok{ by }\DecValTok{2}\NormalTok{).}\FunctionTok{toList}
\KeywordTok{val}\NormalTok{ letters = (}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{ to }\CharTok{\textquotesingle{}f\textquotesingle{}}\NormalTok{ by }\DecValTok{2}\NormalTok{).}\FunctionTok{toList}

\NormalTok{letters.}\FunctionTok{foreach}\NormalTok{(println)}
\NormalTok{nums.}\FunctionTok{filter}\NormalTok{(\_ \textgreater{} }\DecValTok{3}\NormalTok{).}\FunctionTok{foreach}\NormalTok{(println)}
\KeywordTok{val}\NormalTok{ doubleNums = nums.}\FunctionTok{map}\NormalTok{(\_ * }\DecValTok{2}\NormalTok{) }
\KeywordTok{val}\NormalTok{ bools = nums.}\FunctionTok{map}\NormalTok{(\_ \textless{} }\DecValTok{5}\NormalTok{)}
\KeywordTok{val}\NormalTok{ squares = nums.}\FunctionTok{map}\NormalTok{(n =\textgreater{} n*n)}
\KeywordTok{val}\NormalTok{ sum = nums.}\FunctionTok{fold}\NormalTok{(}\DecValTok{0}\NormalTok{)(\_+\_)}
\KeywordTok{val}\NormalTok{ prod = nums.}\FunctionTok{fold}\NormalTok{(}\DecValTok{1}\NormalTok{)(\_*\_)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{Arrays:} Besitzen auch einheitlichen Typ, sind im Gegensatz zu
  Listen mutierbar.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ a = Array(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{a}\NormalTok{(}\DecValTok{0}\NormalTok{) == }\DecValTok{1}\NormalTok{)}
\FunctionTok{a}\NormalTok{(}\DecValTok{0}\NormalTok{) = }\DecValTok{10}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{a}\NormalTok{(}\DecValTok{0}\NormalTok{) == }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  \textbf{Mengen:} \texttt{Set(1,2,3)}, mutierbar mit \texttt{+} und
  \texttt{-} um einzelne Werte hinzuzufügen bzw. zu entfernen,
  \texttt{++} und \texttt{-\/-} für Vereinigung bzw. Schnitt mit anderem
  \texttt{Collectible}-Datentyp, bspw. Menge oder Liste.
\item
  \textbf{Either:} Repräsentiert einen Wert eines von zwei möglichen
  Typen. Jede Instanz von \texttt{Either} ist entweder eine Instanz von
  \texttt{Left} oder von \texttt{Right}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ a: Either[Boolean,Int] = }\FunctionTok{Left}\NormalTok{(}\KeywordTok{true}\NormalTok{)}
\KeywordTok{val}\NormalTok{ b: Either[Boolean,Int] = }\FunctionTok{Right}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{objektorientierung}{%
\subsection{Objektorientierung}\label{objektorientierung}}

\begin{itemize}
\tightlist
\item
  \textbf{Klassen:}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \FunctionTok{Person}\NormalTok{(}\KeywordTok{var}\NormalTok{ firstName: String, }\KeywordTok{var}\NormalTok{ lastName: String) \{}
  \KeywordTok{def} \FunctionTok{sayHello}\NormalTok{() = }\FunctionTok{print}\NormalTok{(s}\StringTok{"Hello, $firstName $lastName"}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{val}\NormalTok{ heiner = }\KeywordTok{new} \FunctionTok{Person}\NormalTok{(}\StringTok{"Heiner"}\NormalTok{, }\StringTok{"Hacker"}\NormalTok{)}

\NormalTok{heiner.}\FunctionTok{sayHello}\NormalTok{() }\CommentTok{// prints "Hello, Heiner Hacker"}
\FunctionTok{println}\NormalTok{(heiner.}\FunctionTok{firstName}\NormalTok{) }\CommentTok{// prints "Heiner"}
\NormalTok{heiner.}\FunctionTok{firstName}\NormalTok{ = }\StringTok{"Heinrich"} \CommentTok{// field access without get and set methods}
\NormalTok{heiner.}\FunctionTok{lastName}\NormalTok{ = }\StringTok{"Knacker"}
\NormalTok{heiner.}\FunctionTok{sayHello}\NormalTok{() }\CommentTok{// now prints "Hello, Heinrich Knacker"}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Mit \texttt{var} definierte Felder einer Klasse sind mutierbar.
\item
  \textbf{Abstrakte Klassen} können mit dem Keyword \texttt{abstract}
  angelegt werden.
\item
  \textbf{Traits} sind Bausteine zur Konstruktion von Klassen und können
  nicht instanziiert werden. Sie lassen sich einer Klasse mit
  \texttt{with}/\texttt{extends} anfügen.
\item
  Ist ein Trait oder eine abstrakte Klasse \emph{sealed} (Keyword
  \texttt{sealed\ ...}), so müssen alle erbenden Klassen in der gleichen
  Datei definiert sein. Dadurch kann bei Pattern Matching erkannt
  werden, ob alle Fälle (also alle Case Classes) abgedeckt sind.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Speaker \{}
    \KeywordTok{def} \FunctionTok{sayCatchPhrase}\NormalTok{(): Unit }\CommentTok{// no function body, abstract}
\NormalTok{\}}

\KeywordTok{trait}\NormalTok{ Sleeper \{}
    \KeywordTok{def} \FunctionTok{sleep}\NormalTok{(): Unit = }\FunctionTok{println}\NormalTok{(}\StringTok{"I\textquotesingle{}m sleeping"}\NormalTok{)}
    \KeywordTok{def} \FunctionTok{wakeUp}\NormalTok{(): Unit = }\FunctionTok{println}\NormalTok{(}\StringTok{"I\textquotesingle{}m awake"}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{class} \FunctionTok{Person}\NormalTok{(}\KeywordTok{var}\NormalTok{ name: String, catchPhrase: String) }\KeywordTok{extends}\NormalTok{ Speaker }\KeywordTok{with}\NormalTok{ Sleeper \{}
    \KeywordTok{def} \FunctionTok{sayCatchPhrase}\NormalTok{(): Unit = }\FunctionTok{println}\NormalTok{(catchPhrase)}
    \KeywordTok{override} \KeywordTok{def} \FunctionTok{sleep}\NormalTok{() = }\FunctionTok{println}\NormalTok{(}\StringTok{"Zzzzzzz"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Umdefinieren von Methoden in Unterklassen ist mit dem Keyword
\texttt{override} möglich. - \textbf{Objekte:} Können mit Keyword
\texttt{object} instanziiert werden.

\begin{itemize}
\item
  Mit \texttt{extends} können Klassen/Traits erweitert oder abstrakte
  Klassen implementiert werden
\item
  \textbf{Case Classes} sind hilfreich bei der Verwendung von Klassen
  als Datencontainer. Erzeugung von Instanzen ist ohne \texttt{new}
  möglich, zudem gibt es Default-Implementationen für das Vergleichen
  oder Hashen von Instanzen der Klasse. Mit Case Classes ist Pattern
  Matching möglich:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ UniPerson}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Student}\NormalTok{(}\KeywordTok{val}\NormalTok{ id: Int) }\KeywordTok{extends}\NormalTok{ UniPerson}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Professor}\NormalTok{(}\KeywordTok{val}\NormalTok{ subject: String) }\KeywordTok{extends}\NormalTok{ UniPerson}

\KeywordTok{def} \FunctionTok{display}\NormalTok{(p: UniPerson) : String = p }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Student}\NormalTok{(id) =\textgreater{} s}\StringTok{"Student number $id"}
  \KeywordTok{case} \FunctionTok{Professor}\NormalTok{(subject) =\textgreater{} s}\StringTok{"Professor of $subject"}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Eine Implementation im objektorientierten Stil sieht dagegen
  folgendermaßen aus:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{abstract} \KeywordTok{class}\NormalTok{ UniPerson \{}
  \KeywordTok{def}\NormalTok{ display : String}
\NormalTok{\}}
\KeywordTok{class} \FunctionTok{Student}\NormalTok{(}\KeywordTok{val}\NormalTok{ id: Int) }\KeywordTok{extends}\NormalTok{ UniPerson \{}
  \KeywordTok{def}\NormalTok{ display = s}\StringTok{"Student number $id"}
\NormalTok{\}}
\KeywordTok{class} \FunctionTok{Professor}\NormalTok{(}\KeywordTok{val}\NormalTok{ subject: String) }\KeywordTok{extends}\NormalTok{ UniPerson \{}
  \KeywordTok{def}\NormalTok{ display = s}\StringTok{"Professor of $subject"}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Die erste Variante (Pattern-Match-Dekomposition) erlaubt das Hinzufügen
weiterer Funktionen, die auf dem Datentyp \texttt{UniPerson} operieren,
ohne Modifikation des bestehenden Codes.

Die zweite Variante (objektorientierte Dekomposition) erlaubt das
Hinzufügen weiterer Unterklassen von \texttt{UniPerson} ohne
Modifikation des bestehenden Codes.

Die Schwierigkeit, die Vorzüge beider Repräsentationen zu vereinen, wird
\emph{Expression Problem} genannt (mehr dazu im Kapitel
\hyperlink{expression-problem}{Objekt-Algebren}).

\hypertarget{kontrollstrukturen}{%
\subsection{Kontrollstrukturen}\label{kontrollstrukturen}}

\begin{itemize}
\tightlist
\item
  \emph{If-Else}-Statements:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if}\NormalTok{ (}\DecValTok{1}\NormalTok{ \textless{} }\DecValTok{2}\NormalTok{) }\FunctionTok{print}\NormalTok{(}\StringTok{"Condition met"}\NormalTok{)}

\KeywordTok{if}\NormalTok{ (a \textgreater{} b) \{}
    \FunctionTok{print}\NormalTok{(}\StringTok{"a greater than b"}\NormalTok{)}
\NormalTok{\} }\KeywordTok{else} \KeywordTok{if}\NormalTok{ (a == b) \{}
    \FunctionTok{print}\NormalTok{(}\StringTok{"a equals b"}\NormalTok{)}
\NormalTok{\} }\KeywordTok{else}\NormalTok{ \{}
    \FunctionTok{print}\NormalTok{(}\StringTok{"a less than b"}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{val}\NormalTok{ x = }\KeywordTok{if}\NormalTok{ (}\DecValTok{1}\NormalTok{ == }\DecValTok{1}\NormalTok{) }\StringTok{"a"} \KeywordTok{else} \StringTok{"b"} \CommentTok{// usable as ternary operator, "a" is bound to x}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \emph{For-Comprehensions}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for}\NormalTok{ (elem \textless{}{-} list) }\FunctionTok{println}\NormalTok{(elem)}

\KeywordTok{for}\NormalTok{ (i \textless{}{-} }\DecValTok{0}\NormalTok{ to }\DecValTok{10}\NormalTok{ by }\DecValTok{2}\NormalTok{) }\FunctionTok{println}\NormalTok{(i)}

\KeywordTok{val}\NormalTok{ evenNums = }\KeywordTok{for}\NormalTok{ \{}
\NormalTok{  i \textless{}{-} }\DecValTok{0}\NormalTok{ to }\DecValTok{10}
  \KeywordTok{if}\NormalTok{ i \% }\DecValTok{2}\NormalTok{ == }\DecValTok{0}
\NormalTok{\} }\KeywordTok{yield}\NormalTok{ i}
\CommentTok{// evenNums: Vector(0,2,4,6,8,10)}
\end{Highlighting}
\end{Shaded}

\hypertarget{pattern-matching}{%
\subsection{Pattern Matching}\label{pattern-matching}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{pm}\NormalTok{(x: Any) = x }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \DecValTok{1}\NormalTok{ =\textgreater{} }\StringTok{"x is 1"}
  \KeywordTok{case} \KeywordTok{true}\NormalTok{ =\textgreater{} }\StringTok{"x is true"}
  \KeywordTok{case}\NormalTok{ s: String =\textgreater{} s}\StringTok{"x is string $s"}
  \KeywordTok{case}\NormalTok{ (a,b,c) =\textgreater{} s}\StringTok{"x is tuple of $a, $b and $c"}
  \KeywordTok{case}\NormalTok{ (a,b) }\KeywordTok{if}\NormalTok{ (a == b) =\textgreater{} s}\StringTok{"tuple ($a,$b) and $a == $b"}
  \KeywordTok{case}\NormalTok{ \_ =\textgreater{} }\StringTok{"x is something else"}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{repl}{%
\subsection{REPL}\label{repl}}

\begin{itemize}
\tightlist
\item
  Anleitung zur Installation der Binaries
  \href{https://www.scala-lang.org/download/}{hier}
\item
  REPL lässt sich mit Befehl \texttt{scala} starten
\item
  \texttt{.scala}-Dateien lassen sich in REPL laden mit
  \texttt{:load\ filename.scala}.
\item
  Ergebnisse werden automatisch an Variablennamen gebunden.
\item
  Typ eines Werts kann mit \texttt{:type} abgefragt werden
\item
  Bisherige Definitionen können mit \texttt{:reset} gelöscht werden.
\item
  REPL kann mit \texttt{:q} verlassen werden.
\end{itemize}

\hypertarget{implizite-konvertierung}{%
\subsection{Implizite Konvertierung}\label{implizite-konvertierung}}

Scala bietet die Möglichkeit, bestimmte Typkonvertierungsfunktionen
automatisch zu nutzen, wenn dadurch der erwartete Typ erfüllt werden
kann. Mit dieser \emph{impliziten Konvertierung} können wir Ausdrücke
für unsere Interpreter geschickter notieren.

Hierzu muss die \texttt{implicitConversions}-Bibliothek importiert
werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import}\NormalTok{ scala.}\FunctionTok{language}\NormalTok{.}\FunctionTok{implicitConversions}

\KeywordTok{abstract} \KeywordTok{class}\NormalTok{ BTree}
\KeywordTok{case} \KeywordTok{class}\NormalTok{ Node(l: BTree, r: BTree) }\KeywordTok{extends}\NormalTok{ BTree}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Leaf}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ BTree}

\KeywordTok{implicit} \KeywordTok{def} \FunctionTok{int2btree}\NormalTok{(n: Int) : BTree = }\FunctionTok{Leaf}\NormalTok{(n)}

\KeywordTok{val}\NormalTok{ test = Node(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{) }\CommentTok{// is implicitly converted to Node(Leaf(1), Leaf(2))}
\end{Highlighting}
\end{Shaded}

Die Funktion \texttt{int2btree} wird durch das Keyword \texttt{implicit}
automatisch auf Werte vom Typ \texttt{Int} aufgerufen, wenn an deren
Stelle ein Wert vom Typ \texttt{BTree} erwartet wird.

\hypertarget{typ-alias}{%
\subsection{Typ-Alias}\label{typ-alias}}

Mit dem Keyword \texttt{type} können neue Typen definiert werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ IntStringMap = Map[Int, String]}
\end{Highlighting}
\end{Shaded}

\hypertarget{lambda-ausdruxfccke-und-currying}{%
\subsection{Lambda-Ausdrücke und
Currying}\label{lambda-ausdruxfccke-und-currying}}

Es können in Scala anonyme Funktionen als Werte
(\emph{Lambda-Ausdrücke}) definiert werden. Diese haben dann einen Typ
der Form \texttt{Type\ =\textgreater{}\ ...}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ succ : (n: Int) =\textgreater{} n+}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

Funktionen bzw. Lambda-Ausdrücke können dadurch der Rückgabewert von
Funktionen sein (\emph{Higher Order}), wodurch etwa \emph{Currying}
möglich wird:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{curryAdd}\NormalTok{(n: Int) : (Int =\textgreater{} Int) = x =\textgreater{} x+n}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{curryAdd}\NormalTok{(}\DecValTok{3}\NormalTok{)(}\DecValTok{4}\NormalTok{) == }\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}


\section{Erster Interpreter (AE)} \label{erster-interpreter-ae}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{trait}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Num}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Add}\NormalTok{(l: Exp, r: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Mul}\NormalTok{(l: Exp, r: Exp) }\KeywordTok{extends}\NormalTok{ Exp}

\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp) : Int = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} n}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{eval}\NormalTok{(l) + }\FunctionTok{eval}\NormalTok{(r)}
  \KeywordTok{case} \FunctionTok{Mul}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{eval}\NormalTok{(l) * }\FunctionTok{eval}\NormalTok{(r)}
\NormalTok{\}}

\CommentTok{// example expressions}
\KeywordTok{var}\NormalTok{ onePlusTwo = }\FunctionTok{Add}\NormalTok{(}\FunctionTok{Num}\NormalTok{(}\DecValTok{1}\NormalTok{), }\FunctionTok{Num}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{eval}\NormalTok{(onePlusTwo) == }\DecValTok{3}\NormalTok{)}
\KeywordTok{var}\NormalTok{ twoTimesFour = }\FunctionTok{Mul}\NormalTok{(}\FunctionTok{Num}\NormalTok{(}\DecValTok{2}\NormalTok{), }\FunctionTok{Add}\NormalTok{(}\FunctionTok{Num}\NormalTok{(}\DecValTok{1}\NormalTok{), }\FunctionTok{Num}\NormalTok{(}\DecValTok{3}\NormalTok{)))}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{eval}\NormalTok{(twoTimesFour) == }\DecValTok{8}\NormalTok{)}
\KeywordTok{var}\NormalTok{ threeTimesFourPlusFour = }\FunctionTok{Add}\NormalTok{(}\FunctionTok{Mul}\NormalTok{(}\FunctionTok{Num}\NormalTok{(}\DecValTok{3}\NormalTok{),}\FunctionTok{Num}\NormalTok{(}\DecValTok{4}\NormalTok{)), }\FunctionTok{Num}\NormalTok{(}\DecValTok{4}\NormalTok{))}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{eval}\NormalTok{(threeTimesFourPlusFour) == }\DecValTok{16}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Bei der Implementation eines Interpreters ist ein umfassendes
Verständnis der \emph{Metasprache} (hier Scala) notwendig, um die
Eigenschaften der (von uns definierten) \emph{Objektsprache} vollständig
zu kennen. Bspw. betreffen die Eigenschaften und Einschränkungen des
\texttt{Int}-Datentyps durch dessen Verwendung auch die Objektsprache.

\hypertarget{syntaktischer-zucker-und-desugaring}{%
\section{Syntaktischer Zucker und
Desugaring}\label{syntaktischer-zucker-und-desugaring}}

In vielen Programmiersprachen gibt es Syntaxerweiterungen, die Programme
lesbarer machen oder verkürzen, aber gleichbedeutend mit einer
ausführlicheren Schreibweise sind (\emph{syntaktischer Zucker}). Dadurch
wird das Programmieren angenehmer und die Lesbarkeit von Programmen
besser, für die Implementierung der Sprache ist syntaktischer Zucker
jedoch lästig, da man gleichbedeutende Syntax mehrfach implementieren
muss.

Der syntaktische Zucker erweitert den Funktionsumfang der Sprache nicht
und jeder Ausdruck kann mit der gleichen Bedeutung ohne syntaktischen
Zucker formuliert werden. Deshalb werden Sprachen typischerweise in eine
\emph{Kernsprache} und eine \emph{erweiterte Sprache} aufgeteilt. Dann
können Ausdrücke vor dem Interpretieren vollständig in die Kernsprache
übersetzt werden (\emph{Desugaring}) und der Interpreter muss nur
Ausdrücke in der Kernsprache auswerten können.

\hypertarget{interpreter-mit-desugaring}{%
\subsection{Interpreter mit
Desugaring}\label{interpreter-mit-desugaring}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// core language}
\KeywordTok{sealed} \KeywordTok{trait}\NormalTok{ CExp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{CNum}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ CExp }
\KeywordTok{case} \KeywordTok{class} \FunctionTok{CAdd}\NormalTok{(l: CExp, r: CExp) }\KeywordTok{extends}\NormalTok{ CExp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{CMul}\NormalTok{(l: CExp, r: CExp) }\KeywordTok{extends}\NormalTok{ CExp}

\CommentTok{// extended language}
\KeywordTok{sealed} \KeywordTok{trait}\NormalTok{ SExp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{SNum}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ SExp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{SAdd}\NormalTok{(l: SExp, r: SExp) }\KeywordTok{extends}\NormalTok{ SExp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{SMul}\NormalTok{(l: SExp, r: SExp) }\KeywordTok{extends}\NormalTok{ SExp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{SNeg}\NormalTok{(e: SExp) }\KeywordTok{extends}\NormalTok{ SExp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{SSub}\NormalTok{(l: SExp, r: SExp) }\KeywordTok{extends}\NormalTok{ SExp}

\KeywordTok{def} \FunctionTok{desugar}\NormalTok{(s: SExp) : CExp = s }\KeywordTok{match}\NormalTok{ \{ }
  \KeywordTok{case} \FunctionTok{SNum}\NormalTok{(n) =\textgreater{} }\FunctionTok{CNum}\NormalTok{(n)}
  \KeywordTok{case} \FunctionTok{SAdd}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{CAdd}\NormalTok{(}\FunctionTok{desugar}\NormalTok{(l), }\FunctionTok{desugar}\NormalTok{(r))}
  \KeywordTok{case} \FunctionTok{SMul}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{CMul}\NormalTok{(}\FunctionTok{desugar}\NormalTok{(l), }\FunctionTok{desugar}\NormalTok{(r)) }
  \KeywordTok{case} \FunctionTok{SNeg}\NormalTok{(e)   =\textgreater{} }\FunctionTok{CMul}\NormalTok{(}\FunctionTok{CNum}\NormalTok{({-}}\DecValTok{1}\NormalTok{), }\FunctionTok{desugar}\NormalTok{(e))}
  \KeywordTok{case} \FunctionTok{SSub}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{CAdd}\NormalTok{(}\FunctionTok{desugar}\NormalTok{(l), }\FunctionTok{desugar}\NormalTok{(}\FunctionTok{SNeg}\NormalTok{(r)))}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{eval}\NormalTok{(c: CExp) : Int = c }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{CNum}\NormalTok{(n) =\textgreater{} n}
  \KeywordTok{case} \FunctionTok{CAdd}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{eval}\NormalTok{(l) + }\FunctionTok{eval}\NormalTok{(r)}
  \KeywordTok{case} \FunctionTok{CMul}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{eval}\NormalTok{(l) * }\FunctionTok{eval}\NormalTok{(r)}
\NormalTok{\}}

\CommentTok{// examples:}
\KeywordTok{var}\NormalTok{ twoMinusOne = }\FunctionTok{SSub}\NormalTok{(}\FunctionTok{SNum}\NormalTok{(}\DecValTok{2}\NormalTok{), }\FunctionTok{SNum}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{eval}\NormalTok{(}\FunctionTok{desugar}\NormalTok{(twoMinusOne)) == }\DecValTok{1}\NormalTok{)}
\KeywordTok{var}\NormalTok{ fivePlusFour = }\FunctionTok{SAdd}\NormalTok{(}\FunctionTok{SNum}\NormalTok{(}\DecValTok{5}\NormalTok{), }\FunctionTok{SNum}\NormalTok{(}\DecValTok{4}\NormalTok{))}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{eval}\NormalTok{(}\FunctionTok{desugar}\NormalTok{(fivePlusFour)) == }\DecValTok{9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Für unsere Zwecke reicht es aus, syntaktischen Zucker in einer Funktion
zu definieren. Dadurch ist kein Desugaring notwendig, wir können aber
trotzdem Testausdrücke einfacher notieren.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{neg}\NormalTok{(e: Exp) = }\FunctionTok{Mul}\NormalTok{(}\FunctionTok{Num}\NormalTok{({-}}\DecValTok{1}\NormalTok{), e)}
\KeywordTok{def} \FunctionTok{sub}\NormalTok{(l: Exp, r: Exp) = }\FunctionTok{Add}\NormalTok{(l, }\FunctionTok{neg}\NormalTok{(r))}
\end{Highlighting}
\end{Shaded}

Syntaktischer Zucker kann (wie bei \texttt{SSub} und \texttt{sub}) auch
auf anderem syntaktischen Zucker aufbauen.

\hypertarget{identifier-mit-umgebung-aeid}{%
\section{Identifier mit Umgebung
(AEId)}\label{identifier-mit-umgebung-aeid}}

Wir wollen unseren ersten Interpreter für arithmetische Ausdrücke um Konstantendefinitionen
erweitern. Um Identifier in den Ausdrücken verwenden zu können, legen
wir eine zusätzliche Datenstruktur an, nämlich eine Umgebung
(\emph{Environment}), in der Paare aus Bezeichnern und Werten hinterlegt
werden.

Wir verwenden für die Identifier den Datentyp \texttt{String}, für die
Umgebung definieren wir das Typ-Alias \texttt{Env}, das eine Abbildung
von \texttt{String} nach \texttt{Int} bezeichnet.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import}\NormalTok{ scala.}\FunctionTok{language}\NormalTok{.}\FunctionTok{implicitConversions}

\CommentTok{// ...}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Id}\NormalTok{(x: String) }\KeywordTok{extends}\NormalTok{ Exp}

\KeywordTok{implicit} \KeywordTok{def} \FunctionTok{num2exp}\NormalTok{(n: Int) : Exp = }\FunctionTok{Num}\NormalTok{(n)}
\KeywordTok{implicit} \KeywordTok{def} \FunctionTok{string2exp}\NormalTok{(s: String) : Exp = }\FunctionTok{Id}\NormalTok{(s))}

\KeywordTok{type}\NormalTok{ Env = Map[String, Int]}

\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp, env: Env) : Int = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} n}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{eval}\NormalTok{(l,env) + }\FunctionTok{eval}\NormalTok{(r,env)}
  \KeywordTok{case} \FunctionTok{Mul}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{eval}\NormalTok{(l,env) * }\FunctionTok{eval}\NormalTok{(r,env)}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} }\FunctionTok{env}\NormalTok{(x)}
\NormalTok{\}}

\CommentTok{// example expressions}
\KeywordTok{val}\NormalTok{ exEnv = Map(}\StringTok{"x"}\NormalTok{ {-}\textgreater{} }\DecValTok{2}\NormalTok{, }\StringTok{"y"}\NormalTok{ {-}\textgreater{} }\DecValTok{4}\NormalTok{)}
\KeywordTok{val}\NormalTok{ a = }\FunctionTok{Add}\NormalTok{(}\FunctionTok{Mul}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\DecValTok{5}\NormalTok{), }\FunctionTok{Mul}\NormalTok{(}\StringTok{"y"}\NormalTok{,}\DecValTok{7}\NormalTok{))}
\FunctionTok{assert}\NormalTok{( }\FunctionTok{eval}\NormalTok{(a,exEnv) == }\DecValTok{38}\NormalTok{ )}
\KeywordTok{val}\NormalTok{ b = }\FunctionTok{Mul}\NormalTok{(}\FunctionTok{Mul}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"x"}\NormalTok{), }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"x"}\NormalTok{))}
\FunctionTok{assert}\NormalTok{( }\FunctionTok{eval}\NormalTok{(b,exEnv) == }\DecValTok{16}\NormalTok{ )}
\end{Highlighting}
\end{Shaded}

Bei der rekursiven Auswertung der Unterausdrücke im \texttt{Add}- und
\texttt{Mul}-Fall reichen wir die Umgebung \texttt{env} unverändert
weiter. Um einen Identifier auszuwerten, schlagen wir ihn in der
Umgebung nach und geben die mit ihm assoziierte Zahl aus.

Wir nutzen \hyperlink{implizite-konvertierung}{implizite
Konvertierung}, um Beispielausdrücke kompakter und lesbarer notieren zu
können.

\hypertarget{abstraktion-durch-visitor}{%
\section{Abstraktion durch Visitor}\label{abstraktion-durch-visitor}}

Eine alternative Möglichkeit, den ersten Interpreter zu definieren, ist
durch \emph{Faltung} mit einem \emph{internen Visitor}. Dabei handelt es
sich um eine Instanz einer Klasse mit Typparameter \texttt{T}, die aus
Funktionen mit den Typen \texttt{Int\ =\textgreater{}\ T} und
\texttt{(T,T)\ =\textgreater{}\ T} besteht.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class}\NormalTok{ Visitor[T](num: Int =\textgreater{} T, add: (T,T) =\textgreater{} T)}

\KeywordTok{def}\NormalTok{ foldExp[T](v: Visitor[T], e: Exp) : T = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} v.}\FunctionTok{num}\NormalTok{(n)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} v.}\FunctionTok{add}\NormalTok{(}\FunctionTok{foldExp}\NormalTok{(v,l), }\FunctionTok{foldExp}\NormalTok{(v,r))}
\NormalTok{\}}

\KeywordTok{val}\NormalTok{ evalVisitor = }\KeywordTok{new}\NormalTok{ Visitor[Int](n =\textgreater{} n, (l,r) =\textgreater{} l+r)}
\KeywordTok{val}\NormalTok{ countVisitor = Visitor[Int](n =\textgreater{} }\DecValTok{1}\NormalTok{, (l,r) =\textgreater{} l+r+}\DecValTok{1}\NormalTok{)}
\KeywordTok{val}\NormalTok{ printVisitor = Visitor[String](\_.}\FunctionTok{toString}\NormalTok{, }\StringTok{"("}\NormalTok{+\_+}\StringTok{"+"}\NormalTok{+\_+}\StringTok{")"}\NormalTok{)}

\FunctionTok{assert}\NormalTok{( }\FunctionTok{foldExp}\NormalTok{(evalVisitor, }\FunctionTok{Add}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{)) == }\DecValTok{6}\NormalTok{ )}
\FunctionTok{assert}\NormalTok{( }\FunctionTok{foldExp}\NormalTok{(countVisitor, }\FunctionTok{Add}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{)) == }\DecValTok{3}\NormalTok{ )}
\FunctionTok{assert}\NormalTok{( }\FunctionTok{foldExp}\NormalTok{(printVisitor, }\FunctionTok{Add}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{)) == }\StringTok{"(2+4)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Im Allgemeinen besteht ein interner Visitor für einen algebraischen
Datentyp aus einer Funktion für jedes Konstrukt des Datentyps und einem
Typparameter, der den Rückgabetyp der Faltung mit dem Visitor angibt.
Der Typparameter wird an allen Stellen verwendet, an denen in der
Definition des Datentyps der Datentyp selbst steht (im Beispiel die
beiden Unterausdrücke von \texttt{Add}).

Ein wesentlicher Unterschied zur Pattern-Matching-Implementation ist,
dass die Visitors selbst nicht rekursiv sind, sondern stattdessen das
grundlegende Rekursionsmuster in einer Funktion abstrahiert wird (als
Faltung, hier in \texttt{foldExp}). Dadurch können beliebige
\emph{kompositionale} Operationen auf der Datenstruktur (hier
\texttt{Exp}) definiert werden, ohne dass weitere Funktionen notwendig
sind.

Durch die Abstraktion des Rekursionsmusters wird
\emph{Kompositionalität} für alle Visitors erzwungen.

\textbf{Kompositionalität} heißt, dass sich die Bedeutung eines
zusammengesetzten Ausdrucks aus der Bedeutung seiner Bestandteile
ergibt. Bei einer rekursiven Struktur muss also die Bedeutungsfunktion
strukturell rekursiv sein.

Eine Funktion ist \textbf{strukturell rekursiv}, wenn rekursive Aufrufe
immer nur auf Unterausdrücken bzw. dem Inhalt der Datenfelder des
aktuellen Ausdrucks stattfinden.

Auch in dieser Implementation ist es möglich, eine Core-Sprache und eine
erweiterte Sprache zu definieren, in dem man etwa eine zweite Klasse
definiert, die \texttt{Visitor} erweitert und um zusätzliche Funktionen
(bspw. \texttt{sub:\ (T,T)\ =\textgreater{}\ T}) ergänzt.

Wir können auch wieder Identifier durch eine Umgebung hinzufügen, der
\texttt{eval}-Visitor muss dazu mithilfe von Currying verfasst werden.
Für den Typparameter \texttt{T} des Visitors muss dann
\texttt{Env\ =\textgreater{}\ Int} gewählt werden, es wird erst ein
Ausdruck und anschließend eine Umgebung eingelesen, bevor das Ergebnis
ausgegeben wird. Dadurch lässt sich die Funktion trotz des zusätzlichen
Parameters mit der Visitor-Klasse verfassen (hier verkürzt ohne
\texttt{Mul}):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class}\NormalTok{ Visitor[T](num: Int =\textgreater{} T, add: (T,T) =\textgreater{} T, id: String =\textgreater{} T)}

\KeywordTok{def}\NormalTok{ foldExp[T](v: Visitor[T], e: Exp) : T = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} v.}\FunctionTok{num}\NormalTok{(n)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} v.}\FunctionTok{add}\NormalTok{(}\FunctionTok{foldExp}\NormalTok{(v, l), }\FunctionTok{foldExp}\NormalTok{(v, r))}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} v.}\FunctionTok{id}\NormalTok{(x)}
\NormalTok{\}}

\KeywordTok{val}\NormalTok{ evalVisitor = Visitor[Env=\textgreater{}Int](}
\NormalTok{  env =\textgreater{} \_ ,}
\NormalTok{  (a, b) =\textgreater{} env =\textgreater{} }\FunctionTok{a}\NormalTok{(env) + }\FunctionTok{b}\NormalTok{(env),}
\NormalTok{  x =\textgreater{} env =\textgreater{} }\FunctionTok{env}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\hypertarget{identifier-mit-bindings-wae}{%
\section{Identifier mit Bindings
(WAE)}\label{identifier-mit-bindings-wae}}

Bei der Implementation von Identifiern mit einer Environment müssen die
Identifier außerhalb der Programme in der \emph{Map} definiert werden
und Identifier können nicht umdefiniert werden.

Besser wäre eine Implementation, bei der die Bindungen innerhalb von
Programmen definiert und umdefiniert werden können. Dazu ist ein neues
Sprachonstrukt, \texttt{With}, notwendig. Ein \texttt{With}-Ausdruck
besteht aus einem Identifier, einem Ausdruck und einem Rumpf, in dem der
Identifier an den Ausdruck gebunden ist.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class} \FunctionTok{With}\NormalTok{(x: String, xDef: Exp, body: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\end{Highlighting}
\end{Shaded}

\texttt{Add(5,\ With(x,\ 7,\ Add(x,\ 3)))} soll also bspw. zu
\texttt{15} auswerten.

Die Bindung soll nur im Rumpf gelten, nicht außerhalb
(\emph{lexikalisches Scoping}).

Dazu soll die Definition von \texttt{x} (hier \texttt{7}) ausgewertet
und für alle Vorkommen von \texttt{x} im Rumpf eingesetzt werden
(\emph{Substitution}). Hierfür definieren wir eine neue Funktion
\texttt{subst} mit dem Typ
\texttt{(Exp,\ String,\ Num)\ =\textgreater{}\ Exp}. Es müssen zwei
verschiedene Vorkommen von Identifiern unterschieden werden:
\emph{Bindende} Vorkommen (Definitionen in \texttt{With}-Ausdrücken) und
\emph{gebundene} Vorkommen (Verwendung an allen anderen Stellen). Tritt
ein Identifier auf, ohne dass es ``weiter außen'' im Ausdruck ein
bindendes Vorkommen gibt, so handelt es sich um ein \emph{freies}
Vorkommen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{With x = }\DecValTok{7}\NormalTok{: }\CommentTok{// binding occurence}
\NormalTok{  x + y }\CommentTok{// x bound, y free}
\end{Highlighting}
\end{Shaded}

Der \textbf{Scope} (Sichtbarkeitsbereich) eines bindenden Vorkommens des
Identifiers \texttt{x} ist die Region des Programmtextes in dem sich
Vorkommen von \texttt{x} auf das bindende Vorkommen beziehen.

Beim Entwerfen der Sprache muss das erwünschte Scoping-Verhalten
entschieden und implementiert werden. - Beispiel 1: Das gebundene
Vorkommen von \texttt{x} soll sich auf die Definition in der ersten
Zeile beziehen, die zweite Definition soll keine Wirkung ``nach außen''
haben.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{With x = }\DecValTok{5}\NormalTok{:}
\NormalTok{  x + (With x = }\DecValTok{3}\NormalTok{: }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Beispiel 2: Das erste Vorkommen soll hier (intuitiv, vgl.
  Scheme/Racket) den Wert 5 besitzen, dass zweite Vorkommen jedoch den
  Wert 3. Es soll also immer das nächste bzw. nächstinnerste bindende
  Vorkommen gelten.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{With x = }\DecValTok{5}\NormalTok{:}
\NormalTok{   x + (With x = }\DecValTok{3}\NormalTok{: x)}
\end{Highlighting}
\end{Shaded}

Würde das Scope des ersten bindenden Vorkommens den gesamten Ausdruck
umfassen, so wäre es nicht möglich, Identifier umzubinden, außerdem sind
Programme so weniger verständlich und deren Auswertung schlechter
nachvollziehbar, da Unterausdrücke je nach Kontext zu einem anderen
Ergebnis auswerten würden.

Es ergibt sich die folgende Implementation für die Erweiterung um
\texttt{With} und Substitution:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class} \FunctionTok{With}\NormalTok{(x: String, xDef: Exp, body: Exp) }\KeywordTok{extends}\NormalTok{ Exp}

\KeywordTok{def} \FunctionTok{subst}\NormalTok{(body: Exp, i: String, v: Num) : Exp = body }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(\_) =\textgreater{} body}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} }\KeywordTok{if}\NormalTok{ (x == i) v }\KeywordTok{else}\NormalTok{ body}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{Add}\NormalTok{(}\FunctionTok{subst}\NormalTok{(l,i,v), }\FunctionTok{subst}\NormalTok{(r,i,v))}
  \KeywordTok{case} \FunctionTok{With}\NormalTok{(x,xDef,body) =\textgreater{}  }\CommentTok{// do not substitute in body if x is redefined}
    \FunctionTok{With}\NormalTok{(x, }\FunctionTok{subst}\NormalTok{(xDef,i,v), }\KeywordTok{if}\NormalTok{ (x == i) body }\KeywordTok{else} \FunctionTok{subst}\NormalTok{(body,i,v))}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp) : Int = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} n}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Unbound identifier: "}\NormalTok{ + x.}\FunctionTok{name}\NormalTok{)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{eval}\NormalTok{(l) + }\FunctionTok{eval}\NormalTok{(r)}
  \KeywordTok{case} \FunctionTok{With}\NormalTok{(x,xDef,body) =\textgreater{} }\FunctionTok{eval}\NormalTok{(}\FunctionTok{subst}\NormalTok{(body,x,}\FunctionTok{Num}\NormalTok{(}\FunctionTok{eval}\NormalTok{(xDef))))}
\NormalTok{\}}

\KeywordTok{val}\NormalTok{ a = }\FunctionTok{Add}\NormalTok{(}\DecValTok{5}\NormalTok{, }\FunctionTok{With}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DecValTok{7}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DecValTok{3}\NormalTok{)))}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{eval}\NormalTok{(a) == }\DecValTok{15}\NormalTok{)}
\KeywordTok{val}\NormalTok{ b = }\FunctionTok{With}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FunctionTok{With}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"x"}\NormalTok{)))}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{eval}\NormalTok{(b) == }\DecValTok{4}\NormalTok{)}
\KeywordTok{val}\NormalTok{ c = }\FunctionTok{With}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DecValTok{5}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{With}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DecValTok{3}\NormalTok{, }\StringTok{"x"}\NormalTok{)))}
\FunctionTok{assert}\NormalTok{((}\FunctionTok{eval}\NormalTok{(c) == }\DecValTok{8}\NormalTok{))}
\KeywordTok{val}\NormalTok{ d = }\FunctionTok{With}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FunctionTok{With}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\DecValTok{1}\NormalTok{), }\StringTok{"x"}\NormalTok{))}
\FunctionTok{assert}\NormalTok{((}\FunctionTok{eval}\NormalTok{(d) == }\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Stößt die \texttt{eval}-Funktion auf einen Identifier, so ist dieser
offensichtlich bei den bisherigen Substitutionen nicht ersetzt worden
und ist frei. In diesem Fall wird also ein Fehler geworfen. Im
\texttt{With}-Fall wird \texttt{subst} aufgerufen, um im Rumpf
(\texttt{body}) die Vorkommen von \texttt{x} durch \texttt{xDef} zu
ersetzen. Dabei wird \texttt{xDef} zuerst ausgewertet, was einen Wert
vom Typ \texttt{Int} ergibt, und anschließend wieder mit \texttt{Num()}
``verpackt'', damit der erwartete Typ erfüllt ist und die Zahl als
Unterausdruck eingefügt werden kann.

Bei der Substitution im \texttt{With}-Konstrukt darf die Substitution
nur dann rekursiv im Rumpf angewendet werden, wenn der Identifier im
\texttt{With} Konstrukt nicht gleich dem zu ersetzenden Identifier ist.
In diesem Fall beziehen sich Vorkommen des Identifiers im Rumpf nämlich
auf die Bindung im \texttt{With}-Konstrukt und nicht auf die Bindung,
für die die Substitution durchgeführt wird.

Es muss aber immer im \texttt{xDef}-Ausdruck substituiert werden, denn
auch hier können Identifier auftreten, die Definition aus dem
\texttt{With}-Ausdruck soll aber nur im Rumpf und nicht in \texttt{xDef}
gelten.

\hypertarget{first-order-funktionen-f1-wae}{%
\section{First-Order-Funktionen
(F1-WAE)}}

Identifier ermöglichen Abstraktion bei mehrfach auftretenden,
identischen Teilausdrücken (\emph{``Magic Literals''}) -- bspw. kann
damit eine Konstante gebunden werden, die in einer Berechnung häufig
vorkommt.

Unterscheiden sich die Teilausdrücke aber immer an einer oder an wenigen
Stellen, so sind First-Order-Funktionen notwendig, um zu abstrahieren.
Die Ausdrücke \texttt{5*3+1}, \texttt{5*2+1} und \texttt{5*7+1} lassen
sich etwa mit \texttt{f(x)\ =\ 5*x+1} schreiben als \texttt{f(3)},
\texttt{f(2)} und \texttt{f(7)}. Weitere Beispiele dieser Abstraktion
wären die Funktionen \texttt{square(n)\ =\ n*n} und
\texttt{avg(x,y)\ =\ (x+y)/2}.

First-Order-Funktionen werden über einen Bezeichner aufgerufen, können
aber nicht als Parameter übergeben werden und sind nicht Ausdrücke (Typ
\texttt{Exp}).

Wir legen zwei Sprachkonstrukte für Funktionsaufrufe und
Funktionsdefinitionen an. Aufrufe sind Expressions und bestehen aus dem
Bezeichner der Funktion sowie einer Liste von Argumenten, Definitionen
bestehen aus einer Liste von Parametern und einem Rumpf. In einer
globalen Map werden Funktionsbezeichnern Funktionsdefinitionen
zugewiesen, die Funktionen werden also außerhalb des Programms definiert
(im Gegensatz zu Bindungen mit \texttt{With}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Call}\NormalTok{(f: String, args: List[Exp]) }\KeywordTok{extends}\NormalTok{ Exp}

\KeywordTok{case} \KeywordTok{class} \FunctionTok{FunDef}\NormalTok{(params: List[String], body: Exp)}
\KeywordTok{type}\NormalTok{ Funs = Map[String, FunDef]}
\end{Highlighting}
\end{Shaded}

\hypertarget{substitutionsbasierter-interpreter}{%
\subsection{Substitutionsbasierter
Interpreter}\label{substitutionsbasierter-interpreter}}

Die bereits implementierten Bindungen mit \texttt{With} und die
Funktionen verwenden getrennte \emph{Namespaces}, es kann also der
gleiche Bezeichner für eine Konstante und für eine Funktion verwendet
werden, die Namensvergabe ist unabhängig voneinander
(\href{https://github.com/DavidLaewen/programmiersprachen1/blob/main/additional-material/F1-WAESharedNamespace.scala}{hier}
eine alternative Implementation mit geteiltem Namespace).

Wir erweitern \texttt{subst} um den \texttt{Call}-Fall, dabei wird die
Substitution mit der \texttt{map}-Funktion auf alle Funktionsargumente
angewandt.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{subst}\NormalTok{(body: Exp, i: String, v: Num) : Exp = body }\KeywordTok{match}\NormalTok{ \{}
  \CommentTok{// ...}
  \KeywordTok{case} \FunctionTok{Call}\NormalTok{(f,args) =\textgreater{} }\FunctionTok{Call}\NormalTok{(f, args.}\FunctionTok{map}\NormalTok{(}\FunctionTok{subst}\NormalTok{(\_,i,v)))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In \texttt{eval} überreichen wir zusätzlich immer die Map, in der
Funktionen definiert sind. Der neue Match-Zweig ist hier deutlich
komplizierter:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp, funs: Funs) : Int = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} n}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Unbound identifier "}\NormalTok{+x)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{eval}\NormalTok{(l,funs)+}\FunctionTok{eval}\NormalTok{(r,funs)}
  \KeywordTok{case} \FunctionTok{With}\NormalTok{(x,xDef,b) =\textgreater{} }\FunctionTok{eval}\NormalTok{(}\FunctionTok{subst}\NormalTok{(b,x,}\FunctionTok{Num}\NormalTok{(}\FunctionTok{eval}\NormalTok{(xDef,funs))), funs)}
  \KeywordTok{case} \FunctionTok{Call}\NormalTok{(f,args) =\textgreater{} \{}
    \KeywordTok{val}\NormalTok{ fDef = }\FunctionTok{funs}\NormalTok{(f)}
    \KeywordTok{val}\NormalTok{ vArgs = args.}\FunctionTok{map}\NormalTok{(}\FunctionTok{eval}\NormalTok{(\_,funs))}
    \KeywordTok{if}\NormalTok{ (fDef.}\FunctionTok{params}\NormalTok{.}\FunctionTok{size}\NormalTok{ != vArgs.}\FunctionTok{size}\NormalTok{)}
\NormalTok{      sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Incorrect number of args in call to "}\NormalTok{+f)}
    \KeywordTok{val}\NormalTok{ substBody = fDef.}\FunctionTok{params}\NormalTok{.}\FunctionTok{zip}\NormalTok{(vArgs).}\FunctionTok{foldLeft}\NormalTok{(fDef.}\FunctionTok{body}\NormalTok{)(}
\NormalTok{      (b,pv) =\textgreater{} }\FunctionTok{subst}\NormalTok{(b, pv.}\FunctionTok{\_1}\NormalTok{, }\FunctionTok{Num}\NormalTok{(pv.}\FunctionTok{\_2}\NormalTok{))}
\NormalTok{    )}
    \FunctionTok{eval}\NormalTok{(substBody,funs)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{f} ist ein Bezeichner vom Typ \texttt{String}, \texttt{args} ist
die Liste der Argumente des Aufrufs vom Typ \texttt{List{[}Exp{]}}.

Zuerst wird die Definition von \texttt{f} in \texttt{funs}
nachgeschlagen und das Ergebnis an \texttt{fDef} gebunden. Mit
\texttt{map} werden dann alle Argumente in der Liste vollständig
ausgewertet. \texttt{vArgs} ist die Liste der ausgewerteten Argumente
mit Einträgen vom Typ \texttt{Int}. Als nächstes wird geprüft, dass die
Argumentliste \texttt{vArgs} und die Parameterliste \texttt{fDef.params}
die selbe Länge besitzen, ist dies nicht der Fall, so wird ein Fehler
geworfen.

Nun wird für jeden Parameter in der Parameterliste die Substitution im
Rumpf \texttt{fDef.body} mit dem entsprechenden Argument aus
\texttt{vArgs} ausgeführt. Dies ist durch \texttt{zip} und
\texttt{foldLeft} implementiert. \texttt{fDef.params.zip(vArgs)} erzeugt
eine Liste vom Typ \texttt{List{[}(String,Int){]}}, in der jeder
Parameter mit dem korrespondierenden Argument in einem Tupel vorliegt.
\texttt{foldLeft} erhält \texttt{body} als Startwert und wendet dann
(vom Ende der Liste beginnend) nacheinander für jedes Tupel die
entsprechende Substitution an. Es werden also Aufrufe von \texttt{subst}
geschachtelt, wobei die innereste Substitution auf dem ursprünglichen
Rumpf \texttt{body} ausgeführt wird.

Zuletzt wird \texttt{eval} rekursiv auf dem Rumpf, in dem alle
Substitutionen durchgeführt wurden, aufgerufen.

Es ist nun möglich, nicht-terminierende Programme zu verfassen. Wird in
der Definition einer Funktion die Funktion selbst aufgerufen, so
entsteht eine Endlosschleife.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ fm = Map(}\StringTok{"square"}\NormalTok{ {-}\textgreater{} }\FunctionTok{FunDef}\NormalTok{(List(}\StringTok{"x"}\NormalTok{), }\FunctionTok{Mul}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"x"}\NormalTok{)),}
             \StringTok{"succ"}\NormalTok{ {-}\textgreater{} }\FunctionTok{FunDef}\NormalTok{(List(}\StringTok{"x"}\NormalTok{), }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\DecValTok{1}\NormalTok{)),}
             \StringTok{"myAdd"}\NormalTok{ {-}\textgreater{} }\FunctionTok{FunDef}\NormalTok{(List(}\StringTok{"x"}\NormalTok{,}\StringTok{"y"}\NormalTok{), }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"y"}\NormalTok{)),}
             \StringTok{"forever"}\NormalTok{ {-}\textgreater{} }\FunctionTok{FunDef}\NormalTok{(List(}\StringTok{"x"}\NormalTok{), }\FunctionTok{Call}\NormalTok{(}\StringTok{"forever"}\NormalTok{, List(}\StringTok{"x"}\NormalTok{))))}

\KeywordTok{val}\NormalTok{ a = }\FunctionTok{Call}\NormalTok{(}\StringTok{"square"}\NormalTok{, List(}\FunctionTok{Add}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)))}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{eval}\NormalTok{(fm,a) == }\DecValTok{16}\NormalTok{)}
\KeywordTok{val}\NormalTok{ b = }\FunctionTok{Mul}\NormalTok{(}\DecValTok{2}\NormalTok{, }\FunctionTok{Call}\NormalTok{(}\StringTok{"succ"}\NormalTok{, List(}\FunctionTok{Num}\NormalTok{(}\DecValTok{20}\NormalTok{))))}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{eval}\NormalTok{(fm,b) == }\DecValTok{42}\NormalTok{)}
\KeywordTok{val}\NormalTok{ c = }\FunctionTok{Call}\NormalTok{(}\StringTok{"myAdd"}\NormalTok{, List(}\FunctionTok{Num}\NormalTok{(}\DecValTok{40}\NormalTok{), }\FunctionTok{Num}\NormalTok{(}\DecValTok{2}\NormalTok{)))}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{eval}\NormalTok{(fm,c) == }\DecValTok{42}\NormalTok{)}

\KeywordTok{val}\NormalTok{ forever = }\FunctionTok{Call}\NormalTok{(}\StringTok{"forever"}\NormalTok{, List(}\FunctionTok{Num}\NormalTok{(}\DecValTok{0}\NormalTok{)))}
\CommentTok{// eval(fm,forever) does not terminate}
\end{Highlighting}
\end{Shaded}

\hypertarget{umgebungsbasierter-interpreter}{%
\subsection{Umgebungsbasierter
Interpreter}\label{umgebungsbasierter-interpreter}}

Unsere bisherige Implementierung von Substitution würde im Ausdruck

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{With}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FunctionTok{With}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\FunctionTok{With}\NormalTok{(}\StringTok{"z"}\NormalTok{, }\DecValTok{3}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\StringTok{"z"}\NormalTok{)))))}
\end{Highlighting}
\end{Shaded}

folgende Schritte durchlaufen:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{With}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\FunctionTok{With}\NormalTok{(}\StringTok{"z"}\NormalTok{, }\DecValTok{3}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\DecValTok{1}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\StringTok{"z"}\NormalTok{))))}
\CommentTok{// \textasciitilde{}\textasciitilde{}\textgreater{}}
\FunctionTok{With}\NormalTok{(}\StringTok{"z"}\NormalTok{, }\DecValTok{3}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\DecValTok{1}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\DecValTok{2}\NormalTok{, }\StringTok{"z"}\NormalTok{)))}
\CommentTok{// \textasciitilde{}\textasciitilde{}\textgreater{}}
\FunctionTok{Add}\NormalTok{(}\DecValTok{1}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Dabei wird der Ausdruck \texttt{Add("x",\ Add("y",\ "z"))} insgesamt
drei Mal traversiert, um für jedes \texttt{With} die Substitution
durchzuführen. Die Komplexität bei Ausdrücken der Länge \(n\) ist
\(\mathcal{O}(n^2)\). Wir suchen deshalb eine effizientere Art, um
Substitution umzusetzen.

Statt beim Auftreten eines \texttt{With}-Ausdrucks direkt zu
substituieren, wollen wir uns in einer zusätzlichen Datenstruktur
merken, welche Substitutionen wir im weiteren Ausdruck vornehmen müssen,
so dass der zusätzliche Durchlauf wegfällt.

Hierzu verwenden wir wieder (wie in
\protect\hyperlink{identifier-mit-umgebung-aeid}{AEId}) eine
\emph{Umgebung}, diese wird aber nicht getrennt und global definiert,
sondern bei der Evaluation stetig angepasst. Tritt etwa ein
\texttt{With}-Ausdruck auf, so wird der entsprechende Identifier mit dem
Auswertungsergebnis der zugewiesenen Expression in die Map eingetragen
(die zu Beginn der Auswertung leer ist).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ Env = Map[String, Int]}

\KeywordTok{def} \FunctionTok{evalWithEnv}\NormalTok{(funs: FunDef, env: Env, e: Exp) : Int = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} n}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} }\FunctionTok{env}\NormalTok{(x)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{evalWithEnv}\NormalTok{(funs,env,l) + }\FunctionTok{evalWithEnv}\NormalTok{(funs,env,r)}
  \KeywordTok{case} \FunctionTok{With}\NormalTok{(x,xDef,body) =\textgreater{} }
    \FunctionTok{evalWithEnv}\NormalTok{(funs, env+(x {-}\textgreater{} }\FunctionTok{evalWithEnv}\NormalTok{(funs,env,xDef)), body)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Da nun die notwendigen Substitutionen nicht direkt ausgeführt, sondern
in der Umgebung hinterlegt und ``aufgeschoben'' werden, können wir auf
nicht-substituierte Identifier stoßen. Diese schlagen wir dann in der
Umgebung \texttt{env} nach, um sie durch den Wert zu ersetzen, an den
sie gebunden sind.

Das vorherige Beispiel wird nun folgendermaßen ausgewertet:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{With}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FunctionTok{With}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\FunctionTok{With}\NormalTok{(}\StringTok{"z"}\NormalTok{, }\DecValTok{3}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\StringTok{"z"}\NormalTok{))))), Map()}
\CommentTok{// \textasciitilde{}\textasciitilde{}\textgreater{}}
\FunctionTok{With}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\FunctionTok{With}\NormalTok{(}\StringTok{"z"}\NormalTok{, }\DecValTok{3}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\StringTok{"z"}\NormalTok{)))), Map(}\StringTok{"x"}\NormalTok{ {-}\textgreater{} }\DecValTok{1}\NormalTok{)}
\CommentTok{// \textasciitilde{}\textasciitilde{}\textgreater{}}
\FunctionTok{With}\NormalTok{(}\StringTok{"z"}\NormalTok{, }\DecValTok{3}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\StringTok{"z"}\NormalTok{))), Map(}\StringTok{"x"}\NormalTok{ {-}\textgreater{} }\DecValTok{1}\NormalTok{, }\StringTok{"y"}\NormalTok{ {-}\textgreater{} }\DecValTok{2}\NormalTok{)}
\CommentTok{// \textasciitilde{}\textasciitilde{}\textgreater{}}
\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\StringTok{"z"}\NormalTok{)), Map(}\StringTok{"x"}\NormalTok{ {-}\textgreater{} }\DecValTok{1}\NormalTok{, }\StringTok{"y"}\NormalTok{ {-}\textgreater{} }\DecValTok{2}\NormalTok{, }\StringTok{"z"}\NormalTok{ {-}\textgreater{} }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Die Komplexität ist nun (unter der Annahme, dass die Map-Operationen in
konstanter Komplexität haben) linear in Abhängigkeit von der Länge des
Ausdrucks.

Das Scoping ist auch in dieser Implementation lexikalisch, da die
Umgebung rekursiv weitergereicht wird und nicht global ist. Somit gilt
eine Bindung nur in Unterausdrücken des bindenden Ausdruckes und nicht
an anderen Stellen im Programm. Die \texttt{+}-Operation auf Maps fügt
nicht nur Bindungen für neue Elemente ein, sondern ersetzt auch den
Abbildungswert bei bereits enthaltenen Elementen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ m = Map(}\StringTok{"a"}\NormalTok{ {-}\textgreater{} }\DecValTok{1}\NormalTok{)}
\NormalTok{m = m+(}\StringTok{"b"}\NormalTok{ {-}\textgreater{} }\DecValTok{2}\NormalTok{)}
\NormalTok{m = m+(}\StringTok{"a"}\NormalTok{ {-}\textgreater{} }\DecValTok{3}\NormalTok{)}
\CommentTok{// \textasciitilde{}\textasciitilde{}\textgreater{}}
\NormalTok{m: Map[String,Int] = Map(}\StringTok{"a"}\NormalTok{ {-}\textgreater{} }\DecValTok{3}\NormalTok{, }\StringTok{"b"}\NormalTok{ {-}\textgreater{} }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Nun fehlt noch der \texttt{Call}-Fall. Hier bleiben die ersten drei
Zeilen nahezu identisch, aber anstelle der Faltung zur Substitution im
Rumpf erweitern wir einfach die leere Umgebung um die Parameternamen,
gebunden an die ausgewerteten Argumente:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{evalWithEnv}\NormalTok{(funs: FunDef, env: Env, e: Exp) : Int = e }\KeywordTok{match}\NormalTok{ \{}
\CommentTok{// ...}
  \KeywordTok{case} \FunctionTok{Call}\NormalTok{(f,args) =\textgreater{}}
    \KeywordTok{val}\NormalTok{ fDef = }\FunctionTok{funs}\NormalTok{(f)}
    \KeywordTok{val}\NormalTok{ vArgs = args.}\FunctionTok{map}\NormalTok{(}\FunctionTok{evalWithEnv}\NormalTok{(funs,env,\_))}
    \KeywordTok{if}\NormalTok{ (fDef.}\FunctionTok{args}\NormalTok{.}\FunctionTok{size}\NormalTok{ != vArgs.}\FunctionTok{size}\NormalTok{)}
\NormalTok{      sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Incorrect number of params in call to "}\NormalTok{ + f)}
    \FunctionTok{evalWithEnv}\NormalTok{(funs, Map()++fDef.}\FunctionTok{args}\NormalTok{.}\FunctionTok{zip}\NormalTok{(vArgs), fDef.}\FunctionTok{body}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Dabei können mit dem Operator \texttt{++} die Tupel in der Liste der Map
hinzugefügt werden.

Wir erweitern die leere Umgebung \texttt{Map()} anstelle der bisherigen
Umgebung \texttt{env}, da in unserer vorherigen Implementation auch nur
für die Funktionsparameter im Funktionsrumpf substituiert wurde (und
nicht für sonstige, aktuell geltende Bindungen). Die
\texttt{subst}-Funktion verändert nämlich die Funktionsdefinitionen in
keiner Weise und hat nicht einmal Zugriff auf diese.

\textbf{Äquivalenz des substitutions- und umgebungsbasierten
Interpreters:}

Für alle \texttt{funs:\ Funs,\ e:\ Exp} gilt:
\texttt{evalWithSubst(funs,e)\ =\ evalWithEnv(funs,Map(),e)}.

Nun gäbe es aber auch die Möglichkeit, die bisherige Umgebung
\texttt{env} zu erweitern und damit den Funktionsrumpf auszuwerten. In
diesem Fall würden wir lokale Bindungen, die an der Stelle des
\texttt{Call}-Ausdrucks gelten, in den Funktionsrumpf weitergeben.

Die Variante mit einer neuen, leeren Umgebung wird \emph{lexikalisches
Scoping} genannt, die Variante bei der \texttt{env} erweitert wird heißt
\emph{dynamisches Scoping}.

\hypertarget{lexikalisches-und-dynamisches-scoping}{%
\section{Lexikalisches und dynamisches
Scoping}\label{lexikalisches-und-dynamisches-scoping}}

\textbf{Lexikalisches (oder statisches) Scoping} bedeutet, dass der
Scope eines bindenden Vorkommens syntaktisch beschränkt ist, bspw. auf
einen Funktionsrumpf. In unserer Sprache wird für ein Vorkommen eines
Identifiers der Wert durch das erste bindende Vorkommen auf dem Weg vom
Identifier zur Wurzel des abstrakten Syntaxbaums (AST) bestimmt.

\textbf{Dynamisches Scoping} bedeutet, dass für ein Vorkommen eines
Identifiers der Wert durch das zuletzt ausgewertete bindende Vorkommen
bestimmt wird. Eine Bindung gilt dadurch während der gesamten weiteren
Programmausführung und ist nicht auf einen bestimmten Bereich im
Programms beschränkt.

Bei lexikalischem Scoping ist also der Ort für die Bedeutung
entscheidend, bei dynamischem Scoping der Programmzustand.

Das folgende Beispiel verursacht bei lexikalischem Scoping einen Fehler,
liefert aber bei dynamischem Scoping das Ergebnis \texttt{3}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ exFunMap = Map(}\StringTok{"f"}\NormalTok{ {-}\textgreater{} }\FunctionTok{FunDef}\NormalTok{(List(}\StringTok{"x"}\NormalTok{), }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"y"}\NormalTok{)))}
\KeywordTok{val}\NormalTok{ exExpr = }\FunctionTok{With}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FunctionTok{Call}\NormalTok{(}\StringTok{"f"}\NormalTok{, List(}\DecValTok{2}\NormalTok{)))}

\FunctionTok{evalWithEnv}\NormalTok{(exFunMap, Map(), exExpr)}
\end{Highlighting}
\end{Shaded}

Der Identifier \texttt{y} wird an den Wert \texttt{1} gebunden, bevor
die Funktion \texttt{f} aufgerufen wird, in deren Rumpf \texttt{y}
auftritt. \texttt{y} hat an diesem \emph{Ort} im Programm keine
Bedeutung, es kann aber ein \emph{Programmzustand} vorliegen, in dem
eine Bindung für \texttt{y} existiert.

Bei lexikalischem Scoping müssen Werte immer ``weitergereicht'' werden,
während bei dynamischen Scoping alle Bindungen zum Zeitpunkt eines
Funktionsaufrufs auch im Funktionsrumpf gelten. Diese automatische
Weitergabe kann in manchen Fällen ein explizites Überreichen ersparen,
führt aber in den meisten Fällen eher zu unerwarteten und unerwünschten
Nebenwirkungen.

Ein Beispiel für eine Verwendung von dynamischem Scoping wäre
\emph{Exception Handling} in Java. Wird in einem \emph{try-catch}-Block
eine Funktion \texttt{f} aufgerufen, die eine bestimmte Exception wirft,
so wird beim Werfen dieser Exception über eine Art von dynamischem
Scoping ermittelt, welcher ExceptionHandler zuständig ist (in dem die
Ausführungshistorie durchsucht wird).

\hypertarget{higher-order-funktionen-fae}{%
\section{Higher-Order-Funktionen
(FAE)}\label{higher-order-funktionen-fae}}

Funktionen erster Ordnung erlauben die Abstraktion über sich
wiederholende Muster, die an bestimmten Ausdruckspositionen variieren
(z.B. eine \texttt{square}- oder \texttt{avg}-Funktion). Liegt aber ein
Muster vor, bei dem eine Funktion variiert (z.B. bei der Komposition
zweier Funktionen), so ist keine Abstraktion möglich.

Hierfür sind Higher-Order-Funktionen notwendig, es braucht eine
Möglichkeit, Funktionen als Parameter zu übergeben, als Ergebnis
zurückzugeben und als Werte zu behandeln. Wir müssen also unsere
Implementation anpassen, so dass Funktionen nicht als ein vom Programm
getrenntes Konstrukt, sondern als Expressions vorliegen.

Wir entfernen also das Sprachkonstrukt \texttt{Call} und ergänzen
stattdessen die zwei folgenden Konstrukte:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Fun}\NormalTok{(param: String, body: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{App}\NormalTok{(funExpr: Exp, argExpr: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\end{Highlighting}
\end{Shaded}

Nun können wir Funktionen direkt im Programm definieren und binden,
wodurch wir keine getrennte \texttt{Funs}-Map mehr benötigen. Funktion
sind eine Form von Werten, solche ``namenslosen'' Funktionen werden
typischerweise \emph{anonyme Funktionen} genannt, im Kontext
funktionaler Sprachen auch \emph{Lambda-Ausdrücke}.

\texttt{With} ist jetzt sogar nur noch syntaktischer Zucker, wir können
bspw. \texttt{With("x",\ 5,\ Add("x",7))} ausdrücken mit
\texttt{App(Fun("x",\ Add("x",7)),\ 5)}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{wth}\NormalTok{(x: String, xdef: Exp, body: Exp) : Exp = }\FunctionTok{App}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(x, body), xdef)}
\end{Highlighting}
\end{Shaded}

Ein \texttt{Fun}-Ausdruck hat nur einen Parameter und ein
\texttt{App}-Ausdruck nur ein Argument (im Gegensatz zu unserer
Implementation von
\protect\hyperlink{first-order-funktionen-f1-wae}{First-Order-Funktionen}),
wir können jedoch Funktionen mit mehreren Parametern durch Currying
darstellen: \(f(x,y)= x+y\) entspricht \(f(x)(y) = x+y\) bzw. in der
Notation des Lambda-Kalküls \(\lambda x.\lambda y.x+y\).

\hypertarget{accidental-captures}{%
\subsection{Accidental Captures}\label{accidental-captures}}

Zuerst implementieren wir den Interpreter wieder durch Substitution:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{subst}\NormalTok{(e: Exp, i: String, v: Exp) : Exp = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(\_) =\textgreater{} e}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} }\KeywordTok{if}\NormalTok{ (x == i) v }\KeywordTok{else}\NormalTok{ e}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{Add}\NormalTok{(}\FunctionTok{subst}\NormalTok{(l,i,v), }\FunctionTok{subst}\NormalTok{(r,i,v))}
  \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(p,b) =\textgreater{}}
    \KeywordTok{if}\NormalTok{ (param == i) e }\KeywordTok{else} \FunctionTok{Fun}\NormalTok{(p, }\FunctionTok{subst}\NormalTok{(b,i,v))}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{App}\NormalTok{(}\FunctionTok{subst}\NormalTok{(f,i,v), }\FunctionTok{subst}\NormalTok{(a,i,v))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Hierbei entsteht ein neues Problem: Der zu substituierende Ausdruck
\texttt{v} muss nun den Typ \texttt{Exp} besitzen, damit Identifier auch
durch Funktionen (und nicht nur \texttt{Num}-Ausdrücke) substituiert
werden können. Dadurch kann es aber in manchen Fällen dazu kommen, dass
Identifier unbeabsichtigt gebunden werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ ac = }\FunctionTok{subst}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"y"}\NormalTok{)), }\StringTok{"y"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

In diesem Beispiel ist das \texttt{x} in \texttt{Add(x,\ 5)} nach der
Substitution an den Parameter \texttt{x} der Funktion gebunden, obwohl
dies vorher nicht der Fall war. Die dabei entstehende Bindung ist
unerwartet, dieses unerwünschte ``Einfangen'' eines Identifiers wird als
\emph{Accidental Capture} bezeichnet und allgemein als Verletzung von
lexikalischem Scoping angesehen.

\hypertarget{capture-avoiding-substitution}{%
\subsection{Capture-Avoiding
Substitution}\label{capture-avoiding-substitution}}

Zwei Funktionen sind \textbf{alpha-äquivalent}, wenn sie bis auf den
Namen des Parameters (oder der Parameter) identisch sind.
\texttt{Fun("x",\ Add("x",1))} und \texttt{Fun("y",\ Add("y",1))} sind
bspw. \emph{alpha-äquivalent}.

Wir nutzen Alpha-Äquivalenz, um Namenskonflikte und damit Accidental
Captures zu verhindern. Dabei wählen wir für den Parameter einer
Funktion einen neuen Namen, der weder im zu substituierenden Ausdruck
noch im aktuellen Ausdruck ungebunden auftritt. Wir brauchen also einen
``Generator'', um bisher ungenutzte Namen zu erzeugen, die wir dann zur
Umbenennung verwenden können.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{freshName}\NormalTok{(names: Set[String], default: String) : String = \{}
  \KeywordTok{var}\NormalTok{ last : Int = }\DecValTok{0}
  \KeywordTok{var}\NormalTok{ freshName = default}
  \KeywordTok{while}\NormalTok{ (names contains freshName) \{}
\NormalTok{    freshName = default + last}
\NormalTok{    last += }\DecValTok{1}
\NormalTok{  \}}
\NormalTok{  freshName}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Die Funktion gibt einen Namen zurück, der nicht in der Menge
\texttt{names} enthalten ist. Ist \texttt{default} nicht in der Menge
enthalten, so wird \texttt{default} ausgegeben, ansonsten wird eine Zahl
an die Eingabe \texttt{default} angehängt und schrittweise
inkrementiert, bis der entstehende String nicht Element der Menge ist.

Wir benötigen außerdem eine Funktion, die die Menge aller freien
Variablen in einem Ausdruck ausgibt, dazu verwenden wir den Datentyp
\texttt{Set}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{freeVars}\NormalTok{(e: Exp) : Set[String] = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(\_) =\textgreater{} Set.}\FunctionTok{empty}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} Set(x)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{freeVars}\NormalTok{(l) ++ }\FunctionTok{freeVars}\NormalTok{(r)}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{freeVars}\NormalTok{(f) ++ }\FunctionTok{freeVars}\NormalTok{(a)}
  \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(x,body) =\textgreater{} }\FunctionTok{freeVars}\NormalTok{(body) {-} x}
\NormalTok{\}}

\FunctionTok{assert}\NormalTok{(}\FunctionTok{freeVars}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{), }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"y"}\NormalTok{)) == Set(}\StringTok{"y"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Mithilfe dieser Funktionen können wir nun beim Substituieren Accidental
Captures verhindern, man spricht hierbei von \emph{Capture-Avoiding
Substitution}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{subst}\NormalTok{(e: Exp, i: String, v: Exp) : Exp = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(\_) =\textgreater{} e}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{Add}\NormalTok{(}\FunctionTok{subst}\NormalTok{(l,i,v), }\FunctionTok{subst}\NormalTok{(r,i,v))}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} }\KeywordTok{if}\NormalTok{ (x == i) v }\KeywordTok{else}\NormalTok{ e}
  \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(p,b) =\textgreater{}}
    \KeywordTok{if}\NormalTok{ (p == i) e }\KeywordTok{else}\NormalTok{ \{}
      \KeywordTok{val}\NormalTok{ fvs = }\FunctionTok{freeVars}\NormalTok{(e) ++ }\FunctionTok{freeVars}\NormalTok{(v) + i}
      \KeywordTok{val}\NormalTok{ nn = }\FunctionTok{freshName}\NormalTok{(fvs,p)}
      \FunctionTok{Fun}\NormalTok{(nn, }\FunctionTok{subst}\NormalTok{(}\FunctionTok{subst}\NormalTok{(b,p,}\FunctionTok{Id}\NormalTok{(nn)), i, v))}
\NormalTok{    \}}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f: Exp, a: Exp) =\textgreater{} }\FunctionTok{App}\NormalTok{(}\FunctionTok{subst}\NormalTok{(f,i,v), }\FunctionTok{subst}\NormalTok{(a,i,v))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Im \texttt{Fun}-Fall prüfen wir zuerst, ob der Parameter und der zu
ersetzende Identifier übereinstimmen. Ist dies der Fall, so lassen wir
den \texttt{Fun}-Ausdruck unverändert, da der Rumpf nicht im Scope des
bindenden Vorkommens liegt, für das substituiert wird.

Ansonsten bestimmen wir mit \texttt{freeVars} die Menge der freien
Variablen im aktuellen Ausdruck \texttt{e} sowie im einzusetzenden
Ausdruck \texttt{v} und vereinigen diese zusammen mit \texttt{i} (damit
nicht \texttt{i} als neuer Name gewählt und fälschlicherweise
substituiert wird, falls \texttt{i} nicht in \texttt{e} frei vorkommt).
Ausgehend von dieser Menge erzeugen wir mit \texttt{freshName} einen
neuen Bezeichner, mit dem wir dann den Parameternamen und alle Vorkommen
des Parameternamens im Rumpf ersetzen, bevor wir die Substitution im
Rumpf rekursiv fortsetzen. So ist garantiert, dass keine freien
Variablen durch die Funktion ``eingefangen'' werden.

\hypertarget{substitutionsbasierter-interpreter-a}{%
\subsection{Substitutionsbasierter
Interpreter}\label{substitutionsbasierter-interpreter-a}}

Da Funktionen nun Werte bzw. Ausdrücke sind, muss der Interpreter auch
Funktionen als Ergebnis einer Auswertung ausgeben können. Der
Rückgabewert von \texttt{eval} kann also nicht mehr \texttt{Int} sein,
stattdessen müssen wir \texttt{Exp} wählen.

Durch diesen Rückgabetyp gibt es aber auch eine neue Klasse von Fehlern,
die auftreten können: Es kann passieren, dass eine Zahl erwartet wird,
aber eine Funktion vorliegt, etwa wenn der linke Teil eines
\texttt{Add}-Ausdrucks zu einer Funktion auswertet. Auch der umgekehrte
Fall kann eintreten: In einem \texttt{App}-Ausdruck wertet der linke
Teil zu einer Zahl anstelle einer Funktion aus.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp) : Exp = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Unbound identifier: "}\NormalTok{ + x)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{eval}\NormalTok{(l),}\FunctionTok{eval}\NormalTok{(r)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{Num}\NormalTok{(a),}\FunctionTok{Num}\NormalTok{(b)) =\textgreater{} }\FunctionTok{Num}\NormalTok{(a+b)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(param,body) =\textgreater{} }\FunctionTok{eval}\NormalTok{(}\FunctionTok{subst}\NormalTok{(body,param,}\FunctionTok{eval}\NormalTok{(a))) }\CommentTok{// call{-}by{-}value}
    \CommentTok{// case Fun(param,body) =\textgreater{} eval(subst(body,param,a))    // call{-}by{-}name}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case}\NormalTok{ \_ =\textgreater{} e}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Aus diesem Grund müssen wir im \texttt{Add}- und \texttt{App}-Fall erst
beide Unterausdrücke auswerten und dann via Pattern-Matching prüfen, ob
jeweils der korrekte Typ vorliegt. Ist dies nicht der Fall, so werfen
wir einen Fehler. \texttt{Num}- und \texttt{Fun}-Ausdrücke werten zu
sich selbst aus, die Ausgabe des Interpreters ist immer vom Typ
\texttt{Num} oder \texttt{Fun}.

Wir könnten den Rückgabetyp also mit \texttt{Either{[}Num,Fun{]}}
präzisieren
(\href{https://github.com/DavidLaewen/programmiersprachen1/blob/main/additional-material/FAEWithEitherType.scala}{mögliche
Implementation}).

\hypertarget{umgebungsbasierter-interpreter-a}{%
\subsection{Umgebungsbasierter
Interpreter}\label{umgebungsbasierter-interpreter-a}}

Der Typ \texttt{Map{[}String,Int{]}} für die Umgebung ist nicht mehr
ausreichend, da auch \texttt{Fun}-Ausdrücke gebunden werden müssen. Wir
wählen also stattdessen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ Env = Map[String,Exp]}
\end{Highlighting}
\end{Shaded}

Der Interpreter ergibt sich größtenteils aus der
\protect\hyperlink{umgebungsbasierter-interpreter}{Implementation für
F1-WAE}, kombiniert mit dem
\protect\hyperlink{substitutionsbasierter-interpreter-a}{substitutionsbasiertem
Interpreter für FAE}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp, env: Env) : Exp = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{eval}\NormalTok{(l,env),}\FunctionTok{eval}\NormalTok{(r,env)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{Num}\NormalTok{(a),}\FunctionTok{Num}\NormalTok{(b)) =\textgreater{} }\FunctionTok{Num}\NormalTok{(a+b)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} }\FunctionTok{env}\NormalTok{(x)}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f,env) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(p,b) =\textgreater{}}
      \FunctionTok{eval}\NormalTok{(b, Map(p {-}\textgreater{} }\FunctionTok{eval}\NormalTok{(a,env)))}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case}\NormalTok{ \_ =\textgreater{} e}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Wie in \protect\hyperlink{umgebungsbasierter-interpreter}{F1-WAE}
erweitern wir bei der Rekursion in einen Funktionsrumpf die Umgebungs
nicht, da sonst dynamisches Scoping vorliegen würde. In diesem Fall
würde der Ausdruck

\(\texttt{With}\; f = \lambda x.x+y:\;\; \texttt{With}\; y = 4:\; (f \;\; 1)\)

keinen Fehler verursachen, obwohl zum Zeitpunkt der Bindung von \(f\)
der Bezeichner \(y\) frei ist.

Stattdessen reichen wir also eine neue Umgebung weiter, die nur den
Parameter und das Argument der Funktion enthält.

Dieser Interpreter ist jedoch nicht äquivalent zum
\protect\hyperlink{substitutionsbasierter-interpreter-a}{substitutionsbasierten},
denn der Ausdruck

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ curry = }\FunctionTok{App}\NormalTok{( }\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{App}\NormalTok{( }\FunctionTok{Fun}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"y"}\NormalTok{)),}\DecValTok{2}\NormalTok{)), }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

wird von \texttt{evalWithSubst} zu \texttt{Num(5)} ausgewertet,
\texttt{evalWithEnv} wirft aber bei der Auswertung den Fehler
\texttt{key\ not\ found:\ x}:

\((\lambda x.(\lambda y.x+y \;\;\; 2)\;\; 3), \; \texttt{Map()}\)
\(\leadsto (\lambda y.x+y \;\;\; 2), \; \texttt{Map(x -> 3)}\)
\(\leadsto x+y, \;\; \texttt{Map(y -> 2)}\)
\(\leadsto \;\; \texttt{key not found: x}\)

Um dieses Problem zu umgehen, können wir nicht einfach die Umgebung im
\texttt{App}-Fall erweitern, weil das (wie bereits gezeigt) zu
dynamischem Scoping führen würde. Stattdessen müssen wir uns bei der
Auswertung einer Funktion sowohl die Funktion selbst, als auch die
Umgebung zum Zeitpunkt der Instanziierung merken.

So ein Paar aus Funktion und Umgebung wird \emph{Closure} genannt.

\hypertarget{closures}{%
\subsection{Closures}\label{closures}}

Wir definieren einen neuen Typ \texttt{Value} neben \texttt{Exp}, so
dass wir Ausdrücke und die Ergebnisse deren Auswertung wieder
unterscheiden können:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Value}
\KeywordTok{type}\NormalTok{ Env = Map[String,Value]}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{NumV}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ Value}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{ClosureV}\NormalTok{(f: Fun, env: Env) }\KeywordTok{extends}\NormalTok{ Value}
\end{Highlighting}
\end{Shaded}

\texttt{Fun}-Ausdrücke liegen nun nach ihrer Auswertung als Closures
vor, der neue Interpreter hat den Rückgabetyp \texttt{Value} und gibt
Zahlen (\texttt{NumV}) und Closures (\texttt{ClosureV}) anstelle von
Zahlen (\texttt{Num}) und Funktionen (\texttt{Fun}) aus.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp, env: Env) : Value = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(n)}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} }\FunctionTok{env}\NormalTok{(x)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{eval}\NormalTok{(l,env),}\FunctionTok{eval}\NormalTok{(r,env)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(a),}\FunctionTok{NumV}\NormalTok{(b)) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(a+b)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case}\NormalTok{ f@}\FunctionTok{Fun}\NormalTok{(\_,\_) =\textgreater{} }\FunctionTok{ClosureV}\NormalTok{(f,env)}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f,env) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{ClosureV}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(p,b),cEnv) =\textgreater{}}
      \FunctionTok{eval}\NormalTok{(b, cEnv+(p {-}\textgreater{} }\FunctionTok{eval}\NormalTok{(a,env)))}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Bei der Auswertung eines \texttt{Fun}-Ausdrucks wird nun ein Closure aus
dem Ausdruck und der aktuellen Umgebung erzeugt. Im \texttt{App}-Zweig
verwenden wir nach der Auswertung der Funktion die Umgebung aus dem
entstehenden Closure -- erweitert um die Bindung des Parameters an das
ausgewertete Argument -- um den Rumpf auszuwerten.

Durch das ``Aufschieben'' der notwendigen Substitutionen in der Umgebung
ist es also im Fall von Funktionen notwendig geworden, die
aufgeschobenen Substitutionen für die spätere Auswertung zu hinterlegen.

Für alle \texttt{e:\ Exp} gilt: - \texttt{evalWithSubst(e)\ ==\ Num(n)}
\(\Longleftrightarrow\) \texttt{evalWithEnv(e,Map())\ ==\ NumV(n)}

\begin{itemize}
\tightlist
\item
  Ist \texttt{evalWithSubst(e)\ ==\ Fun(p,b)} und
  \texttt{evalWithEnv(e)\ ==\ ClosureV(f,env)}, dann entspricht
  \texttt{Fun(p,b)} dem Ausdruck \texttt{f}, in dem für alle Bindungen
  in \texttt{env} Substitution durchgeführt wurde.
\end{itemize}

Closures sind ein fundamental wichtiges Konzept und tauchen in der
Implementation fast aller Programmiersprachen auf.

Ein \textbf{Closure} ist ein Paar, bestehend aus einer
Funktionsdefinition und der Umgebung, die bei der Auswertung der
Funktionsdefinition aktiv bzw. gültig war.

Im
\protect\hyperlink{substitutionsbasierter-interpreter-a}{substitiutionsbasiertem
Interpreter} wird beim Auswerten der Funktionsdefinition sofort im Rumpf
substituiert. Beim
\protect\hyperlink{umgebungsbasierter-interpreter-a}{umgebungsbasiertem
Interpreter} muss hingegen die Umgebung zum Zeitpunkt der Auswertung
gespeichert werden, so dass der Interpreter beim Erreichen der
Identifier die richtigen Werte einsetzen kann.

\hypertarget{muxe4chtigkeit-von-fae}{%
\section{Mächtigkeit von FAE}\label{muxe4chtigkeit-von-fae}}

Wir können in \protect\hyperlink{higher-order-funktionen-fae}{FAE}
nicht-terminierende Ausdrücke verfassen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ omega = }\FunctionTok{App}\NormalTok{( }\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"x"}\NormalTok{)), }\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"x"}\NormalTok{)) )}
\end{Highlighting}
\end{Shaded}

In \texttt{eval} betreten wir den \texttt{App}-Fall, dort wird
substituiert, wodurch wieder \texttt{omega} entsteht.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{assert}\NormalTok{(}\FunctionTok{subst}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"x"}\NormalTok{), }\StringTok{"x"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"x"}\NormalTok{))) ==}
\FunctionTok{App}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"x"}\NormalTok{)), }\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"x"}\NormalTok{))))}
\end{Highlighting}
\end{Shaded}

\texttt{omega} wird im \emph{Lambda-Kalkül} notiert als
\((\lambda x.(x \; x) \;\; \lambda x.(x \; x))\), der gesamte vordere
Ausdruck wird auf den hinteren Ausdruck angewendet, der hintere Ausdruck
wird in den Rumpf des vorderen Ausdrucks für \(x\) eingesetzt, wodurch
wieder der ursprüngliche Ausdruck entsteht.

FAE ist Turing-mächtig, es können also alle Turing-berechenbaren
Funktionen repräsentiert werden. Die Sprache entspricht nämlich dem von
\href{https://en.wikipedia.org/wiki/Alonzo_Church}{Alonzo Church}
eingeführten Turing-mächtigen
\href{https://en.wikipedia.org/wiki/Lambda_calculus}{Lambda-Kalkül},
erweitert um Zahlen und Addition.

\hypertarget{lambda-kalkuxfcl}{%
\subsection{Lambda-Kalkül}\label{lambda-kalkuxfcl}}

Entfernen wir aus \protect\hyperlink{higher-order-funktionen-fae}{FAE}
den \texttt{Num}- und den \texttt{Add}-Fall, so erhalten wir eine
Sprache, die dem \emph{Lambda-Kalkül} entspricht:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Id}\NormalTok{(name: String) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Fun}\NormalTok{(param: String, body: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{App}\NormalTok{(fun: Exp, arg: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\end{Highlighting}
\end{Shaded}

Der Lambda-Kalkül ist Turing-vollständig, es können darin beliebige
Berechnungen ausgedrückt werden. In seiner reinen Form ist es nicht
unbedingt eine praktische oder sinnvolle Sprache, dennoch ist der
Lambda-Kalkül von einem theoretischen Standpunkt relevant und
betrachtenswert.

In dieser Sprache ist jeder Wert eine Funktion (bzw. ein Closure),
wodurch keine Typfehler auftreten können.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Value}
\KeywordTok{type}\NormalTok{ Env = Map[String, Value]}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{ClosureV}\NormalTok{(f: Fun, env: Env) }\KeywordTok{extends}\NormalTok{ Value}
\end{Highlighting}
\end{Shaded}

Um mit dieser minimalistischen Sprache sinnvoll arbeiten zu können, sind
Kodierungen für verschiedene Datentypen notwendig, dazu kann man bspw.
die sogenannten \emph{Church Encodings} verwenden.

\hypertarget{church-kodierungen}{%
\subsection{Church-Kodierungen}\label{church-kodierungen}}

\textbf{Booleans} werden als ihre ``eigene If-Then-Else-Funktion''1
definiert. Darauf basierend lassen sich diverse Bool'sche Operationen
definieren:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ t = }\FunctionTok{Fun}\NormalTok{(}\StringTok{"t"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"f"}\NormalTok{,}\StringTok{"t"}\NormalTok{)) }\CommentTok{// true}
\KeywordTok{val}\NormalTok{ f = }\FunctionTok{Fun}\NormalTok{(}\StringTok{"t"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"f"}\NormalTok{,}\StringTok{"f"}\NormalTok{)) }\CommentTok{// false}

\KeywordTok{val}\NormalTok{ ifTE = }\FunctionTok{Fun}\NormalTok{(}\StringTok{"c"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"t"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"e"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"c"}\NormalTok{,}\StringTok{"t"}\NormalTok{),}\StringTok{"e"}\NormalTok{))))}
\KeywordTok{val}\NormalTok{ not = }\FunctionTok{Fun}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"a"}\NormalTok{, f), t)) }\CommentTok{// if a then False else True}
\KeywordTok{val}\NormalTok{ and = }\FunctionTok{Fun}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{), f))) }\CommentTok{// if a then b else False}
\KeywordTok{val}\NormalTok{ or = }\FunctionTok{Fun}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"a"}\NormalTok{, t), }\StringTok{"b"}\NormalTok{)))  }\CommentTok{// if a then True else b}
\end{Highlighting}
\end{Shaded}

\textbf{Natürliche Zahlen} können wir als
\href{https://de.wikipedia.org/wiki/Peano-Axiome}{Peano-Zahlen} durch
eine Nullfunktion und eine Nachfolgerfunktion kodieren. Dabei wird die
Zahl \(n\) dargestellt durch die \(n\)-fache Anwendung einer Funktion
\(s\) auf einen Startwert \(z\).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ zero = }\FunctionTok{Fun}\NormalTok{(}\StringTok{"s"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"z"}\NormalTok{,}\StringTok{"z"}\NormalTok{))}
\KeywordTok{val}\NormalTok{ succ = }\FunctionTok{Fun}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"s"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"z"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\StringTok{"s"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\StringTok{"s"}\NormalTok{), }\StringTok{"z"}\NormalTok{)))))}
\KeywordTok{val}\NormalTok{ one = }\FunctionTok{App}\NormalTok{(succ,zero) }\CommentTok{// = Fun("s", Fun("z", App("s","z")))}
\KeywordTok{val}\NormalTok{ two = }\FunctionTok{App}\NormalTok{(succ,one) }\CommentTok{// = Fun("s", Fun("z", App("s", App("s","z"))))}
\KeywordTok{val}\NormalTok{ three = }\FunctionTok{App}\NormalTok{(succ,two)}

\KeywordTok{val}\NormalTok{ add = }
  \FunctionTok{Fun}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"s"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"z"}\NormalTok{, }
    \FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"a"}\NormalTok{,}\StringTok{"s"}\NormalTok{), }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"b"}\NormalTok{,}\StringTok{"s"}\NormalTok{),}\StringTok{"z"}\NormalTok{))))))}
\KeywordTok{val}\NormalTok{ mul = }
  \FunctionTok{Fun}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"s"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"z"}\NormalTok{, }
    \FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\StringTok{"b"}\NormalTok{,}\StringTok{"s"}\NormalTok{)), }\StringTok{"z"}\NormalTok{)))))}
\end{Highlighting}
\end{Shaded}

In der \texttt{succ}-Funktion wird der Ausdruck erst ``ausgepackt'',
indem er auf das \(s\) und dann auf das \(z\) angewendet wird, dann wird
der zusätzliche Aufruf von \(s\) hinzugefügt und zuletzt wird der
Ausdruck wieder zwei Mal in eine Funktion geschachtelt, um \(s\) und
\(z\) wieder zu parametrisieren.

Bei der Addition wird der Startwert für \(a\) durch \(b\) ersetzt,
wodurch die \texttt{succ}-Operation \(a\)-Mal auf \(b\) durchgeführt
wird, bei der Multiplikation wird \(a\)-Mal \(b\) auf den Startwert
addiert.

Durch ein Spachkonstrukt \texttt{printDot()}, der bei der Auswertung die
Identitätsfunktion ausgibt und einen Punkt druckt, lassen sich durch den
folgenden Ausdruck die unären Zahlenkodierungen visualisieren:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ printNum = }\FunctionTok{Fun}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\FunctionTok{printDot}\NormalTok{())), f))}
\end{Highlighting}
\end{Shaded}

Wir können auch mit einer Funktion prüfen, ob eine Zahl 0 ist. Da
\texttt{zero} als \texttt{Fun("s",\ Fun("z","z"))} kodiert ist, liefert
der folgende Ausdruck für 0 \(\texttt{True}\), für Zahlen größer 0 die
\(n\)-fache Anwendung von \(\lambda x.\texttt{False}\) auf \texttt{t},
also \(\texttt{False}\).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ isZero = }\FunctionTok{Fun}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{,f)),t))}
\end{Highlighting}
\end{Shaded}

Es können auch eine Vorgängerfunktion \texttt{pred} und negative Zahlen
mithilfe des sogenannten \emph{Pairing Trick} kodiert werden, was jedoch
deutlich aufwändiger ist.

Auch \textbf{Listen} können im Lambda-Kalkül kodiert werden. Die
Grundidee ist es, zur Repräsentation die leere Liste \(e\) und
wiederholte Anwendungen von \(c\) (\texttt{cons}) zu nutzen. Die Liste
\(x_1,x_2,...,x_n\) wird also durch
\(\lambda c. \lambda e. c(x_1, c(... c(x_{n-1}, c(x_n,e))...))\)
kodiert.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ empty = }\FunctionTok{Fun}\NormalTok{(}\StringTok{"c"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"e"}\NormalTok{,}\StringTok{"e"}\NormalTok{))}
\KeywordTok{val}\NormalTok{ cons =}
  \FunctionTok{Fun}\NormalTok{(}\StringTok{"h"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"r"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"c"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"e"}\NormalTok{,}
    \FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"c"}\NormalTok{,}\StringTok{"h"}\NormalTok{), }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"r"}\NormalTok{,}\StringTok{"c"}\NormalTok{), }\StringTok{"e"}\NormalTok{))))))}
\end{Highlighting}
\end{Shaded}

Die leere Liste \texttt{empty} besitzt die gleiche Kodierung wie
\texttt{zero} und \texttt{f}. Bei der \texttt{cons}-Operation wird die
Restliste \texttt{r} durch Applikation auf \texttt{c} und \texttt{e}
``entpackt'', durch Anwendung von \texttt{c} auf das Element \texttt{h}
und die ``entpackte'' Restliste wird das neue Kopfelement vorne an die
Restliste angefügt.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ list123 = }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(cons,one), }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(cons,two), }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(cons,three), empty)))}
\KeywordTok{val}\NormalTok{ listSum = }\FunctionTok{Fun}\NormalTok{(}\StringTok{"l"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\StringTok{"l"}\NormalTok{,add), zero))}
\end{Highlighting}
\end{Shaded}

Durch Applikationen von \texttt{cons} mit jeweils einem Kopfelement und
einer Restliste sowie der leeren Liste \texttt{empty} lassen sich Listen
kodieren, wie es bei \texttt{list123} zu sehen ist. Die Applikation
einer Liste mit einem \texttt{c} und einem \texttt{e} entspricht der
Listenfaltung, wie sie etwa in Scala oder Racket bzw. Scheme möglich
ist:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{List(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{).}\FunctionTok{fold}\NormalTok{(}\DecValTok{0}\NormalTok{)(\_+\_)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(foldr }\OperatorTok{+} \DecValTok{0}\NormalTok{ (}\KeywordTok{list} \DecValTok{1} \DecValTok{2} \DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Listen werden also sozusagen durch ihre Fold-Funktion (also durch ihre
Faltung mit den Argumenten \texttt{c} und \texttt{e}) repräsentiert.

Es können auch Listen von Listen kodiert werden, womit es eine
Repräsentation von Bäumen im Lambda-Kalkül gibt. Wie wir an unserer
eigenen Implementierung sehen können, lassen sich Programme im
Lambda-Kalkül sehr gut durch Baumstrukturen darstellen. Dadurch lassen
sich auch Lambda-Kalkül-Ausdrücke im Lambda-Kalkül selbst geschickt
repräsentieren und es ist möglich, ein Programm im Lambda-Kalkül zu
schreiben, das Ausdrücke im Lambda-Kalkül auswertet (vgl. universelle
Turing-Maschine).

\hypertarget{rekursion}{%
\subsection{Rekursion}\label{rekursion}}

Es ist auch möglich, Rekursion im Lambda-Kalkül zu implementieren. Aus
dem Programm
\texttt{omega\ =\ (x\ =\textgreater{}\ x\ x)\ (x\ =\textgreater{}\ x\ x)}
lässt sich das Programm
\texttt{Y\ f\ =\ (x\ =\textgreater{}\ f\ (x\ x))\ (x\ =\textgreater{}\ f\ (x\ x))}
konstruieren, mit dem Schleifen kodiert werden können. Das Programm
\texttt{Y} ist ein sogenannter \emph{Fixpunkt-Kombinator}.

Ein \textbf{Fixpunkt-Kombinator} ist ein Programm, mit dem der Fixpunkt
von Funktionen gebildet werden kann.

Bei der Auswertung von \texttt{Y\ f} entsteht ein Ausdruck der Form
\texttt{(f\ ...\ (f\ (f\ (f\ Y)))...)}.

\hypertarget{lazy-evaluationcall-by-name-lcfae}{%
\section{Lazy Evaluation/Call-By-Name
(LCFAE)}\label{lazy-evaluationcall-by-name-lcfae}}

Im
\protect\hyperlink{substitutionsbasierter-interpreter-a}{substitutionsbasierten
Interpreter} für FAE konnten wir im \texttt{App}-Fall zwischen zwei
möglichen Implementation wählen: Wir können das Argument vor der
Substitution im Rumpf auswerten, oder substituieren, ohne das Argument
vorher auszuwerten.

Die erste dieser \emph{Auswertungsstrategien} wird \emph{Call-By-Value}
genannt, die zweite \emph{Call-By-Name}.

Im substitutionsbasierten Interpreter gilt für alle \texttt{e:\ Exp}:

Ist \texttt{evalCBV(e)\ ==\ e1} und \texttt{evalCBN(e)\ ==\ e2}, dann
sind \texttt{e1} und \texttt{e2} äquivalent (falls Zahlen -- identisch,
falls Funktionen -- gleichbedeutend).

\texttt{evalCBV(App(Fun("x",0),\ omega))} terminiert nicht,
\texttt{evalCBN(App(Fun("x",0),\ omega))} liefert hingegen das Ergebnis
\texttt{Num(0)}. Der Call-By-Name-Interpreter terminiert auf strikt mehr
Programmen als der Call-By-Value-Interpreter.

Mit ``gleichbedeutend'' ist gemeint, dass sich die Funktionen gleich
verhalten, aber nicht zwingend identisch sind. Für den Ausdruck
\((\lambda x.(\lambda y.x+y) \;\;\; 1+1)\) würde
Call-By-Value-Auswertung das Ergebnis \(\lambda y.2+y\) liefern, während
Call-By-Name-Auswertung das Ergebnis \(\lambda y.(1+1)+y\) liefern
würde. Unterscheiden sich die ausgegebenen Funktionen, so ist die
Funktion im Ergebnis von \texttt{evalCBV} stets ``weiter ausgewertet''.

\hypertarget{nutzen-von-lazy-evaluation}{%
\subsection{Nutzen von Lazy
Evaluation}\label{nutzen-von-lazy-evaluation}}

Die Auswertungsstrategie eines Interpreters bzw. einer
Programmiersprache ist nicht nur eine Frage der Effizienz, sondern hat
auch Auswirkungen darauf, welche Programmstrukturen möglich sind.
Unendliche Datencontainer wie Streams sind bspw. nur durch \emph{Lazy
Evaluation} überhaupt implementierbar.

In der Sprache Haskell kann man etwa eine rekursive Funktion ohne
Abbruchkriterium schreiben, die die Quadratwurzel einer Zahl annähert.

Da Haskell \emph{lazy} ist, kann eine Funktion ohne Abbruchbedingung
definiert und mit verschiedenen Abbruchbedingungen aufgerufen werden,
eine Programmstruktur die durch die Auswertungsstrategie der Sprache
ermöglicht wird.

Der \texttt{evalCBN}-Interpreter erlaubt uns die Kodierung unendlicher
Listen in LCFAE durch Church-Encodings (Zusatzmaterial in
\texttt{08-lcfae.scala}).

\hypertarget{thunks}{%
\subsection{Thunks}\label{thunks}}

Im substitutionsbasierten Interpreter muss nur ein Funktionsaufruf
entfernt werden, um die Auswertungsstrategie zu wechseln. Im
umgebungsbasierten Interpreter müssen wir dagegen einige Änderungen
vornehmen.

Wir müssen bei Funktionsapplikation den Parameter in der Umgebung an das
Argument ohne vorherige Auswertung binden. Dabei stoßen wir auf das
gleiche Problem, das uns bei Funktionen begegnet ist: Im
Argument-Ausdruck, den wir an den Parameternamen binden, müssen noch
Bezeichner substituiert werden, wozu die aktuelle Umgebung benötigt
wird. Auf diese kann aber zum Zeitpunkt, zu dem das Argument ausgewertet
wird, nicht mehr zugegriffen werden.

Analog zu den Closures für Funktionen brauchen wir also eine
Datenstruktur, in der wir sowohl den Ausdruck, als auch die aktuelle
Umgebung ablegen. Solch ein Paar aus \texttt{Exp} und \texttt{Env}
nennen wir \texttt{Thunk}.

Die intutive Definition

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ Thunk = (Exp, Env)}
\KeywordTok{type}\NormalTok{ Env = Map[String, Thunk]}
\end{Highlighting}
\end{Shaded}

ist in Scala durch die gegenseitige Bezüglichkeit nicht möglich.
Stattdessen definieren wir den Interpreter als \texttt{trait}, wobei der
Typ \texttt{Thunk} und die Funktionen \texttt{delay} und \texttt{force}
abstrakt sind, so dass wir verschiedene Implementationen testen können.
Wie definieren \texttt{Env} als Klasse im Trait, so dass mit dem
abstrakten Type Member \texttt{Thunk} die rekursive Bezüglichkeit
hergestellt werden kann. Dadurch müssen wir auch \texttt{Value} im Trait
definieren.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ CBN \{}
  \KeywordTok{type}\NormalTok{ Thunk}
  \KeywordTok{case} \KeywordTok{class} \FunctionTok{Env}\NormalTok{(map: Map[String, Thunk]) \{}
    \KeywordTok{def} \FunctionTok{apply}\NormalTok{(key: String): Thunk = map.}\FunctionTok{apply}\NormalTok{(key)}
    \KeywordTok{def}\NormalTok{ +(other: (String, Thunk)) : Env = }\FunctionTok{Env}\NormalTok{(map+other)}
\NormalTok{  \}}

  \KeywordTok{def} \FunctionTok{delay}\NormalTok{(e: Exp, env: Env) : Thunk}
  \KeywordTok{def} \FunctionTok{force}\NormalTok{(t: Thunk) : Value}

  \KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Value}
  \KeywordTok{case} \KeywordTok{class} \FunctionTok{NumV}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ Value}
  \KeywordTok{case} \KeywordTok{class} \FunctionTok{ClosureV}\NormalTok{(f: Fun, env: Env) }\KeywordTok{extends}\NormalTok{ Value}
  
  \KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp, env: Env) : Value = e }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} }\FunctionTok{force}\NormalTok{(}\FunctionTok{env}\NormalTok{(x))}
    \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{}}
\NormalTok{      (}\FunctionTok{eval}\NormalTok{(l,env), }\FunctionTok{eval}\NormalTok{(r,env)) }\KeywordTok{match}\NormalTok{ \{}
        \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(v1),}\FunctionTok{NumV}\NormalTok{(v2)) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(v1+v2)}
        \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"can only add numbers"}\NormalTok{)}
\NormalTok{      \}}
    \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f,env) }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case} \FunctionTok{ClosureV}\NormalTok{(f,cEnv) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f.}\FunctionTok{body}\NormalTok{, cEnv + (f.}\FunctionTok{param}\NormalTok{ {-}\textgreater{} }\FunctionTok{delay}\NormalTok{(a,env)))}
      \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"can only apply functions"}\NormalTok{)}
\NormalTok{    \}}
    \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(n)}
    \KeywordTok{case}\NormalTok{ f@}\FunctionTok{Fun}\NormalTok{(x,body) =\textgreater{} }\FunctionTok{ClosureV}\NormalTok{(f,env)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Die \texttt{delay}-Funktion dient dazu, die Auswertung eines Ausdrucks
zu verzögern (also einen Thunk zu erzeugen), \texttt{force} dient dazu,
die ``aufgeschobene'' Auswertung zu erzwingen (also den Ausdruck im
Thunk mit der zugehörigen Umgebung auszuwerten). Im \texttt{Id}-Fall
schlagen wir den Bezeichner nach und erzwingen die Auswertung des daran
gebundenen Ausdrucks, im \texttt{App}-Fall verzögern wir die Auswertung
des Arguments, bevor wir es in der Umgebung an den Parameter binden.

Hier die konkrete Call-By-Name-Implementierung des \texttt{CBN}-Traits:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{object}\NormalTok{ CallByName }\KeywordTok{extends}\NormalTok{ CBN \{}
  \KeywordTok{case} \KeywordTok{class} \FunctionTok{Thunk}\NormalTok{(exp: Exp, env: Env)}
  \KeywordTok{def} \FunctionTok{delay}\NormalTok{(e: Exp, env: Env): Thunk = }\FunctionTok{Thunk}\NormalTok{(e,env)}
  \KeywordTok{def} \FunctionTok{force}\NormalTok{(t: Thunk): CallByName.}\FunctionTok{Value}\NormalTok{ = \{}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Forcing evaluation of expression "}\NormalTok{+t.}\FunctionTok{exp}\NormalTok{)}
    \FunctionTok{eval}\NormalTok{(t.}\FunctionTok{exp}\NormalTok{,t.}\FunctionTok{env}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Der Typ \texttt{Thunk} wird dabei mit den Feldern \texttt{exp} und
\texttt{env} definiert, diese werden durch \texttt{delay} mit dem
entsprechenden Ausdruck und der aktuellen Umgebung belegt. In
\texttt{force} werden die Felder ausgelesen und der Ausdruck mit der
hinterlegten Umgebung ausgewertet.

\hypertarget{call-by-need}{%
\subsection{Call-By-Need}\label{call-by-need}}

Während das Argument unter Call-By-Value immer genau ein Mal ausgewertet
wird, findet die Auswertung unter Call-By-Name für jede Verwendung
statt. Wird das Argument einer Funktion mehrmals mehrfach
weitergereicht, so kann die Anzahl der Aufrufe exponentiell wachsen. Die
Auswertungsstrategie kann also in vielen Fällen sehr ineffizient sein.

Eine bessere Alternative ist die Strategie \emph{Call-By-Name}. Dabei
wird nach der ersten Auswertung des Arguments das Ergebnis durch
\emph{Caching} gespeichert, so dass bei mehrfacher Auswertung das
abgespeicherte Ergebnis verwendet werden kann und Argumente höchstens
ein Mal ausgewertet werden.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{object}\NormalTok{ CallByNeed }\KeywordTok{extends}\NormalTok{ CBN \{}
  \KeywordTok{case} \KeywordTok{class} \FunctionTok{MemoThunk}\NormalTok{(e: Exp, env: Env) \{}
    \KeywordTok{var}\NormalTok{ cache: Value = \_}
\NormalTok{  \}}
  \KeywordTok{type}\NormalTok{ Thunk = MemoThunk}
  \KeywordTok{def} \FunctionTok{delay}\NormalTok{(e: Exp, env: Env): MemoThunk = }\FunctionTok{MemoThunk}\NormalTok{(e,env)}
  \KeywordTok{def} \FunctionTok{force}\NormalTok{(t: Thunk): CallByNeed.}\FunctionTok{Value}\NormalTok{ = \{}
    \KeywordTok{if}\NormalTok{ (t.}\FunctionTok{cache}\NormalTok{ != }\KeywordTok{null}\NormalTok{)}
      \FunctionTok{println}\NormalTok{ (}\StringTok{"Reusing cached value "}\NormalTok{+t.}\FunctionTok{cache}\NormalTok{+}\StringTok{" for expression "}\NormalTok{+t.}\FunctionTok{e}\NormalTok{)}
    \KeywordTok{else}\NormalTok{ \{}
      \FunctionTok{println}\NormalTok{(}\StringTok{"Forcing evaluation of expression: "}\NormalTok{+t.}\FunctionTok{e}\NormalTok{)}
\NormalTok{      t.}\FunctionTok{cache}\NormalTok{ = }\FunctionTok{eval}\NormalTok{(t.}\FunctionTok{e}\NormalTok{, t.}\FunctionTok{env}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{    t.}\FunctionTok{cache}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Wir implementieren den Typ \texttt{Thunk} wieder als mit den Feldern
\texttt{exp} und \texttt{env}, diesmal aber mit einer zusätzlichen
Variablenmitglied \texttt{cache}, in dem das Ergebnis der Auswertung
hinterlegt werden kann. Bei der Auswertung mit \texttt{force} wird
überprüft, ob das \texttt{cache}-Feld instanziiert wurde. Falls ja, kann
das Ergebnis direkt von dort übernommen werden, falls nein, wird der
Ausdruck mit der gespeicherten Umgebung ausgewertet und das Ergebnis in
\texttt{cache} hinterlegt, bevor es ausgegeben wird.

Anhand der \texttt{print}-Ausgaben lässt sich erkennen, dass etwa beim
folgenden Aufruf drei Mal auf den Cache zugegriffen wird:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{CallByNeed.}\FunctionTok{eval}\NormalTok{(}\FunctionTok{App}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"x"}\NormalTok{),}\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"x"}\NormalTok{))), }\FunctionTok{Add}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{,)))}
\end{Highlighting}
\end{Shaded}

\hypertarget{rekursive-bindings-rcfae}{%
\section{Rekursive Bindings (RCFAE)}\label{rekursive-bindings-rcfae}}

In FAE kann Rekursion zwar kodiert werden, im Gegensatz zu
\protect\hyperlink{first-order-funktionen-f1-wae}{F1-WAE} ist es aber
nicht möglich, dass eine Funktion sich selbst in ihrem Rumpf aufruft:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ forever = }\FunctionTok{wth}\NormalTok{(}\StringTok{"forever"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\StringTok{"forever"}\NormalTok{,}\StringTok{"x"}\NormalTok{)), }\FunctionTok{App}\NormalTok{(}\StringTok{"forever"}\NormalTok{,}\DecValTok{42}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Die Auswertung dieses Ausdrucks würde einen Fehler liefern, da der
Bezeichner \texttt{"forever"} im Rumpf der Funktion nicht gebunden ist,
sondern nur im dritten Ausdruck von \texttt{wth}.

Aus diesem Grund ist es auch nicht möglich, mit einem Sprachkonstrukt
\texttt{If0} rekursive Funktionen mit Abbruchbedingung zu definieren:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ facAttempt = }
  \FunctionTok{wth}\NormalTok{(}\StringTok{"fac"}\NormalTok{, }
      \FunctionTok{Fun}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\FunctionTok{If0}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FunctionTok{Mul}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\FunctionTok{App}\NormalTok{(}\StringTok{"fac"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"n"}\NormalTok{,{-}}\DecValTok{1}\NormalTok{))))), }
      \FunctionTok{App}\NormalTok{(}\StringTok{"fac"}\NormalTok{,}\DecValTok{4}\NormalTok{))}

\CommentTok{// With fac = (n =\textgreater{} If (n==0) 1 Else n*fac(n{-}1)): }
\CommentTok{//   fac(4)}
\end{Highlighting}
\end{Shaded}

Um Rekursion in dieser Form erzeugen zu können, brauchen wir ein
Konstrukt, mit dem rekursive Bindungen möglich sind. Dazu führen wir das
(analog zur Scheme-Funktion benannte) \texttt{Letrec}-Konstrukt ein, das
die gleiche Form wie \texttt{With} bzw. \texttt{wth} hat, aber rekursive
Bindings ermöglichen soll. Zudem erweitern wir die Sprache um ein
\texttt{If0}-Konstrukt, um Abbruchbedingungen für rekursive Funktionen
geschickt formulieren zu können:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class} \FunctionTok{If0}\NormalTok{(cond: Exp, tBranch: Exp, eBranch: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Letrec}\NormalTok{(x: String, xDef: Exp, body: Exp) }\KeywordTok{extends}\NormalTok{ Exp}

\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp, env: Env) : Value = e }\KeywordTok{match}\NormalTok{ \{}
  \CommentTok{// ...}
  \KeywordTok{case} \FunctionTok{If0}\NormalTok{(c,t,f) =\textgreater{} }\FunctionTok{eval}\NormalTok{(c,env) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{NumV}\NormalTok{(}\DecValTok{0}\NormalTok{) =\textgreater{} }\FunctionTok{eval}\NormalTok{(t,env)}
    \KeywordTok{case} \FunctionTok{NumV}\NormalTok{(\_) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f,env)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only check if number is zero"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Letrec}\NormalTok{(i,v,b) =\textgreater{} }\CommentTok{// ???}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Es stellt sich aber die Frage, wie wir im \texttt{Letrec}-Fall vorgehen
sollen. Zuerst müssen wir \texttt{xDef} auswerten, handelt es sich dabei
um eine Funktion, so ist das Ergebnis der Auswertung natürlich ein
Closure. Die Umgebung im Closure enthält aber keine Bindung für den
Funktionsnamen, der ja im Rumpf der Funktion auftritt.

Selbst wenn man die Umgebung im Closure um eine Bindung für den
Funktionsnamen erweitert, würde das nur einen rekursiven Aufruf
ermöglichen, dann wäre der Funktionsname im Rumpf bereits wieder nicht
gebunden. Für eine unbegrenzte Rekursionstiefe müsste für die Umgebung
gelten:
\texttt{env\ =\ Map("fac"\ -\textgreater{}\ ClosureV(Fun("n",...),\ env))},
sie müsste sich also zirkulär selbst referenzieren.

Eine Möglichkeit, um zirkuläre Strukturen zu definieren, ist durch
Objektreferenzen (bspw. durch zwei Instanzen, die gegenseitig auf sich
verweisen). Hierzu ist Mutation notwendig, es wird die erste
Objektinstanz mit Null-Pointer erzeugt, dann die zweite Objektinstanz
mit Pointer auf die erste, zuletzt wird der Pointer im ersten Objekt
mutiert und auf das zweite gesetzt.

Wir legen eine entsprechende Datenstruktur in einem Objekt
\texttt{Values} an. Diese besteht aus einem Trait \texttt{ValueHolder},
das durch die Klassen \texttt{Value} und \texttt{ValuePointer}
implementiert wird. Instanzen von \texttt{Value} sind dabei selbst
Werte, Instanzen von \texttt{ValuePointer} verweisen auf
\texttt{Value}-Instanzen. Die \texttt{Value}-Subklassen \texttt{NumV}
und \texttt{ClosureV} kennen wir bereits, der Umgebungstyp \texttt{Env}
ist nun nicht mehr eine Map von \texttt{String} nach \texttt{Value}
sondern von \texttt{String} nach \texttt{ValueHolder}. Damit diese
zirkuläre Definition möglich ist
(\texttt{ValueHolder\ -\textgreater{}\ Value\ -\textgreater{}\ ClosureV\ -\textgreater{}\ Env\ -\textgreater{}\ ValueHolder}),
müssen die Definitionen innerhalb eines Objekts liegen.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{object}\NormalTok{ Values \{}
  \KeywordTok{trait}\NormalTok{ ValueHolder \{}
    \KeywordTok{def}\NormalTok{ value: Value}
\NormalTok{  \}}
  \KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Value }\KeywordTok{extends}\NormalTok{ ValueHolder \{}
    \KeywordTok{def}\NormalTok{ value = }\KeywordTok{this}
\NormalTok{  \}}
  \KeywordTok{case} \KeywordTok{class} \FunctionTok{ValuePointer}\NormalTok{(}\KeywordTok{var}\NormalTok{ v: Value) }\KeywordTok{extends}\NormalTok{ ValueHolder \{}
    \KeywordTok{def}\NormalTok{ value = v}
\NormalTok{  \}}
  \KeywordTok{case} \KeywordTok{class} \FunctionTok{NumV}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ Value}
  \KeywordTok{case} \KeywordTok{class} \FunctionTok{ClosureV}\NormalTok{(f: Fun, env: Env) }\KeywordTok{extends}\NormalTok{ Value}
  \KeywordTok{type}\NormalTok{ Env = Map[String,ValueHolder]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Anschließend importieren wir die Definitionen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import}\NormalTok{ Values.}\FunctionTok{\_}
\end{Highlighting}
\end{Shaded}

Die \texttt{eval}-Funktion ändert sich an folgenden Stellen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp, env: Env) : Value = e }\KeywordTok{match}\NormalTok{ \{}
  \CommentTok{// ...}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} }\FunctionTok{env}\NormalTok{(x).}\FunctionTok{value}
  \CommentTok{// ...}
  \KeywordTok{case} \FunctionTok{Letrec}\NormalTok{(i,v,b) =\textgreater{}}
    \KeywordTok{val}\NormalTok{ vp = }\FunctionTok{ValuePointer}\NormalTok{(}\KeywordTok{null}\NormalTok{)}
    \KeywordTok{val}\NormalTok{ newEnv = env+(i {-}\textgreater{} vp)}
\NormalTok{    vp.}\FunctionTok{v}\NormalTok{ = }\FunctionTok{eval}\NormalTok{(v,newEnv)}
    \FunctionTok{eval}\NormalTok{(b,newEnv)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Im \texttt{Letrec}-Fall definieren wir erst den \texttt{ValuePointer}
\texttt{vp}, den wir mit einem Verweis auf \texttt{null} initialisieren.
Wir erweitern die aktuelle Umgebung mit der Bindung des Identifiers
\texttt{i} auf \texttt{vp}. Dann mutieren wir den \texttt{ValuePointer}
so, dass er das Auswertungsergebnis des zu bindenden Wertes in der neuen
Umgebung referenziert (Kreisschluss!). Nach dieser Mutation ist mit der
neuen Umgebung die Auswertung möglich.

Am Beispiel der \texttt{forever}-Funktion geschieht folgendes:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{eval}\NormalTok{( }\FunctionTok{Letrec}\NormalTok{(}\StringTok{"forever"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\FunctionTok{App}\NormalTok{(}\StringTok{"forever"}\NormalTok{,}\StringTok{"x"}\NormalTok{)), }\FunctionTok{App}\NormalTok{(}\StringTok{"forever"}\NormalTok{,}\DecValTok{42}\NormalTok{)), Map() )}
\CommentTok{// \textasciitilde{}\textasciitilde{}\textgreater{}}
\FunctionTok{eval}\NormalTok{( }\FunctionTok{App}\NormalTok{(}\StringTok{"forever"}\NormalTok{,}\DecValTok{42}\NormalTok{), Map(}\StringTok{"forever"}\NormalTok{ {-}\textgreater{} vp) )}
\CommentTok{// vp.v = ClosureV( Fun("x",App("forever","x")), Map("forever" {-}\textgreater{} vp) )}
\end{Highlighting}
\end{Shaded}

Bei der Auswertung von \texttt{App("forever",42)} wird im
\texttt{Id}-Fall der Identifier \texttt{"forever"} in der Umgebung
nachgeschlagen und auf das \texttt{value}-Feld des Ergebnisses
zugegriffen. Dabei handelt es sich um den oben auskommentierten Closure.
Bei der Auswertung des Funktionsrumpfes wird die Umgebung aus dem
Closure erweitert, in dieser ist \texttt{"forever"} wieder an
\texttt{vp} gebunden. Bei einem rekursiven Aufruf wird also wieder
\texttt{vp.value} ausgelesen, etc.

Damit ist eine unbegrenzte Rekursionstiefe möglich.

\hypertarget{mutation-bcfae}{%
\section{Mutation (BCFAE)}\label{mutation-bcfae}}

Die Sprache FAE (auch inkl. \texttt{Letrec}) ist eine \emph{rein
funktionale} Sprache, also eine Sprache ohne Mutation und Seiteneffekte.
In dieser Art von Sprache lassen sich Programme und deren Auswertung
besonders leicht nachvollziehen und es liegt \emph{Referential
Transparency} vor.

\textbf{Referential Transparency} bedeutet, dass alle Aufrufe einer
Funktion mit dem gleichen Argument überall durch das (identische)
Ergebnis des Aufrufs ersetzt werden können, ohne die Bedeutung des
Programms zu verändern.

Besitzen Funktionen Seiteneffekte (etwa Print-Befehle oder Mutationen),
so ist dies nicht der Fall, denn durch das Ersetzen des Funktionsaufrufs
mit dem Ergebnis gehen jegliche Seiteneffekte verloren.

Eine Form von Mutation ist das Mutieren von Variablen, also das
Überschreiben des Wertes einer Variable:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ x = }\DecValTok{1}
\NormalTok{x = }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

Eine andere Form ist die mutierbarer Datenstrukturen, bspw. Arrays, in
denen einzelne Werte überschrieben werden können. Wir wollen die
einfachste denkbare Form einer solchen mutierbaren Datenstruktur unserer
Sprache hinzufügen, nämlich eine Datenstruktur mit genau einem Wert, die
wir als \emph{Box} bezeichnen.

\hypertarget{box-container}{%
\subsection{Box-Container}\label{box-container}}

Eine Box entspricht einem Array der Länge 1, ist also ein Datencontainer
für genau einen Wert. Um Boxes zu implementieren, führen wir die
folgenden Sprachkonstrukte ein:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class} \FunctionTok{NewBox}\NormalTok{(e: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{SetBox}\NormalTok{(b: Exp, e: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{OpenBox}\NormalTok{(b: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class}\NormalTok{ Seq(e1: Exp, e2: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\end{Highlighting}
\end{Shaded}

Wir müssen Boxen instanziieren, beschreiben und auslesen bzw.
dereferenzieren können, zudem brauchen wir eine Möglichkeit, um zu
Sequenzieren, also zwei Ausdrücke nacheinander auszuwerten (damit ein
Ausdruck neben einer Mutation auch eine Berechnung durchführen kann). Da
der Wert einer Box mutiert werden kann, spielt die
Auswertungsreihenfolge von Unterausdrücken nun eine entscheidende Rolle.

Wir implementieren den \texttt{Box}-Container aus pädagogischen Gründen
nicht durch Mutation in der Meta-Sprache, sondern bleiben weiterhin bei
einem funktionalen Interpreter.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ ex1 = }\FunctionTok{wth}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\FunctionTok{NewBox}\NormalTok{(}\DecValTok{0}\NormalTok{), Seq( }\FunctionTok{SetBox}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\DecValTok{1}\NormalTok{,}\FunctionTok{OpenBox}\NormalTok{(}\StringTok{"b"}\NormalTok{))), }\FunctionTok{OpenBox}\NormalTok{(}\StringTok{"b"}\NormalTok{)))}
\CommentTok{/* Should evaluate to 1.}
\CommentTok{With b = NewBox(0):}
\CommentTok{  SetBox(b \textless{}{-} 1+OpenBox(b));}
\CommentTok{    OpenBox(b)}
\CommentTok{ */}
\end{Highlighting}
\end{Shaded}

Die Implementierung von \texttt{Seq} stellt uns vor eine
Herausforderung, die Reihenfolge der rekursiven \texttt{eval}-Aufrufe in
unserem Interpreter spielt nämlich keine Rolle, da diese
Funktionsaufrufe keine Effekte haben (und auch nicht haben sollen). Wir
müssen also unseren Interpreter abändern, so dass nach der Auswertung
sowohl das Ergebnis, als auch durchgeführte Mutationen zurückgegeben
werden, damit wir beim Auswerten des zweiten Programmabschnitts die
Effekte des ersten Programmabschnitts berücksichtigen können.

Hierzu ist es aber nicht ausreichend, \texttt{(Value,Env)} als
Rückgabetyp zu wählen, wie das folgenden Beispiel zeigt:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ ex2 = }\FunctionTok{wth}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\FunctionTok{NewBox}\NormalTok{(}\DecValTok{1}\NormalTok{), }
            \FunctionTok{wth}\NormalTok{(}\StringTok{"f"}\NormalTok{, }\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\FunctionTok{OpenBox}\NormalTok{(}\StringTok{"a"}\NormalTok{))),}
\NormalTok{              Seq(}\FunctionTok{SetBox}\NormalTok{(}\StringTok{"a"}\NormalTok{,}\DecValTok{2}\NormalTok{), }\FunctionTok{App}\NormalTok{(}\StringTok{"f"}\NormalTok{,}\DecValTok{5}\NormalTok{))))}
\CommentTok{/* Should evaluate to 7.}
\CommentTok{With b = NewBox(1):}
\CommentTok{  With f = (x =\textgreater{} x+OpenBox(b):}
\CommentTok{    SetBox(a, 2);}
\CommentTok{    f(5)}
\CommentTok{ */}
\end{Highlighting}
\end{Shaded}

Bei der Auswertung von \texttt{f} wird die Umgebung aus dem zu
\texttt{f} gehörigen Closure verwendet. In dieser Umgebung steht in der
an \texttt{"a"} gebundenen Box der Wert \texttt{1}, nicht \texttt{2}.
Environments dienen zur Umsetzung von lexikalischem Scoping, sie werden
entsprechend der Programmstruktur rekursiv in Unterausdrücke
weitergereicht. Für Mutation ist aber die Auswertungsreihenfolge und
nicht die syntaktische Struktur des Programms entscheidend, insofern
sind Environments für die Implementation dieses neuen Features
ungeeignet.

Stattdessen benötigen wir eine zweite Datenstruktur, die wir als
zusätzliches Argument bei der Auswertung übergeben und in evtl.
modifizierter Form nach der Auswertungs ausgeben. Die neue Datenstruktur
besitzt einen ganz anderen Datenfluss als die Umgebung, sie wird von
Auswertungsposition zu Auswertungsposition gereicht und nicht wie die
Umgebung im AST immer nur nach unten weitergegeben.

\hypertarget{store-und-adressen}{%
\subsection{Store und Adressen}\label{store-und-adressen}}

Wir verwenden wieder unsere alten Definitionen von \texttt{Value} und
\texttt{Env} und führen die Typen \texttt{Address} und \texttt{Store}
ein. Zusätzlich erweitern wir \texttt{Value} um den Fall
\texttt{AddressV}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Value}
\KeywordTok{type}\NormalTok{ Env = Map[String,Value]}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{NumV}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ Value}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{ClosureV}\NormalTok{(f: Fun, env: Env) }\KeywordTok{extends}\NormalTok{ Value}

\KeywordTok{type}\NormalTok{ Address = Int}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{AddressV}\NormalTok{(a: Address) }\KeywordTok{extends}\NormalTok{ Value}
\KeywordTok{type}\NormalTok{ Store = Map[Address,Value]}
\end{Highlighting}
\end{Shaded}

Adressen sind Integers und dienen als Referenzen (``Pointer'') für
Box-Instanzen. In der \texttt{Store}-Map werden die aktuellen Werte der
Box-Instanzen hinterlegt. Um Identifier an Boxen binden zu können,
müssen wir Boxen als \texttt{Value} repräsentieren können, zu diesem
Zweck dient \texttt{AddressV}.

Um neue Adressen zu erhalten, inkrementieren wir einfach die bisher
höchste Adresse um 1. Um das Entfernen alter Referenzen und die
Limitierungen dieses Adressen-Systems kümmern wir uns zum jetzigen
Zeitpunkt nicht.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ address = }\DecValTok{0}
\KeywordTok{def}\NormalTok{ nextAddress : Address = \{}
\NormalTok{  address += }\DecValTok{1}
\NormalTok{  address}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Hier verwendet unsere Implementation doch Mutation in der Meta-Sprache,
aber nur um diese Hilfsfunktion zu vereinfachen. Alternativ wäre eine
Funktion \texttt{freshAddress} denkbar, die eine neue ungenutzte Adresse
erzeugt (vgl. \texttt{freshName}
\protect\hyperlink{capture-avoiding-substitution}{hier})

\hypertarget{interpreter}{%
\subsection{Interpreter}\label{interpreter}}

Im Interpreter ändert sich in allen Fällen deutlich, die Implementation
wird im Allgemeinen aufwändiger:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp, env: Env, s: Store) : (Value,Store) = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} (}\FunctionTok{NumV}\NormalTok{(n),s)}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} (}\FunctionTok{env}\NormalTok{(x),s)}
  \KeywordTok{case}\NormalTok{ f@}\FunctionTok{Fun}\NormalTok{(\_,\_) =\textgreater{} (}\FunctionTok{ClosureV}\NormalTok{(f,env),s)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{eval}\NormalTok{(l,env,s) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(a),s1) =\textgreater{} }\FunctionTok{eval}\NormalTok{(r,env,s1) }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(b),s2) =\textgreater{} (}\FunctionTok{NumV}\NormalTok{(a+b),s2)}
      \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{    \}}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f,env,s) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{ClosureV}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(p,b),cEnv),s1) =\textgreater{} }\FunctionTok{eval}\NormalTok{(a,env,s1) }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case}\NormalTok{ (v,s2) =\textgreater{} }\FunctionTok{eval}\NormalTok{(b, cEnv+(p {-}\textgreater{} v), s2)}
\NormalTok{    \}}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case}\NormalTok{ Seq(e1,e2) =\textgreater{}}
    \FunctionTok{eval}\NormalTok{(e2,env,}\FunctionTok{eval}\NormalTok{(e1,env,s).}\FunctionTok{\_2}\NormalTok{)}
  \KeywordTok{case} \FunctionTok{NewBox}\NormalTok{(e) =\textgreater{} }\FunctionTok{eval}\NormalTok{(e,env,s) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (v,s1) =\textgreater{}}
      \KeywordTok{val}\NormalTok{ a = nextAddress}
\NormalTok{      (}\FunctionTok{AddressV}\NormalTok{(a), s1+(a {-}\textgreater{} v))}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{SetBox}\NormalTok{(b,e) =\textgreater{} }\FunctionTok{eval}\NormalTok{(b,env,s) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{AddressV}\NormalTok{(a),s1) =\textgreater{} }\FunctionTok{eval}\NormalTok{(e,env,s1) }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case}\NormalTok{ (v,s2) =\textgreater{} (v, s2+(a {-}\textgreater{} v))}
\NormalTok{    \}}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only set boxes"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{OpenBox}\NormalTok{(b) =\textgreater{}  }\FunctionTok{eval}\NormalTok{(b,env,s) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{AddressV}\NormalTok{(a),s1) =\textgreater{} (}\FunctionTok{s1}\NormalTok{(a),s1)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only open boxes"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Der \texttt{Num}-, \texttt{Id}- und \texttt{Fun}-Fall entsprechen der
\protect\hyperlink{umgebungsbasierter-interpreter-a}{umgebungsbasierten
FAE-Implementierung} bis auf den neuen Store, der zusätzlich (mit dem
Ergebnis zusammen in einem Tupel) ausgegeben wird. Im \texttt{Add}- und
\texttt{Mul}-Fall müssen wir aber bereits entscheiden, in welcher
Reihenfolge wir den linken und rechten Unterausdruck auswerten wollen.
Wir werten (wie die meisten Sprachen) erst links und dann rechts aus.

Durch die Auswertung des linken Teilausdrucks (mit aktueller Umgebung
und aktuellem Store) erhalten wir ein Tupel aus \texttt{Value} und
\texttt{Store}, diesen neuen \texttt{Store} verwenden wir dann bei der
Auswertung des rechten Teilausdrucks, so dass potentielle Mutierungen im
linken Teilausdruck bei der Auswertung des rechten Teilausdrucks
berücksichtigt werden. Die Auswertung des rechten Teilausdrucks liefert
wieder einen Wert und einen Store, wir geben die Summe der Zahlen und
den neuesten Store als Ergebnis aus.

Auch im \texttt{App}-Fall müssen wir den Store erst in den linken
Unterausdruck und dann (potentiell modifiziert) in den rechten Ausdruck
reichen, der Store, der bei der Auswertung des Arguments ausgegeben
wird, verwenden wir bei der Auswertung des Funktionsrumpfs.

Im \texttt{Seq}-Fall werten wir zuerst den linken Ausdruck aus und
greifen mit \texttt{.\_2} auf den Store aus dem Ergebnis zu. Diesen
nutzen wir dann bei der Auswertung des rechten Ausdrucks. Das Ergebnis
des linken Teilausdrucks wird also ignoriert, es wird das Ergebnis des
rechten Teilausdrucks ausgegeben.

Um eine neue Box-Instanz zu erzeugen, werten wir zuerst den Ausdruck
aus, der in der Box stehen soll. Wir erhalten einen Wert \texttt{v} und
einen Store \texttt{s1}, erzeugen mit \texttt{nextAddress} eine neue
Adresse und geben ein Tupel aus der neuen Adresse und \texttt{s1},
erweitert um eine Bindung der neuen Adresse an \texttt{v}, aus. Im
\texttt{SetBox}-Fall muss zusätzlich der Ausdruck an der ersten Stelle
ausgewertet werden, um die Adresse der Box-Instanz zu erhalten und den
Store mit dem neuen Wert zu aktualisieren. Im \texttt{OpenBox}-Fall wird
auch erst die Adresse bestimmt, anschließend wird der an die Adresse
gebundene Wert und der aktuelle Store ausgegeben.

Beim Auslesen einer Box-Instanz wird also erst in der Umgebung der
Bezeichner nachgeschlagen, was einen \texttt{AddressV}-Wert liefern
sollte, anschließend wird im Store nachgeschlagen, auf welchen Wert
diese Adresse verweist.

\hypertarget{speichermanagement}{%
\section{Speichermanagement}\label{speichermanagement}}

Die Funktion \texttt{nextAddress}, mit der wir ungenutzte Adressen für
neue Boxen erzeugen, inkrementiert einfach die Variable \texttt{address}
immer weiter. Der Wert von \texttt{address} wird nach der Auswertung
nicht zurückgesetzt. Während der Auswertung wird auch nicht geprüft,
welche Einträge im Store noch benötigt werden und ob Adressen und die an
sie gebundenen Werte entfernt werden können.

Eine Möglichkeit, nicht mehr benötigte Einträge zu entfernen, wäre ein
neues Sprachkonstrukt, etwa \texttt{RemoveBox}. Damit könnte der
Programmierer Box-Instanzen verwerfen, die nicht mehr benötigt werden.
Wird aber ein Identifier an eine Box-Instanz gebunden und diese
Box-Instanz gelöscht, so verweist der Identifier weiterhin auf eine
Adresse, für die es im Store aber keinen Eintrag mehr oder sogar einen
anderen, neuen Eintrag gibt.

Unter anderem durch solche \emph{Dangling Pointers} ist Programmieren
mit manuellem Speichermanagement fehleranfällig, auch wenn dadurch
performantere Programme möglich sind. Aus diesem Grund verwenden viele
Programmiersprachen automatisches Speichermanagement in Form von
\emph{Garbage Collection}.

\hypertarget{garbage-collection}{%
\subsection{Garbage Collection}\label{garbage-collection}}

Garbage Collection beruht auf der Tatsache, dass algorithmisch bestimmt
bzw. approximiert werden kann, welche Speicherinhalte in der weiteren
Auswertung noch benötigt werden.

Ideal wäre ein Garbage-Collection-Algorithmus, der folgendes erfüllt:

\textbf{``Perfekte'' Garbage Collection:} Wenn die Adresse \(a\) im
Store \(s\) in der weiteren Berechnung nicht mehr benötigt wird, so wird
der Eintrag für \(a\) aus \(s\) entfernt.

Die Fragestellung, ob ein Store-Eintrag in der weiteren Berechnung noch
benötigt wird, ist jedoch unentscheidbar, was aus der Unentscheidbarkeit
des Halteproblems und dem Satz von Rice folgt. Wird bspw. eine Funktion
\(f\) aufgerufen und danach auf eine Adresse zugegriffen, so wird die
Adresse nur benötigt, wenn \(f\) terminiert. Für perfekte Garbage
Collection müsste also das Halteproblem entscheidbar sein.

Es kann jedoch die Menge der noch benötigten Adressen approximiert
werden. Approximinieren bedeutet dabei, das es Adressen gibt, für die
keine Entscheidung möglich ist oder die falsch eingeordnet werden.
Garbage Collection wird dabei so gestaltet, dass nur eine Art von Fehler
geschieht, nämlich dass Daten unnötig/fälschlicherweise im Speicher
gehalten werden aber nie fälschlicherweise verworfen werden
(\emph{Soundness}).

\emph{Reachability} von Speichereinträgen hat sich als eine geeignete
Approximation für die Zwecke von Garbage Collection herausgestellt und
wird in vielen Algorithmen benutzt, um nicht mehr benötigte Einträge zu
bestimmen.

\textbf{Erreichbarkeit/Reachability:} Eine Adresse ist
\emph{erreichbar}, wenn sie sich in der aktuellen Umgebung (inkl.
Unterumgebungen in Closures, usw.) befindet, oder wenn es einen Pfad von
Verweisen aus der aktuellen Umgebung zu der Adresse gibt.

Garbage Collection entspricht also dem Erreichbarkeitsproblem in einem
gerichteten Graphen. Voraussetzung ist dabei, dass alle nicht
erreichbaren Adressen im Rest der Berechnung nicht benötigt werden. Das
wäre bspw. nicht der Fall, wenn durch Pointer-Arithmetik auf beliebige
Adressen zugegriffen werden kann.

Da unsere Auswertungsfunktion rekursiv ist, reicht es nicht, nur die
aktuelle Umgebung zu betrachten. Es muss für jede Instanz der
\texttt{eval}-Funktion auf dem Call-Stack die zugehörige Umgebung
berücksichtigt werden, da beim Aufstieg aus den rekursiven Aufrufen
wieder die auf dem Stack abgelegten Umgebungen verwendet werden.

\hypertarget{mark-and-sweep}{%
\subsection{Mark and Sweep}\label{mark-and-sweep}}

Die meisten einfachen Garbage-Collection-Algorithmen auf Basis von
Reachability bestehen aus den zwei Phasen \emph{Mark} und \emph{Sweep}.
Im ersten Schritt werden alle Adressen markiert, die noch benötigt
werden, im zweiten Schritt werden dann alle nicht markierten Adressen
entfernt.

Die folgende Funktion führt Mark-And-Sweep Garbage-Collection in
\protect\hyperlink{mutation-bcfae}{BCFAE} für eine Umgebung \texttt{env}
auf dem Store durch:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{gc}\NormalTok{(env: Env, store: Store) : Store = \{}

  \KeywordTok{def} \FunctionTok{allAddrInVal}\NormalTok{(v: Value) : Set[Address] = v }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{NumV}\NormalTok{(\_) =\textgreater{} Set()}
    \KeywordTok{case} \FunctionTok{ClosureV}\NormalTok{(\_,env) =\textgreater{} }\FunctionTok{allAddrInEnv}\NormalTok{(env)}
    \KeywordTok{case} \FunctionTok{AddressV}\NormalTok{(a) =\textgreater{} Set(a)}
\NormalTok{  \}}

  \KeywordTok{def} \FunctionTok{allAddrInEnv}\NormalTok{(env: Env) : Set[Address] =}
\NormalTok{    env.}\FunctionTok{values}\NormalTok{.}\FunctionTok{map}\NormalTok{\{allAddrInVal\}.}\FunctionTok{fold}\NormalTok{(Set())(\_++\_)}

  \KeywordTok{def} \FunctionTok{mark}\NormalTok{(seed: Set[Address]) : Set[Address] = \{}
    \KeywordTok{val}\NormalTok{ newAddresses = seed.}\FunctionTok{flatMap}\NormalTok{(a =\textgreater{} }\FunctionTok{allAddrInVal}\NormalTok{(}\FunctionTok{store}\NormalTok{(a)))}
    \KeywordTok{if}\NormalTok{ (newAddresses.}\FunctionTok{subsetOf}\NormalTok{(seed)) seed }\KeywordTok{else} \FunctionTok{mark}\NormalTok{(seed++newAddresses)}
\NormalTok{  \}}

  \KeywordTok{val}\NormalTok{ marked = }\FunctionTok{mark}\NormalTok{(}\FunctionTok{allAddrInEnv}\NormalTok{(env)) }\CommentTok{// mark}
  
\NormalTok{  store.}\FunctionTok{filter}\NormalTok{\{ }\KeywordTok{case}\NormalTok{ (a,\_) =\textgreater{} }\FunctionTok{marked}\NormalTok{(a) \} }\CommentTok{// sweep}

\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Die Funktion \texttt{allAddrInEnv} sammelt alle erreichbaren Adressen in
einer Umgebung, indem \texttt{allAddrInVal} auf alle Werte in der
Umgebung aufgerufen wird und die entstehenden Mengen alle vereinigt
werden. Die Funktion \texttt{mark} erhält eine Adressmenge \texttt{seed}
und liefert die Menge aller Adressen, die von den Adressen in
\texttt{seed} aus erreicht werden können. Werden dabei keine neuen
Adressen gefunden, so wird die Menge \texttt{seed} ausgegeben. Ansonsten
wird \texttt{mark} rekursiv aufgerufen, dabei wird die Menge um die neu
gefundenen Adressen erweitert. Sie wird also schrittweise erweitert, bis
keine neuen Adressen mehr gefunden werden. \texttt{gc} bestimmt erst die
Menge der markierten Adressen und filtert dann den Store, so dass
unmarkierte Adressen entfernt werden.

Das folgende Beispiel zeigt die Funktionsweise des Algorithmus,
\texttt{gc} wird mit einer Umgebung aufgerufen, in der auf der rechten
Seite die Adresse \texttt{5} vorkommt. An der Adresse \texttt{5} steht
im Store eine Closure, in dem wiederum die Adresse \texttt{3} auftritt,
an der Adresse \texttt{3} wird auf die Adresse \texttt{1} verwiesen. Die
Adressen \texttt{2} und \texttt{5} sind nicht erreichbar und sind
dementsprechend im Ergebnis-Store nicht mehr vorhanden.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ testEnv = Map(}\StringTok{"a"}\NormalTok{ {-}\textgreater{} }\FunctionTok{AddressV}\NormalTok{(}\DecValTok{5}\NormalTok{))}
\KeywordTok{val}\NormalTok{ testStore = Map(}
  \DecValTok{1}\NormalTok{ {-}\textgreater{} }\FunctionTok{NumV}\NormalTok{(}\DecValTok{0}\NormalTok{),}
  \DecValTok{2}\NormalTok{ {-}\textgreater{} }\FunctionTok{NumV}\NormalTok{(}\DecValTok{0}\NormalTok{),}
  \DecValTok{3}\NormalTok{ {-}\textgreater{} }\FunctionTok{AddressV}\NormalTok{(}\DecValTok{1}\NormalTok{),}
  \DecValTok{4}\NormalTok{ {-}\textgreater{} }\FunctionTok{AddressV}\NormalTok{(}\DecValTok{2}\NormalTok{),}
  \DecValTok{5}\NormalTok{ {-}\textgreater{} }\FunctionTok{ClosureV}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"x"}\NormalTok{), Map(}\StringTok{"y"}\NormalTok{ {-}\textgreater{} }\FunctionTok{AddressV}\NormalTok{(}\DecValTok{3}\NormalTok{))))}
  
\CommentTok{// addresses 2 and 4 cannot be reached, are removed by GC}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{gc}\NormalTok{(testEnv,testStore) ==}
\NormalTok{  Map(}\DecValTok{5}\NormalTok{ {-}\textgreater{} }\FunctionTok{ClosureV}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"x"}\NormalTok{), Map(}\StringTok{"y"}\NormalTok{ {-}\textgreater{} }\FunctionTok{AddressV}\NormalTok{(}\DecValTok{3}\NormalTok{))),}
      \DecValTok{3}\NormalTok{ {-}\textgreater{} }\FunctionTok{AddressV}\NormalTok{(}\DecValTok{1}\NormalTok{), }
      \DecValTok{1}\NormalTok{ {-}\textgreater{} }\FunctionTok{NumV}\NormalTok{(}\DecValTok{0}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\hypertarget{moving-und-non-moving-gc}{%
\subsection{Moving und Non-Moving GC}\label{moving-und-non-moving-gc}}

Durch wiederholtes Anlegen und Entfernen von Speichereinträgen kann es
zu einer starken Fragmentierung des Speichers kommen, die belegten
Speicherzellen sind dann evtl. stark verteilt und der Speicher ist
``lückenhaft'' befüllt.

Diese Fragmentierung erschwert zum einen die Speicherzuweisung, da
größere ``Datenblöcke'' evtl. nicht am Stück gespeichert werden können
und zerlegt werden müssen, zum anderen verschlechtert sich die
Performanz, da die Speichernutzung weniger effizient wird (freier
Speicher ist verteilt und kann dadurch evtl. nicht genutzt werden, es
müssen mehr Adressen im Speicher gehalten werden, zusammengehörige Daten
werden nicht automatisch gemeinsam in den Cache geladen).

Um Fragmentierung zu reduzieren, müssen bei der Garbage Collection
Speichereinträge verschoben (``zusammengerückt'') werden, sodass die
Speicherbelegung möglichst dicht bzw. kompakt bleibt. Hierbei spricht
man von \emph{Moving} Garbage Collection. Dabei werden nicht nur die
Daten verschoben, sondern es müssen auch alle Referenzen mit der neuen
Speicheradresse aktualisiert werden.

Bei \protect\hyperlink{mark-and-sweep}{Mark and Sweep} werden die Daten
nicht verschoben, der Algorithmus ist eine Form von \emph{Non-Moving}
Garbage Collection. Er führt allgemein über die Laufzeit hinweg zu
zunehmender Fragmentierung.

Ein Beispiel für Moving Garbage Collection ist \emph{Semi-Space Garbage
Collection}. Dabei wird der Speicher in zwei Hälften geteilt, wobei
während der Allokation nur eine Hälfte des Speichers verwendet wird. Ist
diese voll, so wird Garbage Collection durchgeführt: Die noch benötigten
Einträge werden markiert, anschließend werden alle markierten Einträge
in die freie Speicherhälfte kopiert, wodurch der Speicher wieder dicht
belegt wird. Zuletzt werden alle Einträge in der vollen Speicherhälfte
gelöscht. Beim nächsten GC-Zyklus wird das Verfahren mit umgekehrten
Rollen wiederholt.

\textbf{Vorteil} ist, dass bei jedem GC-Zyklus der gesamte Speicher
defragmentiert wird, das Problem der steigenden Fragmentierung über Zeit
ist also behoben. \textbf{Nachteile} sind die hinzukommenden
Kopieroperationen und größere Anzahl an Löschoperationen, die
Aktualisierung der Referenzen und die dazu notwendigen Suchoperationen,
sowie die (im Worst Case) Halbierung des verfügbaren Speicherplatzes.

\hypertarget{weitere-begriffe}{%
\subsection{Weitere Begriffe}\label{weitere-begriffe}}

\begin{itemize}
\item
  \textbf{Generational GC:} Es kann empirisch belegt werden, dass in den
  meisten Anwendungen die Objekte, die bei einem GC-Zyklus
  dereferenziert werden können, tendenziell sehr ``jung'' sind, also
  erst vor kurzer Zeit angelegt wurden. Bei Objekten, die sich schon
  sehr lange im Speicher befinden, werden viel wahrscheinlicher noch
  benötigt als Objekte, die erst kürzlich angelegt wurden. ~ Bei
  \emph{Generational Garbage Collection} macht man sich diese Tatsache
  zunutze, indem die Objekte nach ihrem Alter aufgeteilt werden und im
  Speicherbereich für jungen Objekte öfter Garbage Collection
  durchgeführt wird als im Speicherbereich für alte Objekte. Somit kann
  Speicherplatz effizienter freigegeben werden, da gezielt die Objekte
  betrachtet werden, die am ehesten dereferenziert werden können.
\item
  \textbf{``Stop the World''-Phänomen:} Während Garbage Collection
  durchgeführt wird, kann eine Anwendung i.A. nicht weiterlaufen, denn
  der GC-Algorithmus wäre nicht mehr sicher, wenn während der Ausführung
  des GC-Algorithmus weiter Adressen angelegt und Referenzen geändert
  werden. Stattdessen muss der Anwendungsprozess aufgeschoben werden,
  bis der GC-Zyklus vollendet ist. ~ In den meisten Fällen kann dies
  unbemerkt geschehen, aber bei interaktiven Programmen und
  Echtzeit-Anwendungen wird die Garbage Collection und das damit
  verbundene Aussetzen des Programms evtl. durch Ruckeln oder kurzes
  ``Hängen'' bemerkbar. Im besten Fall ist das für einen Nutzer leicht
  störend, im schlimmsten Fall hat die verzögerte Reaktion aber
  weitreichende Folgen, weshalb automatisches Speichermanagement für
  Programme mit extrem hohen Ansprüchen an die Reaktionsfähigkeit und
  Zuverlässigkeit ungeeignet sein kann.
\item
  \textbf{Reference Counting:} Eine andere Form des automatischen
  Speichermanagements, die nicht auf Erreichbarkeit von Objektinstanzen
  beruht, ist \emph{Reference Counting}. Dabei wird zusammen mit jeder
  Objektinstanz ein Feld angelegt, in dem die Anzahl der Referenzen auf
  das Objekt gehalten wird. Ist diese Anzahl 0, so kann das Objekt
  dereferenziert werden. Bei jeder Änderung der Referenzen müssen die
  Felder in den betroffenen Objekten aktualisiert werden. Im Gegensatz
  zu Garbage Collection muss die Anwendung nicht mehr unterbrochen
  werden, Objekte können gelöscht werden, sobald ihr Counter 0 beträgt.
  ~ Gibt es jedoch Referenzzyklen, so werden Objekte, die evtl. nicht
  mehr erreichbar sind, dennoch im Speicher gehalten. Deshalb wird das
  Verfahren typischerweise mit Zyklendetektion kombiniert, damit solche
  Strukturen erkannt und die entsprechenden Objekte dereferenziert
  werden.
\end{itemize}

\hypertarget{interpreter-mit-speichermanagement}{%
\section{Interpreter mit
Speichermanagement}\label{interpreter-mit-speichermanagement}}

Um Garbage Collection in den BCFAE-Interpreter zu integrieren, ergänzen
wir Werte um einen ``Markierungszustand'' und verwenden eine neue
Definition für \texttt{Store}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Value \{}
  \KeywordTok{var}\NormalTok{ marked : Boolean = }\KeywordTok{false}
\NormalTok{\}}

\KeywordTok{trait}\NormalTok{ Store \{}
  \KeywordTok{def} \FunctionTok{malloc}\NormalTok{(stack: List[Env], v: Value) : Int}
  \KeywordTok{def} \FunctionTok{update}\NormalTok{(i: Int, v: Value) : Unit}
  \KeywordTok{def} \FunctionTok{apply}\NormalTok{(i: Int) : Value}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Dabei fügt \texttt{malloc} dem Store einen Wert hinzu (wobei falls
notwendig GC betrieben wird) und liefert die gewählte Adresse zurück,
\texttt{update} mutiert den Wert an der Adresse \texttt{i} im Store und
\texttt{apply} liest den Wert an der Adresse \texttt{i} aus. Wir
verwenden jetzt also auch Mutation in der Meta-Sprache, um den
Interpreter samt Speichermanagement zu implementieren. Der Store wird
also nicht mehr von Funktionsaufruf zu Funktionsaufruf gereicht, sondern
ist eine globale Datenstruktur, auf die von überall zugegriffen werden
kann.

Unser Interpreter ähnelt dadurch wieder stärker dem
\protect\hyperlink{umgebungsbasierter-interpreter-a}{umgebungsbasierten
FAE-Interpreter}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp, stack: List[Env], store: Store) : Value = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(n)}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} stack.}\FunctionTok{head}\NormalTok{(x)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{eval}\NormalTok{(l,stack,store),}\FunctionTok{eval}\NormalTok{(r,stack,store)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(a),}\FunctionTok{NumV}\NormalTok{(b)) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(a+b)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Mul}\NormalTok{(l,r) =\textgreater{} }\CommentTok{// analogous to Add}
  \KeywordTok{case}\NormalTok{ f@}\FunctionTok{Fun}\NormalTok{(\_,\_) =\textgreater{} }\FunctionTok{ClosureV}\NormalTok{(f,stack.}\FunctionTok{head}\NormalTok{)}
  \KeywordTok{case} \FunctionTok{If0}\NormalTok{(c,t,f) =\textgreater{} }\FunctionTok{eval}\NormalTok{(c,stack,store) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{NumV}\NormalTok{(}\DecValTok{0}\NormalTok{) =\textgreater{} }\FunctionTok{eval}\NormalTok{(t,stack,store)}
    \KeywordTok{case} \FunctionTok{NumV}\NormalTok{(\_) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f,stack,store)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only check if number is zero"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f,stack,store) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{ClosureV}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(p,b),cEnv) =\textgreater{}}
      \FunctionTok{eval}\NormalTok{(b, cEnv+(p {-}\textgreater{} }\FunctionTok{eval}\NormalTok{(a,stack,store))::stack, store)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case}\NormalTok{ Seq(e1,e2) =\textgreater{} }\FunctionTok{eval}\NormalTok{(e1,stack,store); }\FunctionTok{eval}\NormalTok{(e2,stack,store)}
  \KeywordTok{case} \FunctionTok{NewBox}\NormalTok{(e: Exp) =\textgreater{}}
    \KeywordTok{val}\NormalTok{ a = store.}\FunctionTok{malloc}\NormalTok{(stack,}\FunctionTok{eval}\NormalTok{(e,stack,store))}
    \FunctionTok{AddressV}\NormalTok{(a)}
  \KeywordTok{case} \FunctionTok{SetBox}\NormalTok{(b: Exp, e: Exp) =\textgreater{} }\FunctionTok{eval}\NormalTok{(b,stack,store) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{AddressV}\NormalTok{(a) =\textgreater{}}
      \KeywordTok{val}\NormalTok{ v = }\FunctionTok{eval}\NormalTok{(e,stack,store)}
\NormalTok{      store.}\FunctionTok{update}\NormalTok{(a,v)}
\NormalTok{      v}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only set boxes"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{OpenBox}\NormalTok{(b: Exp) =\textgreater{} }\FunctionTok{eval}\NormalTok{(b,stack,store) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{AddressV}\NormalTok{(a) =\textgreater{} store.}\FunctionTok{apply}\NormalTok{(a)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only open boxes"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Statt einer Umgebung verwendet der Interpreter nun eine Liste aller im
Call-Stack auftretenden Umgebungen als Parameter. Der Kopf der Liste ist
die aktive Umgebung des aktuellen Funktionsaufrufs, die weiteren
Elemente sind die Umgebungen der ``darüberliegenden'' Aufrufe in der
Rekursionsstruktur, als die auf dem Call-Stack abgelegten Umgebungen. Im
\texttt{App}-Fall wird die Umgebungsliste erweitert, indem vorne an die
Liste eine neue Umgebung angehängt wird, die zusätzlich die Bindung des
Parameters enthält. Im \texttt{Id}-Fall wird der Bezeichner in der
obersten/ersten Umgebung im Stack nachgeschlagen.

Im \texttt{NewBox}-, \texttt{SetBox}- und \texttt{OpenBox}-Fall werden
jeweils die Store-Funktionen \texttt{malloc}, \texttt{update} und
\texttt{apply} benutzt. Es muss der Stack anstelle der Umgebung als
Parameter von \texttt{eval} verwendet werden, damit dieser im
\texttt{NewBox}-Fall an die \texttt{malloc}-Funktion überreicht werden
kann -- für GC und die Suche nach ungenutzten Adressen werden nämlich
alle Umgebungen im Stack benötigt.

\hypertarget{ohne-gc}{%
\subsection{Ohne GC}\label{ohne-gc}}

Eine sehr einfache Implementation der abstrakten \texttt{Store}-Klasse
für Speichermanagement ohne Garbage Collection sieht folgendermaßen aus:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \FunctionTok{StoreNoGC}\NormalTok{(size: Int) }\KeywordTok{extends}\NormalTok{ Store \{}
  \KeywordTok{val}\NormalTok{ memory = }\KeywordTok{new}\NormalTok{ Array[Value](size)}
  \KeywordTok{var}\NormalTok{ nextFreeAddr: Int = }\DecValTok{0}
  \KeywordTok{def} \FunctionTok{malloc}\NormalTok{(stack: List[Env], v: Value) : Int = \{}
    \KeywordTok{val}\NormalTok{ a = nextFreeAddr}
    \KeywordTok{if}\NormalTok{ (a \textgreater{}= size) sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Out of memory!"}\NormalTok{)}
\NormalTok{    nextFreeAddr += }\DecValTok{1}\NormalTok{; }\FunctionTok{update}\NormalTok{(a,v); a}
\NormalTok{  \}}
  \KeywordTok{def} \FunctionTok{update}\NormalTok{(i: Int, v: Value) : Unit = memory.}\FunctionTok{update}\NormalTok{(i,v)}
  \KeywordTok{def} \FunctionTok{apply}\NormalTok{(i: Int) : Value = }\FunctionTok{memory}\NormalTok{(i)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Der Store ist hierbei durch ein Array implementiert, um eine freie
Adresse zu finden wird die mutierbare Variable \texttt{nextFreeAddr}
verwendet und nach jeder neuen Zuweisung inkrementiert. Die Größe
\texttt{size} wird bei der Instanziierung gewählt und legt fest, wie
groß das Array ist, also wie viele Adressen es gibt. Sind alle Indices
des Array belegt worden, so ist der Speicher voll und es wird eine
Fehlermeldung ausgegeben. Es wird keinerlei Garbage Collection
betrieben, um Ressourcen freizugeben.

Die \texttt{eval}-Aufrufe im folgenden Programm verursachen also eine
Fehlermeldung, wenn bei der Evaluation von \texttt{ex1} mindestens eine
Box angelegt wird:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ store = }\KeywordTok{new} \FunctionTok{StoreNoGC}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\KeywordTok{val}\NormalTok{ stack = List[Env]()}
\FunctionTok{eval}\NormalTok{(ex1,stack,store); }\FunctionTok{eval}\NormalTok{(ex1,stack,store); }\FunctionTok{eval}\NormalTok{(ex1,stack,store)}
\end{Highlighting}
\end{Shaded}

Auch ein Testprogramm, in dem mehr als zwei Boxen instanziiert werden,
würde einen Fehler liefern.

\hypertarget{mit-gc}{%
\subsection{Mit GC}\label{mit-gc}}

Wir implementieren nun die abstrakte \texttt{Store}-Klasse mit ``Mark \&
Sweep''-Garbage-Collection. Der Store wird dabei wieder mit einer Größe
\texttt{size} instanziiert, die die Anzahl der Adressen bestimmt. Wir
ergänzen eine Variable \texttt{free}, in der die Anzahl ungenutzter
Adressen gehalten wird. Gibt es bei der Speicherallokation keine freien
Adressen mehr, so wird Garbage Collection betrieben. Ist auch danach
keine Adresse frei, so wird eine Fehlermeldung ausgegeben. Der
verwendete ``Mark \& Sweep''-Algorithmus ähnelt dem im
\protect\hyperlink{mark-and-sweep}{vorherigen Kapitel} aufgeführten
stark:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \FunctionTok{MarkAndSweepStore}\NormalTok{(size: Int) }\KeywordTok{extends}\NormalTok{ Store \{}
  \KeywordTok{val}\NormalTok{ memory = }\KeywordTok{new}\NormalTok{ Array[Value](size)}
  \KeywordTok{var}\NormalTok{ free : Int = size}
  \KeywordTok{var}\NormalTok{ nextFreeAddr : Int = }\DecValTok{0}
  \KeywordTok{def} \FunctionTok{malloc}\NormalTok{(stack: List[Env], v: Value) : Int = \{}
    \KeywordTok{if}\NormalTok{ (free \textless{}= }\DecValTok{0}\NormalTok{) }\FunctionTok{gc}\NormalTok{(stack)}
    \KeywordTok{if}\NormalTok{ (free \textless{}= }\DecValTok{0}\NormalTok{) sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Out of memory!"}\NormalTok{)}
    \KeywordTok{while}\NormalTok{ (}\FunctionTok{memory}\NormalTok{(nextFreeAddr) != }\KeywordTok{null}\NormalTok{) \{}
\NormalTok{      nextFreeAddr += }\DecValTok{1}
      \KeywordTok{if}\NormalTok{ (nextFreeAddr == size) nextFreeAddr = }\DecValTok{0}
\NormalTok{    \}}
    \FunctionTok{update}\NormalTok{(nextFreeAddr,v); free {-}= }\DecValTok{1}\NormalTok{; nextFreeAddr}
\NormalTok{  \}}
  \KeywordTok{def} \FunctionTok{update}\NormalTok{(i: Int, v: Value) : Unit = \{ }\FunctionTok{memory}\NormalTok{(i) = v \}}
  \KeywordTok{def} \FunctionTok{apply}\NormalTok{(i: Int) : Value = }\FunctionTok{memory}\NormalTok{(i)}

  \CommentTok{// Mark \& Sweep GC:}
  \KeywordTok{def} \FunctionTok{allAddrInVal}\NormalTok{(v: Value) : Set[Int] = v }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{NumV}\NormalTok{(\_) =\textgreater{} Set()}
    \KeywordTok{case} \FunctionTok{AddressV}\NormalTok{(a) =\textgreater{} Set(a)}
    \KeywordTok{case} \FunctionTok{ClosureV}\NormalTok{(\_,env) =\textgreater{} }\FunctionTok{allAddrInEnv}\NormalTok{(env)}
\NormalTok{  \}}
  \KeywordTok{def} \FunctionTok{allAddrInEnv}\NormalTok{(env: Env) : Set[Int] = \{}
\NormalTok{    env.}\FunctionTok{values}\NormalTok{.}\FunctionTok{map}\NormalTok{(allAddrInVal).}\FunctionTok{fold}\NormalTok{(Set())(\_++\_)}
\NormalTok{  \}}
  \KeywordTok{def} \FunctionTok{mark}\NormalTok{(seed: Set[Int]) : Unit = \{}
\NormalTok{    seed.}\FunctionTok{foreach}\NormalTok{(}\FunctionTok{memory}\NormalTok{(\_).}\FunctionTok{marked}\NormalTok{ = }\KeywordTok{true}\NormalTok{)}
    \KeywordTok{val}\NormalTok{ newAddresses = }
\NormalTok{      seed.}\FunctionTok{flatMap}\NormalTok{(a =\textgreater{} }\FunctionTok{allAddrInVal}\NormalTok{(}\FunctionTok{memory}\NormalTok{(a))).}\FunctionTok{filter}\NormalTok{(!}\FunctionTok{memory}\NormalTok{(\_).}\FunctionTok{marked}\NormalTok{)}
    \KeywordTok{if}\NormalTok{ (newAddresses.}\FunctionTok{nonEmpty}\NormalTok{) \{}
      \FunctionTok{mark}\NormalTok{(newAddresses)}
\NormalTok{    \}}
\NormalTok{  \}}
  \KeywordTok{def} \FunctionTok{sweep}\NormalTok{() : Unit = \{}
\NormalTok{    memory.}\FunctionTok{indices}\NormalTok{.}\FunctionTok{foreach}\NormalTok{(}
\NormalTok{      i =\textgreater{} }\KeywordTok{if}\NormalTok{ (}\FunctionTok{memory}\NormalTok{(i) == }\KeywordTok{null}\NormalTok{) \{\}}
      \KeywordTok{else} \KeywordTok{if}\NormalTok{ (}\FunctionTok{memory}\NormalTok{(i).}\FunctionTok{marked}\NormalTok{) }\FunctionTok{memory}\NormalTok{(i).}\FunctionTok{marked}\NormalTok{ = }\KeywordTok{false}
      \KeywordTok{else}\NormalTok{ \{ }\FunctionTok{memory}\NormalTok{(i) = }\KeywordTok{null}\NormalTok{; free += }\DecValTok{1}\NormalTok{ \}}
\NormalTok{    )}
\NormalTok{  \}}
  \KeywordTok{def} \FunctionTok{gc}\NormalTok{(stack: List[Env]) : Unit = \{}
    \FunctionTok{mark}\NormalTok{(stack.}\FunctionTok{map}\NormalTok{(allAddrInEnv).}\FunctionTok{fold}\NormalTok{(Set())(\_++\_))}
    \FunctionTok{sweep}\NormalTok{()}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Gibt es bei der Allokation noch (oder nach der Garbage Collection) freie
Adressen, so wird das Array linear durchsucht, bis ein leeres Feld
gefunden wird. Hier wird dann der Wert eingetragen, \texttt{free} wird
dekrementiert und die Adresse wird ausgegeben.

Die Markierung der noch erreichbaren Adressen ist nicht mehr durch eine
Menge repräsentiert, sondern durch das Feld \texttt{marked} in jedem
\texttt{Value}. Die \texttt{sweep}-Funktion ersetzt nicht markierte
Werte im Store durch \texttt{null} (wobei \texttt{free} inkrementiert
wird) und setzt die Markierung aller Werte auf \texttt{false} zurück.

\hypertarget{meta--und-syntaktische-interpretation}{%
\section{Meta- und syntaktische
Interpretation}\label{meta--und-syntaktische-interpretation}}

Jede Sprachsemantik einer Programmiersprache lässt sich in einer
Meta-Sprache auf verschiedene Arten implementieren, dabei ist die
Unterscheidung zwischen \emph{Metainterpretation} und
\emph{syntaktischer Interpretation} von besonderer Wichtigkeit.

\emph{Metainterpretation} bezeichnet die Implementierung eines
Sprachfeatures durch das entsprechende Feature in der Hostsprache,
\emph{syntaktische Interpretation} hingegen die Implementierung eines
Features durch Reduktion auf primitivere Sprachkonstrukte der
Hostsprache. Metainterpretation ist (falls überhaupt möglich) leichter
zu implementieren, erlaubt aber keine Anpassung eines Sprachkonstrukts
gegenüber der Implementation in der Hostsprache. Syntaktische
Interpretation erlaubt eine andere, selbst festgelegte Implementation
und die Kontrolle darüber, wobei aber ein umfangreiches Verständnis des
Sprachkonstrukts notwendig ist, um dieses mit einfacheren Mitteln selbst
zu implementieren.

In unserer Sprache \protect\hyperlink{higher-order-funktionen-fae}{FAE}
ist bspw. Addition durch Metainterpretation implementiert, wir verwenden
im Interpreter die Additionsfunktion von Scala und delegieren damit
dieses Feature einfach an die Hostsprache. Dementsprechend besitzt
Addition in unserer Sprache die gleichen Einschränkungen und
Eigenschaften wie Addition in der Scala. Auch die maximale Tiefe
rekursiver Programme oder das Speichermanagement wird nicht durch unsere
Implementierung festgelegt, sondern durch Scala, da wir Rekursion in
Scala für unseren Interpreter nutzen und implizit das Speichermanagement
von Scala übernehmen.

Andere Sprachfeatures werden hingegen nicht durch das entsprechende
Feature in der Hostsprache umgesetzt, z.B. Identifier (inkl. Scoping)
oder Closures. Hier liegt syntaktische Interpretation vor. Beim
Entwerfen des Interpreters muss man sich also bewusst sein, welche
Verhaltensweisen und Einschränkungen mit den Features der Hostsprache
einhergehen und entscheiden, welche Features man selbst implementieren
und welche man ``weiterreichen'' (d.h. an die Hostsprache delegieren)
möchte.

Wir könnten in \protect\hyperlink{higher-order-funktionen-fae}{FAE} aber
auch mehr Metainterpretation verwenden, indem wir etwa die Funktionen
durch Funktionen der Metasprache umsetzen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{trait}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Num}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Id}\NormalTok{(x: String) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Add}\NormalTok{(lhs: Exp, rhs: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Fun}\NormalTok{(f: Exp =\textgreater{} Exp) }\KeywordTok{extends}\NormalTok{ Exp }
\KeywordTok{case} \KeywordTok{class} \FunctionTok{App}\NormalTok{(fun: Exp, arg: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\end{Highlighting}
\end{Shaded}

Eine solche Repräsentation von Funktionen der Objektsprache durch
Funktionen der Metasprache nennt man \emph{Higher-Order Abstract Syntax
(HOAS)}.

Der Interpreter wird nun extrem einfach, aber die Kontrolle über das
Verhalten von Identifiern und Bindungen (also bspw. Scoping) geht
verloren.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp) : Exp = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Unbound identifier: "}\NormalTok{+x)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{eval}\NormalTok{(l),}\FunctionTok{eval}\NormalTok{(r)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{Num}\NormalTok{(a),}\FunctionTok{Num}\NormalTok{(b)) =\textgreater{} }\FunctionTok{Num}\NormalTok{(a+b)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} f }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(f) =\textgreater{} }\FunctionTok{eval}\NormalTok{(}\FunctionTok{f}\NormalTok{(}\FunctionTok{eval}\NormalTok{(a)))}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case}\NormalTok{ \_ =\textgreater{} e}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Es ist auch möglich, Closures durch Metainterpretation umzusetzen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Value}
\KeywordTok{type}\NormalTok{ Env = Map[String, Value]}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{NumV}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ Value}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{FunV}\NormalTok{(f: Value =\textgreater{} Value) }\KeywordTok{extends}\NormalTok{ Value}

\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp) : Env =\textgreater{} Value = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n: Int) =\textgreater{} (env) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(n)}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} env =\textgreater{} }\FunctionTok{env}\NormalTok{(x)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} \{ (env) =\textgreater{}}
\NormalTok{    (}\FunctionTok{eval}\NormalTok{(l)(env),  }\FunctionTok{eval}\NormalTok{(r)(env)) }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(v1),}\FunctionTok{NumV}\NormalTok{(v2)) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(v1+v2)}
      \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(param,body) =\textgreater{} (env) =\textgreater{} }\FunctionTok{FunV}\NormalTok{( (v) =\textgreater{} }\FunctionTok{eval}\NormalTok{(body)(env + (param {-}\textgreater{} v)))}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} (env) =\textgreater{} (}\FunctionTok{eval}\NormalTok{(f)(env), }\FunctionTok{eval}\NormalTok{(a)(env)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{FunV}\NormalTok{(g),arg) =\textgreater{} }\FunctionTok{g}\NormalTok{(arg)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Anstelle von Closures bestehend aus einer Funktion und der zugehörigen
Umgebung liefert die Auswertung von Funktionen eine
\texttt{FunV}-Instanz mit einer Scala-Funktion, die die Auswertung des
Rumpfes mit der korrekten Umgebung (vom Zeitpunkt, zu dem der
\texttt{Fun}-Ausdruck ausgewertet wird, entsprechend der
Closure-Umgebung) durchführt. Die Closures der Objektsprache sind also
durch die Closures der Metasprache implementiert.

Durch das zusätzliche Auslagern des Umgebungsparameters aus
\texttt{eval} durch Currying ist dieser Interpreter kompositional, d.h.
alle rekursiven Aufrufe von \texttt{eval} sind auf Unterausdrücken des
aktuellen Ausdrucks. Dadurch lässt sich Programmäquivalenz in der
Objektsprache leicht durch Äquivalenz in der Metasprache beweisen.
Außerdem lässt sich der Interpreter auch im
\protect\hyperlink{abstraktion-durch-visitor}{Visitor-Stil}
implementieren.

Es könnten auch mehr Sprachkonstrukte von FAE durch syntaktische
Interpretation umgesetzt werden, bspw. könnte man Zahlen als Sequenz von
Ziffern anstelle von Scala-\texttt{Int}s repräsentieren. Wir werden noch
Implementation kennenlernen, die nicht mehr von Scalas
Speichermanagement und Higher-Order-Funktionen abhängen.

\hypertarget{objekt-algebren}{%
\section{Objekt-Algebren}}

\emph{Objekt-Algebren} (\emph{Object Algebras}) sind eine Abstraktion,
die eng mit
\href{https://en.wikipedia.org/wiki/Algebraic_data_type}{algebraischen
Datentypen} und
\protect\hyperlink{church-kodierungen}{Church-Kodierungen} verwandt ist.
Zudem haben sie einige Gemeinsamkeiten mit dem
\protect\hyperlink{abstraktion-durch-visitor}{Visitor Pattern}.

Sie sind ein mächtiger und teilweise auch effizienter Mechanismus zur
Modularisierung von Programmen und ein sehr junges Forschungsgebiet, zu
dem es erst seit etwa 2012 Veröffentlichungen gibt.

\hypertarget{binuxe4rbuxe4ume-im-objekt-algebra-stil}{%
\subsection{Binärbäume im
Objekt-Algebra-Stil}\label{binuxe4rbuxe4ume-im-objekt-algebra-stil}}

Betrachten wir zuerst eine Implementation von Binärbäumen im
Visitor-Stil (völlig analog zum
\protect\hyperlink{abstraktion-durch-visitor}{Interpreter im
Visitor-Stil} --
\href{https://github.com/DavidLaewen/programmiersprachen1/blob/main/additional-material/FunctionalVisitorObjectalgebra.scala}{hier}
ein Vergleich des funktionalen Pattern-Matching-, Visitor und
Objekt-Algebra-Stils):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ BTree}
\KeywordTok{case} \KeywordTok{class}\NormalTok{ Node(l: BTree, r: BTree) }\KeywordTok{extends}\NormalTok{ BTree}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Leaf}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ BTree}

\KeywordTok{case} \KeywordTok{class}\NormalTok{ Visitor[T](node: (T,T) =\textgreater{} T, leaf: Int =\textgreater{} T)}

\KeywordTok{def}\NormalTok{ foldExp[T](v: Visitor[T], b: BTree) : T = b }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case}\NormalTok{ Node(l,r) =\textgreater{} v.}\FunctionTok{node}\NormalTok{(}\FunctionTok{foldExp}\NormalTok{(v,l), }\FunctionTok{foldExp}\NormalTok{(v,r))}
  \KeywordTok{case} \FunctionTok{Leaf}\NormalTok{(n)   =\textgreater{} v.}\FunctionTok{leaf}\NormalTok{(n)}
\NormalTok{\}}

\KeywordTok{val}\NormalTok{ sumVisitor = }\KeywordTok{new}\NormalTok{ Visitor[Int]((l,r) =\textgreater{} l+r, n =\textgreater{} n)}

\FunctionTok{assert}\NormalTok{(}\FunctionTok{foldExp}\NormalTok{(sumVisitor, Node(}\FunctionTok{Leaf}\NormalTok{(}\DecValTok{1}\NormalTok{),}\FunctionTok{Leaf}\NormalTok{(}\DecValTok{2}\NormalTok{))) == }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Im Objekt-Algebra-Stil wird der Datentyp nicht durch eine abstrakte
Klasse mit verschiedenen \emph{Cases}, sondern durch die Funktionen der
Faltungsoperation definiert, die Daten werden also durch ihre eigene
Faltung repräsentiert:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ BTreeInt[T] \{}
  \KeywordTok{def} \FunctionTok{node}\NormalTok{(l: T, r: T) : T}
  \KeywordTok{def} \FunctionTok{leaf}\NormalTok{(n: Int) : T}
\NormalTok{\}}

\KeywordTok{def}\NormalTok{ ex1[T](semantics: BTreeInt[T]) : T = \{}
  \KeywordTok{import}\NormalTok{ semantics.}\FunctionTok{\_}
  \FunctionTok{node}\NormalTok{(}\FunctionTok{leaf}\NormalTok{(}\DecValTok{1}\NormalTok{),}\FunctionTok{leaf}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\NormalTok{\}}

\KeywordTok{object}\NormalTok{ TreeSum }\KeywordTok{extends}\NormalTok{ BTreeInt[Int] \{}
  \KeywordTok{def} \FunctionTok{node}\NormalTok{(l: Int, r: Int) = l+r}
  \KeywordTok{def} \FunctionTok{leaf}\NormalTok{(n: Int) = n}
\NormalTok{\}}

\FunctionTok{assert}\NormalTok{(}\FunctionTok{ex1}\NormalTok{(TreeSum) == }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Dadurch muss zur Durchführung einer Faltung nur eine Instanz von
\texttt{BTreeInt} (hier etwa \texttt{TreeSum}) an einen Wert des
Datentyps (hier etwa \texttt{ex1}) überreicht werden, in der die
Faltungsoperation für beide Fälle konkret definiert sind.

\textbf{Eigenschaften des Objekt-Algebra-Stils:} - Jeder Konstruktor des
Datentyps (hier \texttt{Node} und \texttt{Leaf}) wird zu einer Funktion
in der abstrakten ``Signaturklasse'' mit Typparameter \texttt{T} (hier
\texttt{BTreeInt{[}T{]}}), wobei rekursive Vorkommen des Datentyps durch
\texttt{T} ersetzt werden.

\begin{itemize}
\item
  Konkrete Werte des Datentyps sind als Funktionen mit Typparameter
  \texttt{T} definiert, deren Eingabe eine Instanz der Signaturklasse
  und deren Ausgabe vom Typ \texttt{T} ist.
\item
  Konkrete Faltungen werden zu Instanziierungen der Signaturklasse (hier
  \texttt{TreeSum}), in der die Faltungsfunktionen für die verschiedenen
  Fälle definiert werden.
\end{itemize}

Die Argumente der Faltungsfunktion werden also in einem \texttt{Trait}
zusammengefasst und können als Objekt überreicht werden. Dadurch lässt
sich der Datentyp durch Vererbung erweitern (etwa um Blätter, die
Strings enthalten):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ BTreeMixed[T] }\KeywordTok{extends}\NormalTok{ BTreeInt[T] \{}
  \KeywordTok{def} \FunctionTok{leaf}\NormalTok{(s: String) : T}
\NormalTok{\}}

\KeywordTok{def}\NormalTok{ ex2[T](semantics: BTreeMixed[T]) : T = \{}
  \KeywordTok{import}\NormalTok{ semantics.}\FunctionTok{\_}
  \FunctionTok{node}\NormalTok{(}\FunctionTok{leaf}\NormalTok{(}\DecValTok{1}\NormalTok{),}\FunctionTok{node}\NormalTok{(}\StringTok{"a"}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{peano-zahlen-im-objekt-algebra-stil}{%
\subsection{Peano-Zahlen im
Objekt-Algebra-Stil}\label{peano-zahlen-im-objekt-algebra-stil}}

Wir können die Church-Kodierungen für Zahlen folgendermaßen in Scala
nachbilden, wobei Zahlen Instanzen von \texttt{Num} sind und
(entsprechend der Church-Kodierung) aus ihrer eigenen Faltungsfunktion
bestehen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ Num \{}
  \KeywordTok{def}\NormalTok{ fold[T](s: T =\textgreater{} T, z: T) : T}
\NormalTok{\}}

\KeywordTok{case} \KeywordTok{object}\NormalTok{ Zero }\KeywordTok{extends}\NormalTok{ Num \{}
  \KeywordTok{def}\NormalTok{ fold[T](s: T =\textgreater{} T, z: T) : T = z}
\NormalTok{\}}

\KeywordTok{case} \KeywordTok{object}\NormalTok{ One }\KeywordTok{extends}\NormalTok{ Num \{}
  \KeywordTok{def}\NormalTok{ fold[T](s: T =\textgreater{} T, z: T) : T = }\FunctionTok{s}\NormalTok{(z)}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{succ}\NormalTok{(n: Num) : Num = \{}
  \KeywordTok{new}\NormalTok{ Num \{}
    \KeywordTok{def}\NormalTok{ fold[T](s: T =\textgreater{} T, z: T) : T = }\FunctionTok{s}\NormalTok{(n.}\FunctionTok{fold}\NormalTok{(s,z))}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Bei der Implementierung im Objekt-Algebra-Stil werden die Funktionen der
Faltung (also Parameter von \texttt{fold}) wieder zu einem Objekt
zusammengefasst:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ NumSig[T] \{}
  \KeywordTok{def} \FunctionTok{s}\NormalTok{(p: T) : T}
  \KeywordTok{def}\NormalTok{ z: T}
\NormalTok{\}}

\KeywordTok{trait}\NormalTok{ Num \{ }\KeywordTok{def}\NormalTok{ apply[T](x: NumSig[T]) : T \}}
\end{Highlighting}
\end{Shaded}

Eine Objekt-Algebra ist eine Klasse, die ein generisches \emph{Abstract
Factory Interface} implementiert, das im wissenschaftlichen Gebiet der
\emph{universellen Algebra} als \emph{algebraische Signatur} bezeichnet
wird. Die obige Implementation im Objekt-Algebra-Stil ist eine
\emph{algebraische Struktur} mit den Operationen \texttt{s} und
\texttt{z}. Der Typ der Operationen (hier \texttt{NumSig}) wird als
\emph{Signatur} oder \emph{Funktor} bezeichnet, bei \texttt{Num} handelt
es sich um eine \emph{(Funktor-)Algebra}.

Eine \textbf{algebraische Struktur} besteht gewöhnlich aus einer
nichtleeren Menge (\emph{Grundmenge} oder \emph{Trägermenge}) und einer
Familie von \emph{inneren Verknüpfungen} (\emph{Grundoperationen}) auf
der Menge. Ein Beispiel für eine einfache algebraische Struktur ist etwa
das \emph{Monoid}.

Ein \textbf{Monoid} ist eine algebraische Struktur bestehend aus einer
Menge \(M\), einer Abbildung \(\odot: M \times M \to M\) und einem
neutralen Element \(e \in M\), so dass \(\forall a \in M\) gilt:
\(e \odot a = a \odot e = a\). Außerdem gilt
\(\forall a,b,c \in M: (a \odot b) \odot c = a \odot (b \odot c)\)
(\emph{Assoziativität}).

Wir implementieren Zahlen und Addition im Objekt-Algebra-Stil
folgendermaßen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ zero: Num = }\KeywordTok{new}\NormalTok{ Num \{ }\KeywordTok{def}\NormalTok{ apply[T](x: NumSig[T]): T = x.}\FunctionTok{z}\NormalTok{ \}}
\KeywordTok{val}\NormalTok{ one: Num = }\KeywordTok{new}\NormalTok{ Num \{ }\KeywordTok{def}\NormalTok{ apply[T](x: NumSig[T]): T = x.}\FunctionTok{s}\NormalTok{(x.}\FunctionTok{z}\NormalTok{) \}}
\KeywordTok{val}\NormalTok{ two: Num = }\KeywordTok{new}\NormalTok{ Num \{ }\KeywordTok{def}\NormalTok{ apply[T](x: NumSig[T]) : T = x.}\FunctionTok{s}\NormalTok{(one.}\FunctionTok{apply}\NormalTok{(x))\}}

\KeywordTok{def} \FunctionTok{plus}\NormalTok{(a: Num, b: Num) : Num = }\KeywordTok{new}\NormalTok{ Num \{}
  \KeywordTok{def}\NormalTok{ apply[T](x: NumSig[T]) : T = a.}\FunctionTok{apply}\NormalTok{(}\KeywordTok{new}\NormalTok{ NumSig[T] \{}
    \KeywordTok{def} \FunctionTok{s}\NormalTok{(p: T): T = x.}\FunctionTok{s}\NormalTok{(p)}
    \KeywordTok{def}\NormalTok{ z: T = b.}\FunctionTok{apply}\NormalTok{(x)}
\NormalTok{  \})}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Dieser Stil ermöglicht verschiedene konkrete Implementierungen des
Interfaces, bei denen die Argumente für die Faltung übergeben werden,
die die \texttt{Num}-Objekte in der \texttt{apply}-Funktion noch
erwarten.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{object}\NormalTok{ NumAlg }\KeywordTok{extends}\NormalTok{ NumSig[Int] \{}
  \KeywordTok{def} \FunctionTok{s}\NormalTok{(x: Int) : Int = x+}\DecValTok{1}
  \KeywordTok{def}\NormalTok{ z = }\DecValTok{0}
\NormalTok{\}}

\FunctionTok{assert}\NormalTok{(}\FunctionTok{two}\NormalTok{(NumAlg) == }\DecValTok{2}\NormalTok{)}
\FunctionTok{assert}\NormalTok{(}\FunctionTok{plus}\NormalTok{(one,two)(NumAlg) == }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Wir können bspw. das Objekt \texttt{NumAlg} überreichen, um die
Church-kodierten Zahlen in Scala-Integer umzuwandeln. Dabei wird
implizit \texttt{apply} mit der übergebenen
\texttt{NumSig}-Instanziierung aufgerufen.

In diesem Fall bietet der Objekt-Algebra-Stil keine speziellen Vorteile,
anders ist es aber bei unserem Interpreter.

\hypertarget{interpreter-im-objekt-algebra-stil}{%
\subsection{Interpreter im
Objekt-Algebra-Stil}\label{interpreter-im-objekt-algebra-stil}}

Der Objekt-Algebra-Stil erzwingt Kompositionalität, deshalb wählen wir
zur Umwandlung unsere kompositionale Implementation von FAE, in der
Closures durch Metainterpretation umgesetzt sind.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ Exp[T] \{}
  \KeywordTok{implicit} \KeywordTok{def} \FunctionTok{num}\NormalTok{(n: Int) : T}
  \KeywordTok{implicit} \KeywordTok{def} \FunctionTok{id}\NormalTok{(name: String) : T}
  \KeywordTok{def} \FunctionTok{add}\NormalTok{(l: T, r: T) : T}
  \KeywordTok{def} \FunctionTok{fun}\NormalTok{(param: String, body: T) : T}
  \KeywordTok{def} \FunctionTok{app}\NormalTok{(fun: T, arg: T) : T}
  \KeywordTok{def} \FunctionTok{wth}\NormalTok{(x: String, xDef: T, body: T) : T = }\FunctionTok{app}\NormalTok{(}\FunctionTok{fun}\NormalTok{(x,body),xDef)}
\NormalTok{\}}

\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Value}
\KeywordTok{type}\NormalTok{ Env = Map[String,Value]}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{ClosureV}\NormalTok{(f: Value =\textgreater{} Value) }\KeywordTok{extends}\NormalTok{ Value}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{NumV}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ Value}

\KeywordTok{trait}\NormalTok{ eval }\KeywordTok{extends}\NormalTok{ Exp[Env =\textgreater{} Value] \{}
  \KeywordTok{def} \FunctionTok{id}\NormalTok{(x: String) : Env =\textgreater{} Value = env =\textgreater{} }\FunctionTok{env}\NormalTok{(x)}
  \KeywordTok{def} \FunctionTok{fun}\NormalTok{(p: String, b: Env =\textgreater{} Value) : Env =\textgreater{} Value =}
\NormalTok{    env =\textgreater{} }\FunctionTok{ClosureV}\NormalTok{(v =\textgreater{} }\FunctionTok{b}\NormalTok{(env+(p {-}\textgreater{} v)))}
  \KeywordTok{def} \FunctionTok{app}\NormalTok{(fun: Env =\textgreater{} Value, arg: Env =\textgreater{} Value) : Env =\textgreater{} Value =}
\NormalTok{    env =\textgreater{} }\FunctionTok{fun}\NormalTok{(env) }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case} \FunctionTok{ClosureV}\NormalTok{(f) =\textgreater{} }\FunctionTok{f}\NormalTok{(}\FunctionTok{arg}\NormalTok{(env))}
      \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{    \}}
  \KeywordTok{def} \FunctionTok{num}\NormalTok{(n: Int) : Env =\textgreater{} Value = \_ =\textgreater{} }\FunctionTok{NumV}\NormalTok{(n)}
  \KeywordTok{def} \FunctionTok{add}\NormalTok{(l: Env =\textgreater{} Value, r: Env =\textgreater{} Value) : Env =\textgreater{} Value =}
\NormalTok{    env =\textgreater{} (}\FunctionTok{l}\NormalTok{(env),}\FunctionTok{r}\NormalTok{(env)) }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(a),}\FunctionTok{NumV}\NormalTok{(b)) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(a+b)}
      \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{\}}

\KeywordTok{object}\NormalTok{ eval }\KeywordTok{extends}\NormalTok{ eval}

\KeywordTok{def}\NormalTok{ test[T](semantics: Exp[T]) = \{}
  \KeywordTok{import}\NormalTok{ semantics.}\FunctionTok{\_}
  \FunctionTok{app}\NormalTok{(}\FunctionTok{app}\NormalTok{(}\FunctionTok{fun}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\FunctionTok{fun}\NormalTok{(}\StringTok{"y"}\NormalTok{,}\FunctionTok{add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"y"}\NormalTok{))),}\DecValTok{5}\NormalTok{),}\DecValTok{3}\NormalTok{)}
\NormalTok{\}}

\FunctionTok{assert}\NormalTok{(}\FunctionTok{test}\NormalTok{(eval)(Map()) == }\FunctionTok{NumV}\NormalTok{(}\DecValTok{8}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Dieser Stil erlaubt vollständige Modularität, so dass Sprachkonstrukte
nach Bedarf hinzugefügt werden können. Wir können die Sprache etwa
folgendermaßen um Multiplikation erweitern:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ ExpWithMul[T] }\KeywordTok{extends}\NormalTok{ Exp[T] \{}
  \KeywordTok{def} \FunctionTok{mul}\NormalTok{(l: T, r: T) : T}
\NormalTok{\}}

\KeywordTok{object}\NormalTok{ evalWithMul }\KeywordTok{extends}\NormalTok{ eval }\KeywordTok{with}\NormalTok{ ExpWithMul[Env =\textgreater{} Value] \{}
  \KeywordTok{def} \FunctionTok{mul}\NormalTok{(l: Env =\textgreater{} Value, r: Env =\textgreater{} Value) : Env =\textgreater{} Value =}
\NormalTok{    env =\textgreater{} (}\FunctionTok{l}\NormalTok{(env),}\FunctionTok{r}\NormalTok{(env)) }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(a),}\FunctionTok{NumV}\NormalTok{(b)) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(a*b)}
      \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only multiply numbers"}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{\}}
\KeywordTok{def}\NormalTok{ test2[T](semantics: ExpWithMul[T]) = \{}
  \KeywordTok{import}\NormalTok{ semantics.}\FunctionTok{\_}
  \FunctionTok{app}\NormalTok{(}\FunctionTok{app}\NormalTok{(}\FunctionTok{fun}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\FunctionTok{fun}\NormalTok{(}\StringTok{"y"}\NormalTok{,}\FunctionTok{mul}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\StringTok{"y"}\NormalTok{))),}\DecValTok{5}\NormalTok{),}\DecValTok{3}\NormalTok{)}
\NormalTok{\}}

\FunctionTok{assert}\NormalTok{(}\FunctionTok{test2}\NormalTok{(evalWithMul)(Map()) == }\FunctionTok{NumV}\NormalTok{(}\DecValTok{15}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{expression-problem}{%
\subsection{Expression Problem}\label{expression-problem}}

Bei unserem Interpreter gibt es zwei Arten von Erweiterung: Zum einen
gibt es die Erweiterung um zusätzliche Funktionen neben \texttt{eval}
(bspw. \texttt{print} oder \texttt{countNodes}), zum anderen gibt es die
Erweiterung um zusätzliche Sprachkonstrukte. - Unsere bisherige
(funktionale) Implementation mit Pattern Matching erlaubt die modulare
Erweiterung um neue Funktionen -- es können neben \texttt{eval} weitere
strukturell rekursive Funktionen angelegt werden, die auf Expressions
operieren. Die Erweiterung um neue Sprachkonstrukte ist aber nicht
modular möglich, denn die Funktionen können nach ihrer Definition nicht
mehr um zusätzliche Fälle erweitert werden.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{trait}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Num}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Add}\NormalTok{(l: Exp, r: Exp) }\KeywordTok{extends}\NormalTok{ Exp}

\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp) : Int = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} n}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{eval}\NormalTok{(l) + }\FunctionTok{eval}\NormalTok{(r)}
\NormalTok{\}}

\CommentTok{// ...}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Bei einer objektorientierten Implementierung können Funktionen nicht
  nachträglich hinzugefügt werden, da diese in jedem Konstruktor
  definiert werden müssen. Modulare Ergänzung neuer Sprachkonstrukte ist
  hingegen gut möglich, die abstrakte Oberklasse kann nachträglich
  erweitert werden.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Exp \{}
  \KeywordTok{def} \FunctionTok{eval}\NormalTok{() : Int}
\NormalTok{\}}

\KeywordTok{case} \KeywordTok{class} \FunctionTok{Num}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ Exp \{}
  \KeywordTok{def} \FunctionTok{eval}\NormalTok{() = n}
\NormalTok{\}}

\KeywordTok{case} \KeywordTok{class} \FunctionTok{Add}\NormalTok{(l: Exp, r: Exp) }\KeywordTok{extends}\NormalTok{ Exp \{}
  \KeywordTok{def} \FunctionTok{eval}\NormalTok{() = l.}\FunctionTok{eval}\NormalTok{ + r.}\FunctionTok{eval}
\NormalTok{\}}

\CommentTok{// ...}
\end{Highlighting}
\end{Shaded}

Der große Vorteil des Objekt-Algebra-Stils ist die modulare
Erweiterbarkeit in beiden Dimensionen. Es können sowohl neue
Sprachkonstrukte modular ergänzt, als auch neue Funktionen neben
\texttt{eval} hinzugefügt werden. Es handelt sich dabei um eine Lösung
für das sogenannte \emph{Expression Problem}.

Das \textbf{Expression Problem} beschreibt die Suche nach einer
Datenabstraktion, bei der sowohl neue Datenvarianten (Cases), als auch
neue Funktionen, die auf dem Datentyp operieren, ergänzt werden können,
ohne dass bisheriger Code modifiziert werden muss und wobei
Typsicherheit gewährt bleibt
(\href{https://en.wikipedia.org/wiki/Expression_problem}{Wikipedia-Artikel}).

Bei einem funktionalen Ansatz ist typischerweise die Erweiterung mit
Operationen gut unterstützt, bei einem objektorientierten Ansatz
hingegen die Erweiterung mit neuen Datenvarianten.

\hypertarget{webprogrammierung-mit-continuations}{%
\section{Webprogrammierung mit
Continuations}\label{webprogrammierung-mit-continuations}}

Angenommen, man will eine interaktive Webanwendung über mehrere
Webseiten hinweg programmieren, so wird man vor eine Herausforderung
gestellt: Das Webprotokoll HTTP ist zustandslos, d.h. ein Programm im
Web terminiert nach jeder Anfrage. Anfragen sind unabhängig voneinander
und es ist kein Zugriff auf vorherige Anfragen und dabei übermittelte
Daten möglich. Betrachten wir etwa die interaktive Funktion
\texttt{progSimple} im folgenden Code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import}\NormalTok{ scala.}\FunctionTok{io}\NormalTok{.}\FunctionTok{StdIn}\NormalTok{.}\FunctionTok{readLine}

\KeywordTok{def} \FunctionTok{inputNumber}\NormalTok{(prompt: String) : Int = \{}
  \FunctionTok{println}\NormalTok{(prompt)}
\NormalTok{  Integer.}\FunctionTok{parseInt}\NormalTok{(}\FunctionTok{readLine}\NormalTok{())}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{progSimple}\NormalTok{() : Unit = \{}
  \FunctionTok{println}\NormalTok{(}\FunctionTok{inputNumber}\NormalTok{(}\StringTok{"First number:"}\NormalTok{) + }\FunctionTok{inputNumber}\NormalTok{(}\StringTok{"Second number:"}\NormalTok{))}
\NormalTok{\} }
\end{Highlighting}
\end{Shaded}

Hier finden nacheinander zwei Eingaben durch den Nutzer statt, wobei das
Ergebnis aus beiden Werten berechnet wird. Würde man diese Funktion im
Web umsetzen wollen, so dass der Nutzer auf zwei verschiedenen Seiten
die Werte eingibt und absendet und auf einer dritten Seite das Ergebnis
angezeigt bekommt, dann wäre aufgrund der Zustandslosigkeit von HTTP ein
spezieller Programmierstil notwendig.

Der Ablauf zerfällt dabei in die folgenden Teilprogramme: -
\textbf{Teilprogramm \(a\)} zeigt das Formular für die erste Zahl an. -
\textbf{Teilprogramm \(b\)} konsumiert die Zahl aus dem ersten Formular
und generiert das Formular für die zweite Zahl. - \textbf{Teilprogramm
\(c\)} konsumiert die Daten aus dem zweiten Formular, berechnet die
Ausgabe und erzeugt die Seite mit dem Ergebnis.

Nun stellt sich die Frage, wie im zustandslosen Protokoll das
Teilprogramm \(c\) auf die in \(a\) eingegebenen Daten zugreifen kann.
Hierzu muss der eingegebene Wert über \(b\) weitergereicht werden, etwa
als verstecktes Formularfeld in HTML oder als Parameter in der URL.

Wir können die Zustandslosigkeit mit dem Rückgabetyp \texttt{Nothing}
modellieren, dabei brechen wir alle Funktionen mit einem Fehler ab, so
dass sie nicht zurückkehren.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{webDisplay}\NormalTok{(s: String) : Nothing = \{}
  \FunctionTok{println}\NormalTok{(s)}
\NormalTok{  sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Program terminated"}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{webRead}\NormalTok{(prompt: String, continue: String) : Nothing = \{}
  \FunctionTok{println}\NormalTok{(prompt)}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Send input to "}\NormalTok{+continue)}
\NormalTok{  sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Program terminated"}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{def}\NormalTok{ progA = }\FunctionTok{webRead}\NormalTok{(}\StringTok{"First number:"}\NormalTok{, }\StringTok{"progB"}\NormalTok{)}
\KeywordTok{def} \FunctionTok{progB}\NormalTok{(n: Int) = }\FunctionTok{webRead}\NormalTok{(}\StringTok{"First number was "}\NormalTok{+n+}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Second number:"}\NormalTok{, }\StringTok{"progC"}\NormalTok{)}
\KeywordTok{def} \FunctionTok{progC}\NormalTok{(n1: Int, n2: Int) = }\FunctionTok{webDisplay}\NormalTok{(}\StringTok{"Sum of "}\NormalTok{+n1+}\StringTok{" and "}\NormalTok{+n2+}\StringTok{" is "}\NormalTok{+(n1+n2))}
\end{Highlighting}
\end{Shaded}

Hier wird die Weitergabe der Daten von einem Teilprogramm zum nächsten
nur durch die Ausgaben und Eingaben in der Konsole (also händisch durch
den Nutzer) modelliert, d.h. es wird bspw. erst \texttt{progA} mit
\texttt{2} aufgerufen, dann \texttt{progB} mit \texttt{3} und zuletzt
\texttt{progC} mit \texttt{2} und \texttt{3}. Dadurch ist der Nutzen der
durchgeführten Programmtransformation noch nicht sonderlich klar
erkennbar.

\hypertarget{implementierung-mit-continuations}{%
\subsection{Implementierung mit
Continuations}\label{implementierung-mit-continuations}}

Es können aber auch die jeweils noch notwendigen Schritte als
\emph{Continuation} repräsentiert werden, im Fall von \texttt{progA}
muss etwa noch die zweite Zahl eingelesen werden, dann müssen beide
Zahlen addiert und das Ergebnis ausgegeben werden. In der ursprünglichen
Variante des Programms

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{progSimple}\NormalTok{() : Unit = \{}
  \FunctionTok{println}\NormalTok{(}\FunctionTok{inputNumber}\NormalTok{(}\StringTok{"First number:"}\NormalTok{) + }\FunctionTok{inputNumber}\NormalTok{(}\StringTok{"Second number:"}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

entspricht das der folgenden anonymen Funktion:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ cont1 = (n: Int) =\textgreater{} }\FunctionTok{println}\NormalTok{(n + }\FunctionTok{inputNumber}\NormalTok{(}\StringTok{"Second number:"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Die Continuation zum Zeitpunkt der zweiten Eingabe entspricht dem
folgenden Wert:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ cont2 = (m: Int) =\textgreater{} }\FunctionTok{println}\NormalTok{(n + m)}
\end{Highlighting}
\end{Shaded}

Durch das Ablegen dieser Continuations in einer Map und der Ausgabe des
zugehörigen Schlüssels können wir \texttt{webRead} umgestalten und es
dem Nutzer ermöglichen, die Auswertung ab dem letzten Zwischenstand
fortzusetzen.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ continuations = }\KeywordTok{new}\NormalTok{ mutable.}\FunctionTok{HashMap}\NormalTok{[String, Int=\textgreater{}Nothing]}
\KeywordTok{var}\NormalTok{ nextIndex : Int = }\DecValTok{0}
\KeywordTok{def}\NormalTok{ getNextId : String = \{}
\NormalTok{  nextIndex += }\DecValTok{1}
  \StringTok{"c"}\NormalTok{+nextIndex}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{webRead\_k}\NormalTok{(prompt: String, k: Int =\textgreater{} Nothing) : Nothing = \{}
  \KeywordTok{val}\NormalTok{ id = getNextId}
\NormalTok{  continuations += (id {-}\textgreater{} k)}
  \FunctionTok{println}\NormalTok{(prompt)}
  \FunctionTok{println}\NormalTok{(}\StringTok{"To continue, invoke continuation "}\NormalTok{+id)}
\NormalTok{  sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Program terminated"}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{continue}\NormalTok{(kId: String, input: Int): Nothing = }\FunctionTok{continuations}\NormalTok{(kId)(input)}

\KeywordTok{def}\NormalTok{ webProg =}
  \FunctionTok{webRead\_k}\NormalTok{(}\StringTok{"First number:"}\NormalTok{, (n: Int) =\textgreater{}}
    \FunctionTok{webRead\_k}\NormalTok{(}\StringTok{"Second number:"}\NormalTok{, (m: Int) =\textgreater{}}
      \FunctionTok{webDisplay}\NormalTok{(}\StringTok{"Sum of "}\NormalTok{+n+}\StringTok{" and "}\NormalTok{+m+}\StringTok{" is "}\NormalTok{+(n+m))))}
\end{Highlighting}
\end{Shaded}

Nun kann zuerst \texttt{webProg} aufgerufen werden, es wird die ID für
die nächste Continuation ausgegeben. Mit dieser ID und der ersten Zahl
kann dann \texttt{continue} aufgerufen werden, die dabei ausgegebene ID
kann dann \texttt{continue} mit der zweiten Zahl übergeben werden,
woraufhin das Ergebnis angezeigt wird. Die Bezeichner \texttt{n} und
\texttt{m} sind zum Zeitpunkt, zu dem \texttt{webDisplay} aufgerufen
wird, durch Scalas interne Closures gebunden und können korrekt
aufgelöst werden.

In Bezug auf Webprogrammierung entsprechen die Continuations
Zwischenzuständen der Auswertung, die serverseitig hinterlegt werden.
Dabei erhält der Client (im Hintergrund) einen Bezeichner, um diesen
Zustand mit der nächsten Eingabe aufzurufen. Somit könnte auch beim
Klonen des Tabs oder bei Verwendung des ``Zurück''-Buttons das Programm
in allen Instanzen korrekt fortgesetzt werden. Das steht im Kontrast zu
einer Implementierung mit einer \emph{Session}, wobei der Client (und
nicht der Zustand) anhand einer übermittelten Session-ID erkannt wird.
In diesem Fall könnte es bei mehreren Instanzen zu fehlerhaften
Ergebnissen kommen, da alle Instanzen über eine Session-ID laufen und
damit nicht unabhängig sind.

Diese Eigenschaft ist auch bei unserer Implementierung erkennbar, es
kann eine ausgegebene ID mehrfach aufgerufen werden, wobei die
Auswertung jeweils dann mit der nächsten ID korrekt fortgesetzt werden
kann und das korrekte Ergebnis liefert.

Eine Continuation kann als Repräsentation des Call-Stacks in einer
Funktion aufgefasst werden.

\hypertarget{rekursion-im-web-stil}{%
\subsection{Rekursion im Web-Stil}\label{rekursion-im-web-stil}}

Betrachten wir nun den allgemeineren Fall der n-fachen Addition: Im
folgenden Programm wird eine Liste von Gegenständen rekursiv
durchlaufen, wobei der Nutzer für jeden Gegenstand aufgefordert wird,
einen Preis einzugeben. Nachdem alle Listenelemente abgearbeitet wurden,
wird die Summe der Zahlen ausgegeben.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{inputNumber}\NormalTok{(prompt: String) : Int = \{}
  \FunctionTok{println}\NormalTok{(prompt)}
\NormalTok{  Integer.}\FunctionTok{parseInt}\NormalTok{(}\FunctionTok{readLine}\NormalTok{())}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{addAllCosts}\NormalTok{(il: List[String]): Int = il }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case}\NormalTok{ List() =\textgreater{} }\DecValTok{0}
  \KeywordTok{case}\NormalTok{ first :: rest =\textgreater{} }\FunctionTok{inputNumber}\NormalTok{(}\StringTok{"Cost of "}\NormalTok{+first+}\StringTok{":"}\NormalTok{) + }\FunctionTok{addAllCosts}\NormalTok{(rest)}
\NormalTok{\}}

\KeywordTok{val}\NormalTok{ testList = List(}\StringTok{"Banana"}\NormalTok{, }\StringTok{"Apple"}\NormalTok{, }\StringTok{"Orange"}\NormalTok{)}
\KeywordTok{def} \FunctionTok{test}\NormalTok{() : Unit = }\FunctionTok{println}\NormalTok{(}\StringTok{"Total cost: "}\NormalTok{ + }\FunctionTok{addAllCosts}\NormalTok{(testList))}
\end{Highlighting}
\end{Shaded}

Dieses Programm besitzt nach der ``Web-Stil''-Transformation die Form:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{addAllCosts\_k}\NormalTok{(il: List[String], k: Int =\textgreater{} Nothing) : Nothing = il }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case}\NormalTok{ List() =\textgreater{} }\FunctionTok{k}\NormalTok{(}\DecValTok{0}\NormalTok{)}
  \KeywordTok{case}\NormalTok{ first :: rest =\textgreater{}}
    \FunctionTok{webRead\_k}\NormalTok{(}\StringTok{"Cost of "}\NormalTok{+first+}\StringTok{":"}\NormalTok{,}
\NormalTok{      (n: Int) =\textgreater{} }\FunctionTok{addAllCosts\_k}\NormalTok{(rest, (m: Int) =\textgreater{} }\FunctionTok{k}\NormalTok{(m+n)))}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{testWeb}\NormalTok{() : Unit = }\FunctionTok{addAllCosts\_k}\NormalTok{(testList, m =\textgreater{} }\FunctionTok{webDisplay}\NormalTok{(}\StringTok{"Total cost: "}\NormalTok{+m))}
\end{Highlighting}
\end{Shaded}

Die Funktion \texttt{addAllCosts\_k} wird aufgerufen mit der Liste von
Gegenständen und der Contination
\texttt{m\ =\textgreater{}\ webDisplay("Total\ cost:\ "+m)}. Im Fall der
leeren Liste wird die Continuation \texttt{k} auf \texttt{0} aufgerufen,
es würde also \texttt{Total\ cost:\ 0} angezeigt werden. Ist die Liste
nicht leer, so wird durch \texttt{webRead\_k} der Nutzer dazu
aufgefordert, den Preis des ersten Gegenstandes einzugegeben. Dabei wird
die Continuation
\texttt{n\ =\textgreater{}\ addAllCosts\_k(rest,\ m\ =\textgreater{}\ k(m+n))}
übergeben, diese Continuation wird also vom Nutzer/Client als nächstes
mit dem entsprechenden Preis aufgerufen. Dabei wird die Continuation
\texttt{m\ =\textgreater{}\ k(m+n)} an \texttt{addAllCosts\_k}
zurückgereicht, d.h. die Nutzereingabe \texttt{n} wird jeweils den
Kosten hinzugefügt.

Die Funktion \texttt{addAllCosts} lässt sich geschickt mit \texttt{map}
umformulieren:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{addAllCostsMap}\NormalTok{(items: List[String]) : Int = \{}
\NormalTok{  items.}\FunctionTok{map}\NormalTok{((s: String) =\textgreater{} }\FunctionTok{inputNumber}\NormalTok{(}\StringTok{"Cost of "}\NormalTok{ + s + }\StringTok{":"}\NormalTok{)).}\FunctionTok{sum}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Würden wir auf dieser Implementation die Web-Transformation anwenden
wollen, so müssten wir auch \texttt{map} transformieren. Die
Web-Transformation ist nämlich ``allumfassend'' und betrifft alle
Funktionen, die in einem Programm auftreten (bis auf primitive
Operationen). Es benötigen alle Funktionen einen Continuation-Parameter,
damit sie auch innerhalb anderer Programme im Web-Stil eingesetzt werden
können. Wir müssen in diesem Fall also \texttt{map} im Web-Stil
verfassen. Oben ist die ``normale'' Implementation von \texttt{map},
unten die Web-transformierte Variante:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ map[X,Y](l: List[X], f: X =\textgreater{} Y) : List[Y] = c }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case}\NormalTok{ List() =\textgreater{} List()}
  \KeywordTok{case}\NormalTok{ x::xs =\textgreater{} }\FunctionTok{f}\NormalTok{(x)::}\FunctionTok{map}\NormalTok{(xs,f)}
\NormalTok{\}}

\KeywordTok{def}\NormalTok{ map\_k[X,Y](l: List[X],}
\NormalTok{               f: X, (Y =\textgreater{} Nothing) =\textgreater{} Nothing,}
\NormalTok{               k: List[Y] =\textgreater{} Nothing) : Nothing = l }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case}\NormalTok{ List() =\textgreater{} }\FunctionTok{k}\NormalTok{(List())}
  \KeywordTok{case}\NormalTok{ x::xs =\textgreater{} }\FunctionTok{f}\NormalTok{(x, y =\textgreater{} }\FunctionTok{map\_k}\NormalTok{(xs, f, (ys: List[Y]) =\textgreater{} }\FunctionTok{k}\NormalTok{(y::ys)))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Bei der Transformation wird überall der Rückgabetyp mit \texttt{Nothing}
ersetzt, die ursprünglichen Rückgabewerte werden stattdessen an die
Continuation gereicht. So wird \texttt{f} nun durch ein neues Argument
mit dem Typ \texttt{Y\ =\textgreater{}\ Nothing} ergänzt, der Typ der
Eingabe entspricht dem ursprünglichen Rückgabetyp. Die
\texttt{map}-Funktion selbst wird durch ein neues Argument mit dem Typ
\texttt{List{[}T{]}\ =\textgreater{}\ Nothing} ergänzt, auch hier
entspricht der Typ der Eingabe dem ursprünglichen Rückgabetyp.

Die Auswertungsreihenfolge ist entscheidend für die Web-Transformation,
die implizite Auswertungsreihenfolge des Ausgangsprogramms (etwa bei
geschachtelten Ausdrücken) muss explizit ausformuliert werden, das
Programm wird \emph{sequentalisiert}.

Außerdem ist die Transformation global, es müssen alle verwendeten
Funktionen (auch aus Bibliotheken etc.) transformiert werden.

Aufgrund des Aspekts der Sequentialisierung ist die Transformation mit
Continuations auch für das Programmieren von Compilern relevant. Man
spricht bei diesem ``Web-Stil'' auch von \emph{Continuation Passing
Style} (\emph{CPS}).

\hypertarget{continuation-passing-style}{%
\section{Continuation Passing Style}\label{continuation-passing-style}}

Programme in CPS haben die folgenden Eigenschaften: - Alle Zwischenwerte
besitzen einen Namen. - Die Auswertungsschritte werden sequentialisiert
(und die Auswertungsreihenfolge ist somit explizit). - Alle Ausdrücke
erhalten einen Continuation-Parameter und liefern keinen Rückgabewert
(Rückgabetyp \texttt{Nothing}), sondern rufen den Continuation-Parameter
auf ihrem Ergebnis auf. - Alle Funktionsaufrufe sind \emph{Tail Calls}
(da Funktionen nicht zurückkehren).

Man spricht von einem \textbf{Tail Call}, wenn bei einem rekursiven
Aufruf im Rumpf einer Funktion keine weitere Berechnung nach der
Rückkehr des Aufrufs stattfindet. Der Aufruf \texttt{f(n+1)} in
\texttt{def\ f(n:\ Int):\ Int\ =\ f(n+1)} ist ein Tail Call, in
\texttt{def\ f(n:\ Int):\ Int\ =\ f(n+1)*2} jedoch nicht.

Liegt nach der CPS-Transformation eine ``triviale'' Continuation (d.h.
\texttt{k} bleibt unverändert) bei einem rekursiven Aufruf vor, so lag
ursprünglich ein Tail Call vor. Das wird bspw. an der folgenden Funktion
deutlich:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{sumAcc}\NormalTok{(n: Int, acc: Int) : Int = l }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \DecValTok{0}\NormalTok{ =\textgreater{} acc}
  \KeywordTok{case}\NormalTok{ n =\textgreater{} }\FunctionTok{sumAcc}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{, n+acc)}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{sumAcc\_k}\NormalTok{(n: Int, acc: Int, k: Int =\textgreater{} Nothing) : Nothing = l }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \DecValTok{0}\NormalTok{ =\textgreater{} }\FunctionTok{k}\NormalTok{(acc)}
  \KeywordTok{case}\NormalTok{ n =\textgreater{} }\FunctionTok{sumAcc\_k}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{, n+acc, k)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Die Funktion berechnet die Summe aller Zahlen von 1 bis \texttt{n},
verwendet aber im Gegensatz zu einer herkömmlichen Lösung
(\texttt{case\ n\ =\textgreater{}\ n+sum(n-1)}, siehe \texttt{sum} im
Beispiel weiter unten) einen zusätzlichen Parameter, in dem die aktuelle
Zwischensumme gehalten wird. Dadurch liegt im rekursiven Fall ein Tail
Call vor und in der CPS-transformierten Variante wird \texttt{k}
unverändert weitergereicht, was bei der herkömmlichen Lösung nicht der
Fall wäre.

Bei Rekursion mit Tail Call (\emph{Endrekursion}) muss der Kontext des
rekursiven Aufrufs nicht auf dem Call Stack gespeichert werden, in Scala
wird deshalb einfache Endrekursion erkannt und entsprechend optimiert.
In Java werden auch endrekursive Aufrufe auf dem Stack hinterlegt,
wodurch rekursive Berechnungen immer einen größeren Speicherverbrauch
haben als iterative. In Racket findet bei Endrekursion nie eine
``Kontextanhäufung'' auf dem Call-Stack statt.

Bei der CPS-Transformation von Funktionen und Werten sind die folgenden
Schritte notwendig: 1. Ersetzen aller Rückgabetypen durch
\texttt{Nothing}, wobei auch der Typ bei Konstanten \texttt{c:\ T} durch
\texttt{T\ =\textgreater{}\ Nothing} ersetzt wird

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Ergänzen eines Parameters \texttt{k} mit Typ
  \texttt{R\ =\textgreater{}\ Nothing}, wobei \texttt{R} der
  ursprüngliche Rückgabetyp ist (Konstanten der Form \texttt{c:\ T}
  werden also in Funktionen der Form
  \texttt{c\_k(k:\ T\ =\textgreater{}\ Nothing):\ Nothing} umgewandelt)
\item
  Weitergabe des Ergebnisses an \texttt{k}, bei Konstante
  \texttt{val\ c:\ T\ =\ x} etwa
  \texttt{def\ c\_k(k:\ T\ =\textgreater{}\ Nothing):\ Nothing\ =\ k(x)}
\item
  Sequentialisierung durch Weiterreichen der Zwischenergebnisse, aus
  \texttt{f(f(42))} wird bspw.
  \texttt{k\ =\textgreater{}\ f\_k(42,\ fRes\ =\textgreater{}\ f\_k(fRes,k))}
  oder aus \texttt{f(1)\ +\ g(2)} wird
  \texttt{k\ =\textgreater{}\ f\_k(1,\ fRes\ =\textgreater{}\ g\_k(2,\ gRes\ =\textgreater{}\ k(fRes+gRes)))}
\end{enumerate}

Weitere Beispiele der CPS-Transformation:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// constant value}
\KeywordTok{val}\NormalTok{ x: Int = }\DecValTok{42}
\KeywordTok{def} \FunctionTok{x\_k}\NormalTok{(k: Int =\textgreater{} Nothing) : Nothing = }\FunctionTok{k}\NormalTok{(}\DecValTok{42}\NormalTok{)}

\CommentTok{// recursion with "context"}
\KeywordTok{def} \FunctionTok{sum}\NormalTok{(n: Int) : Int = n }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \DecValTok{0}\NormalTok{ =\textgreater{} }\DecValTok{0}
  \KeywordTok{case}\NormalTok{ n =\textgreater{} n + }\FunctionTok{sum}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{def} \FunctionTok{sum\_k}\NormalTok{(n: Int, k: Int =\textgreater{} Nothing) : Nothing = n }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \DecValTok{0}\NormalTok{ =\textgreater{} }\FunctionTok{k}\NormalTok{(}\DecValTok{0}\NormalTok{) }\CommentTok{// k called with result}
  \KeywordTok{case}\NormalTok{ n =\textgreater{} }\FunctionTok{sum\_k}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{, m =\textgreater{} }\FunctionTok{k}\NormalTok{(n+m)) }\CommentTok{// non{-}trivial continuation}
\NormalTok{\}}

\CommentTok{// two{-}way tail call recursion}
\KeywordTok{def} \FunctionTok{even}\NormalTok{(n: Int) : Boolean = n }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \DecValTok{0}\NormalTok{ =\textgreater{} }\KeywordTok{true}
  \KeywordTok{case}\NormalTok{ n =\textgreater{} }\FunctionTok{odd}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{def} \FunctionTok{odd}\NormalTok{(n: Int) : Boolean = n }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \DecValTok{0}\NormalTok{ =\textgreater{} }\KeywordTok{false}
  \KeywordTok{case}\NormalTok{ n =\textgreater{} }\FunctionTok{even}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{even\_k}\NormalTok{(n: Int, k: Boolean =\textgreater{} Nothing) : Nothing = n }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \DecValTok{0}\NormalTok{ =\textgreater{} }\FunctionTok{k}\NormalTok{(}\KeywordTok{true}\NormalTok{)}
  \KeywordTok{case}\NormalTok{ n =\textgreater{} }\FunctionTok{odd\_k}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{,k) }\CommentTok{// trivial continuation}
\NormalTok{\}}
\KeywordTok{def} \FunctionTok{odd\_k}\NormalTok{(n: Int, k: Boolean =\textgreater{} Nothing) : Nothing = n }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \DecValTok{0}\NormalTok{ =\textgreater{} }\FunctionTok{k}\NormalTok{(}\KeywordTok{false}\NormalTok{)}
  \KeywordTok{case}\NormalTok{ n =\textgreater{} }\FunctionTok{even\_k}\NormalTok{(n}\DecValTok{{-}1}\NormalTok{,k) }\CommentTok{// trivial continuation}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{automatische-cps-transformation}{%
\section{Automatische
CPS-Transformation}\label{automatische-cps-transformation}}

Nun wollen wir die CPS-Transformation von Ausdrücken in FAE
automatisieren. Die Transformationsregeln können folgendermaßen
formalisiert werden:

\begin{itemize}
\item
  \textbf{Konstanten:} Aus \texttt{c} wird
  \texttt{k\ =\textgreater{}\ k(c)}
\item
  \textbf{Funktionsdefinitionen:} Aus \texttt{x\ =\textgreater{}\ y}
  wird
  \texttt{k\ =\textgreater{}\ k(\ (x,\ dynK)\ =\textgreater{}\ dynK(y)\ )}
\item
  \textbf{Funktionsapplikationen:} Aus \texttt{f(x)} mit
  \texttt{f:\ X\ =\textgreater{}\ Y} wird
  \texttt{(k:\ Y\ =\textgreater{}\ ...)\ =\textgreater{}\ f\_k(x,\ y\ =\textgreater{}\ k(y))}
\end{itemize}

Im Fall von Funktionsdefinition müssen zwei Continuations beachtet
werden: Die Continuation vom Zeitpunkt der Definition (\texttt{k}) sowie
die \emph{dynamische Continuation} (\texttt{dynK}), die bei der
Funktionsapplikation überreicht wird.

Wir definieren einen zweiten Typ neben \texttt{Exp} um
CPS-transformierte Ausdrücke zu repräsentieren, da sich zum einen die
Syntax mancher Sprachkonstrukte durch die Transformation ändert (es
kommt der zusätzliche Continuation-Parameter hinzu) und zum anderen um
die Eigenschaften von CPS-transformierten Programmen explizit zu
formulieren (und sicherzustellen).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ CPSExp}
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ CPSVal }\KeywordTok{extends}\NormalTok{ CPSExp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{CPSNum}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ CPSVal}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{CPSFun}\NormalTok{(x: String, k: String, body: CPSExp) }\KeywordTok{extends}\NormalTok{ CPSVal}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{CPSCont}\NormalTok{(v: String, body: CPSExp) }\KeywordTok{extends}\NormalTok{ CPSVal}

\KeywordTok{case} \KeywordTok{class} \FunctionTok{CPSVar}\NormalTok{(x: String) }\KeywordTok{extends}\NormalTok{ CPSVal \{ }\KeywordTok{override} \KeywordTok{def}\NormalTok{ toString: String = x \}}
\KeywordTok{implicit} \KeywordTok{def} \FunctionTok{string2cpsExp}\NormalTok{(s: String): CPSVar = }\FunctionTok{CPSVar}\NormalTok{(s)}

\KeywordTok{case} \KeywordTok{class} \FunctionTok{CPSAdd}\NormalTok{(l: CPSVar, r: CPSVar) }\KeywordTok{extends}\NormalTok{ CPSVal}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{CPSFunApp}\NormalTok{(f: CPSVar, a: CPSVar, k: CPSVar) }\KeywordTok{extends}\NormalTok{ CPSExp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{CPSContApp}\NormalTok{(k: CPSVal, a: CPSVal) }\KeywordTok{extends}\NormalTok{ CPSExp}

\end{Highlighting}
\end{Shaded}

Wir unterscheiden zwei syntaktische Kategorien, nämlich \texttt{CPSVal}
(Werte) und \texttt{CPSExp} (Ausdrücke, die keinen Rückgabewert
besitzen). Addition betrachten wir als primitive Operation, die nicht
CPS-transformiert wird, und zählen diese somit zu \texttt{CPSVal}. Zu
den Werten gehört auch die Repräsentation von Bezeichnern,
\texttt{CPSVar}. Es wird zwischen Funktionsdefinitionen und
Continuations unterschieden, wodurch auch die Applikation von Funktionen
und Continuations getrennte Sprachkonstrukte sind. Bei Funktions- und
Continuationapplikationen haben die Argumente den Typ \texttt{CPSVar},
somit kann es sich nicht um geschachtelte Ausdrücke handeln, diese
würden nämlich nicht CPS entsprechen.

Wir benötigen wieder einen Mechanismus, um ``frische'' Bezeichner zu
generieren, diesen übernehmen von unserem substitutionsbasierten
FAE-Interpreter:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{freeVars}\NormalTok{(e: Exp) : Set[String] =  e }\KeywordTok{match}\NormalTok{ \{}
   \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} Set(x)}
   \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{freeVars}\NormalTok{(l) ++ }\FunctionTok{freeVars}\NormalTok{(r)}
   \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(x,body) =\textgreater{} }\FunctionTok{freeVars}\NormalTok{(body) {-} x}
   \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{freeVars}\NormalTok{(f) ++ }\FunctionTok{freeVars}\NormalTok{(a)}
   \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} Set.}\FunctionTok{empty}
\NormalTok{\}}
\KeywordTok{def} \FunctionTok{freshName}\NormalTok{(names: Set[String], default: String) : String = \{}
  \KeywordTok{var}\NormalTok{ last : Int = }\DecValTok{0}
  \KeywordTok{var}\NormalTok{ freshName = default}
  \KeywordTok{while}\NormalTok{ (names contains freshName) \{ freshName = default+last; last += }\DecValTok{1}\NormalTok{; \}}
\NormalTok{  freshName}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Die CPS-Transformation von FAE-Ausdrücken läuft folgendermaßen ab:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{cps}\NormalTok{(e: Exp) : CPSCont = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} \{}
    \FunctionTok{CPSCont}\NormalTok{(}\StringTok{"k"}\NormalTok{, }\FunctionTok{CPSContApp}\NormalTok{(}\StringTok{"k"}\NormalTok{, }\FunctionTok{CPSNum}\NormalTok{(n)))}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} \{}
    \KeywordTok{val}\NormalTok{ k = }\FunctionTok{freshName}\NormalTok{(}\FunctionTok{freeVars}\NormalTok{(e),}\StringTok{"k"}\NormalTok{)}
    \FunctionTok{CPSCont}\NormalTok{(k, }\FunctionTok{CPSContApp}\NormalTok{(k, }\FunctionTok{CPSVar}\NormalTok{(x)))}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} \{}
    \KeywordTok{val}\NormalTok{ k = }\FunctionTok{freshName}\NormalTok{(}\FunctionTok{freeVars}\NormalTok{(e),}\StringTok{"k"}\NormalTok{)}
    \KeywordTok{val}\NormalTok{ lv = }\FunctionTok{freshName}\NormalTok{(}\FunctionTok{freeVars}\NormalTok{(r),}\StringTok{"lv"}\NormalTok{)}
    \FunctionTok{CPSCont}\NormalTok{(k, }\FunctionTok{CPSContApp}\NormalTok{(}\FunctionTok{cps}\NormalTok{(l), }\FunctionTok{CPSCont}\NormalTok{(lv, }
      \FunctionTok{CPSContApp}\NormalTok{(}\FunctionTok{cps}\NormalTok{(r), }\FunctionTok{CPSCont}\NormalTok{(}\StringTok{"rv"}\NormalTok{, }
        \FunctionTok{CPSContApp}\NormalTok{(k, }\FunctionTok{CPSAdd}\NormalTok{(lv,}\StringTok{"rv"}\NormalTok{)))))))}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(p,b) =\textgreater{} \{}
    \KeywordTok{val}\NormalTok{ k = }\FunctionTok{freshName}\NormalTok{(}\FunctionTok{freeVars}\NormalTok{(e),}\StringTok{"k"}\NormalTok{)}
    \KeywordTok{val}\NormalTok{ dynK = }\FunctionTok{freshName}\NormalTok{(}\FunctionTok{freeVars}\NormalTok{(e),}\StringTok{"dynK"}\NormalTok{)}
    \FunctionTok{CPSCont}\NormalTok{(k, }\FunctionTok{CPSContApp}\NormalTok{(k, }\FunctionTok{CPSFun}\NormalTok{(p, dynK, }\FunctionTok{CPSContApp}\NormalTok{(}\FunctionTok{cps}\NormalTok{(b), dynK))))}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} \{}
    \KeywordTok{val}\NormalTok{ k = }\FunctionTok{freshName}\NormalTok{(}\FunctionTok{freeVars}\NormalTok{(e),}\StringTok{"k"}\NormalTok{)}
    \KeywordTok{val}\NormalTok{ fv = }\FunctionTok{freshName}\NormalTok{(}\FunctionTok{freeVars}\NormalTok{(a),}\StringTok{"fv"}\NormalTok{)}
    \FunctionTok{CPSCont}\NormalTok{(k, }\FunctionTok{CPSContApp}\NormalTok{(}\FunctionTok{cps}\NormalTok{(f), }\FunctionTok{CPSCont}\NormalTok{(fv,}
      \FunctionTok{CPSContApp}\NormalTok{(}\FunctionTok{cps}\NormalTok{(a), }\FunctionTok{CPSCont}\NormalTok{(}\StringTok{"av"}\NormalTok{,}
        \FunctionTok{CPSFunApp}\NormalTok{(fv,}\StringTok{"av"}\NormalTok{,k))))))}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Entsprechend der zu Beginn formulierten Regeln zur Transformation werden
Konstanten (\texttt{Num}- und \texttt{Id}-Ausdrücke) umgewandelt von
\texttt{c} in \texttt{k\ =\textgreater{}\ k(c)}, was als \texttt{CPSExp}
dem Ausdruck \texttt{CPSCont(k,\ CPSContApp(k,\ c))} entspricht. Im
\texttt{Add}- und \texttt{App}-Fall werden die zwei Unterausdrücke
sequentiell umgewandelt, wobei die Zwischenergebnisse jeweils an einen
Bezeichner (\texttt{CPSVar}, implizite Umwandlung von Strings) gebunden
werden.

Der Bezeichner \texttt{k} darf jeweils nicht in \texttt{e} vorkommen,
der Bezeichner für den transformierten linken Unterausdruck (\texttt{lv}
bzw. \texttt{fv}) darf nur nicht im rechten Unterausdruck vorkommen und
der Bezeichner für den transformierten rechten Unterausdruck kann frei
gewählt werden, da zwischen dem bindenden Vorkommen und der Verwendung
kein rekursive Transformation eines Unterausdrucks stattfindet.

Im \texttt{Fun}-Fall wird der Rumpf mit der dynamischen Continuation
transformiert und wird auch in den \texttt{CPSFun}-Ausdruck eingefügt.
Auf diesen wird dann die Continuation vom Zeitpunkt der Definition
angewendet.

Bei der hier verwendeten Transformation handelt es sich um die
sogenannte \emph{Fischer-Transformation}.

Die \textbf{Fischer-CPS-Transformation} ist ein möglicher
CPS-Transformationsalgorithmus von vielen verschiedenen. Der Vorteil der
Algorithmus ist seine Einfachheit und die Tatsache, dass es sich um eine
strukturelle Rekursion des abstrakten Syntaxbaums handelt. Ein großer
Nachteil ist aber, dass sogenannte \emph{administrativen Redexe} bei der
Umwandlung entstehen, dabei handelt es sich um Contination-Applikationen
von anonymen Funktionen, die nicht im ursprünglichen Programm enthalten
waren und direkt aufgelöst werden könnten.

Bspw. ergibt die Fischer-Transformation von \texttt{Add(2,3)} den
Ausdruck

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{CPSCont}\NormalTok{(}\StringTok{"k"}\NormalTok{, }\FunctionTok{CPSContApp}\NormalTok{(}\FunctionTok{CPSCont}\NormalTok{(}\StringTok{"k"}\NormalTok{, }\FunctionTok{CPSContApp}\NormalTok{(}\StringTok{"k"}\NormalTok{,}\DecValTok{2}\NormalTok{)),}
  \FunctionTok{CPSCont}\NormalTok{(}\StringTok{"lv"}\NormalTok{, }\FunctionTok{CPSContApp}\NormalTok{(}\FunctionTok{CPSCont}\NormalTok{(}\StringTok{"k"}\NormalTok{, }\FunctionTok{CPSContApp}\NormalTok{(}\StringTok{"k"}\NormalTok{,}\DecValTok{3}\NormalTok{)),}
    \FunctionTok{CPSCont}\NormalTok{(}\StringTok{"rv"}\NormalTok{, }\FunctionTok{CPSAdd}\NormalTok{(}\StringTok{"rv"}\NormalTok{,}\StringTok{"lv"}\NormalTok{))))))}
\end{Highlighting}
\end{Shaded}

anstelle von

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{CPSCont}\NormalTok{(}\StringTok{"k"}\NormalTok{, }\FunctionTok{CPSContApp}\NormalTok{(}\StringTok{"k"}\NormalTok{, }\FunctionTok{CPSAdd}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

Fortgeschrittenere Transformationsalgorithmen versuchen möglichst viele
dieser administrativen Redexe zu vermeiden.

\hypertarget{first-class-continuations}{%
\section{First-Class Continuations}\label{first-class-continuations}}

In Programmiersprachen mit \emph{First-Class Continuations} (bspw.
Scheme, Racket) gibt es Sprachkonstrukte, um die aktuelle Continuation
zu jedem Zeitpunkt abzugreifen und um damit zu arbeiten (also um die
Continuation zu reifizieren, zu binden, als Parameter zu übergeben oder
aufzurufen). Mit solch einem Sprachfeature kann der Programmierer bspw.
fortgeschrittene Kontrollstrukturen selbst definieren.

In Racket gibt es die Funktion \texttt{let/cc}, mit der die aktuelle
Continuation an einen Identifier gebunden und im Rumpf von
\texttt{let/cc} aufgerufen werden kann.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[\textgreater{}]}\NormalTok{ (}\KeywordTok{number{-}\textgreater{}string}\NormalTok{ (}\OperatorTok{+} \DecValTok{1}\NormalTok{ (let/cc k (}\KeywordTok{string{-}length}\NormalTok{ (k }\DecValTok{3}\NormalTok{)))))}
\StringTok{"4"}
\end{Highlighting}
\end{Shaded}

Im obigen Beispiel werden die Funktionsaufrufe vor dem Aufruf von
\texttt{let/cc} als Continuation an \texttt{k} gebunden, im Rumpf von
\texttt{let/cc} wird dann \texttt{k} mit \texttt{3} aufgerufen und damit
die Continuation fortgesetzt, es werden die in der Contination
gespeicherten Funktionsaufrufe angewendet und \texttt{"4"} ausgegeben.
Der Aufruf von \texttt{k} kehrt nicht zurück, wodurch der
Funktionsaufruf von \texttt{string-length} zwischen \texttt{let/cc} und
\texttt{k} nicht mehr auf das Ergebnis angewendet wird.

Die Continuation kann auch durch \texttt{set!} an einen globalen
Identifier gebunden werden, um sie außerhalb des Rumpfes von
\texttt{let/cc} aufrufen zu können:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[\textgreater{}]}\NormalTok{ (}\ExtensionTok{define}\FunctionTok{ c }\StringTok{"dummy"}\NormalTok{)}
\OperatorTok{[\textgreater{}]}\NormalTok{ (}\KeywordTok{number{-}\textgreater{}string}\NormalTok{ (}\OperatorTok{+} \DecValTok{1}\NormalTok{ (let/cc k (}\KeywordTok{begin}\NormalTok{ (}\KeywordTok{set!}\NormalTok{ c k) (k }\DecValTok{3}\NormalTok{)))))}
\StringTok{"4"}
\OperatorTok{[\textgreater{}]}\NormalTok{ (c }\DecValTok{5}\NormalTok{)}
\StringTok{"6"}
\end{Highlighting}
\end{Shaded}

\hypertarget{fae-mit-first-class-continuations}{%
\section{FAE mit
First-Class-Continuations}\label{fae-mit-first-class-continuations}}

Nun wollen wir unserem FAE-Interpreter First-Class-Continuations als
Sprachfeature hinzufügen. Wir ergänzen dazu das folgende
Sprachkonstrukt:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class} \FunctionTok{LetCC}\NormalTok{(param: String, body: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\end{Highlighting}
\end{Shaded}

Bei einem Aufruf von \texttt{LetCC} soll, wie in Racket, die aktuelle
Contination an den Bezeichner \texttt{param} gebunden werden, wobei die
Bindung im Rumpf von \texttt{LetCC} gültig ist.

In einem Programm, das bereits in CPS vorliegt, wäre das Bestimmen der
aktuellen Continuation trivial. Für unsere Implementation von
\texttt{LetCC} wollen wir aber nicht alle Programme transformieren,
sondern stattdessen den Interpreter selbst in CPS verfassen.
Continuations auf Interpreter-Ebene repräsentieren nämlich auch die noch
durchzuführende Auswertung auf Ebene der Objektsprache.

Bei einer Implementierung durch die automatische CPS-Transformation von
Programmen müsste jedes Programm erst transformiert werden. Der
Interpreter muss hingegen nur ein Mal transformiert werden. Der erste
Schritt zur Implementierung von \texttt{LetCC} ist also das
Transformieren des Interpreters.

\hypertarget{cps-transformation-des-interpreters}{%
\subsection{CPS-Transformation des
Interpreters}\label{cps-transformation-des-interpreters}}

Wir beginnen mit unserem FAE-Interpreter:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp, env: Env) : Value = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(n)}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} }\FunctionTok{env}\NormalTok{(x)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{eval}\NormalTok{(l,env),}\FunctionTok{eval}\NormalTok{(r,env)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(a),}\FunctionTok{NumV}\NormalTok{(b)) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(a+b)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case}\NormalTok{ f@}\FunctionTok{Fun}\NormalTok{(\_,\_) =\textgreater{} }\FunctionTok{ClosureV}\NormalTok{(f,env)}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f,env) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{ClosureV}\NormalTok{(f,cEnv) =\textgreater{}}
      \FunctionTok{eval}\NormalTok{(f.}\FunctionTok{body}\NormalTok{, cEnv+(f.}\FunctionTok{param}\NormalTok{ {-}\textgreater{} }\FunctionTok{eval}\NormalTok{(a,env)))}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Wir ersetzen den Rückgabetypen mit \texttt{Nothing} und ergänzen einen
Continuation-Parameter \texttt{k} mit dem Typ
\texttt{Value\ =\textgreater{}\ Nothing}. Der \texttt{Num}-,
\texttt{Id}- und \texttt{Fun}-Fall sind trivial, da diese nicht rekursiv
sind, hier reichen wir das Ergebnis einfach an \texttt{k} weiter. Im
\texttt{Add}- und \texttt{App}-Fall muss die Auswertung des linken und
rechten Unterausdrucks sequentialisiert werden, wir werten von links
nach rechts aus.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp, env: Env, k: Value =\textgreater{} Nothing) : Nothing = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{NumV}\NormalTok{(n))}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{env}\NormalTok{(x))}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{eval}\NormalTok{(l, env, lv =\textgreater{} }\FunctionTok{eval}\NormalTok{(r, env, rv =\textgreater{} (lv,rv) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(a),}\FunctionTok{NumV}\NormalTok{(b)) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{NumV}\NormalTok{(a+b))}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{  \}))}
  \KeywordTok{case}\NormalTok{ f@}\FunctionTok{Fun}\NormalTok{(\_,\_) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{ClosureV}\NormalTok{(f,env))}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f, env, fv =\textgreater{} fv }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{ClosureV}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(p,b),cEnv) =\textgreater{}}
      \FunctionTok{eval}\NormalTok{(a, env, av =\textgreater{} }\FunctionTok{eval}\NormalTok{(b, cEnv+(p {-}\textgreater{} av), k))}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{  \})}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Im \texttt{Add}-Fall werten wir erst den linken Unterausdruck aus und
übergeben dabei eine Continuation, die das Ergebnis an \texttt{lv}
bindet und mit der Auswertung des rechten Unterausdrucks fortfährt.
Deren Ergebnis wird durch die übergebene Continuation an \texttt{rv}
gebunden. Wie im ursprünglichen Interpreter werden nun durch Pattern
Matching die Zahlen extrahiert und ein \texttt{NumV}-Objekt mit deren
Summe erzeugt, dieses wird nun aber an \texttt{k} überreicht.

Im \texttt{App}-Fall wird auch erst der linke Teilausdruck ausgewertet
und diesmal durch die Continuation an \texttt{fv} gebunden, durch
Pattern Matching werden Parameter und Rumpf der Funktion sowie die
Umgebung im Closure gebunden. Nun wird das Argument ausgewertet, durch
die übergebene Continuation an \texttt{av} gebunden und zuletzt
\texttt{eval} mit dem Rumpf, der Umgebung inkl. neuer Bindung und der
Continuation \texttt{k} aufgerufen.

Um den Interpreter auch ohne Rückgabe testen zu können, verwenden wir
folgende Funktion:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{startEval}\NormalTok{(e: Exp) : Value = \{}
  \KeywordTok{var}\NormalTok{ res: Value = }\KeywordTok{null}
  \KeywordTok{val}\NormalTok{ s: Value =\textgreater{} Nothing = v =\textgreater{} \{ res = v; sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Program terminated"}\NormalTok{) \}}
  \KeywordTok{try}\NormalTok{ \{ }\FunctionTok{eval}\NormalTok{(e, Map(), s) \} }\KeywordTok{catch}\NormalTok{ \{ }\KeywordTok{case}\NormalTok{ \_: Throwable =\textgreater{} () \}}
\NormalTok{  res}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Es wird \texttt{eval} eine Continuation überreicht, die das Ergebnis der
Auswertung bindet und dann mit einem Fehler die Auswertung beendet (um
den Rückgabetyp \texttt{Nothing} zu erfüllen). Die Auswertung selbst
wird in einem Try-Catch-Block gestartet, um den Fehler abzufangen. Das
durch die Continuation gebundene Ergebnis wird von \texttt{startEval}
ausgegeben.

Die CPS-Transformation des Interpreters hat zur Folge, dass der
Interpreter nicht mehr vom Call-Stack der Hostsprache abhängig ist, da
nun jeder Funktionsaufruf ein Tail Call ist und die noch notwendigen
Auswertungsschritte jeweils in Form der Continuation überreicht werden.

\hypertarget{implementierung-von-letcc}{%
\subsection{Implementierung von
`LetCC'}\label{implementierung-von-letcc}}

Jetzt wo der Interpreter selbst CPS-transformiert ist, können wir das
neue Sprachkonstrukt \texttt{LetCC} mit wenig Aufwand ergänzen, da wir
die Continuations auf Interpreter-Ebene als Continuations der
Objektsprache nutzen können. Zuerst erweitern wir \texttt{Exp} um das
Sprachkonstrukt \texttt{LetCC}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class} \FunctionTok{LetCC}\NormalTok{(param: String, body: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\end{Highlighting}
\end{Shaded}

Im Interpreter ergänzen wir den \texttt{LetCC}-Fall, hier setzen wir die
Auswertung rekursiv im Body fort, wobei wir den Parameter in
\texttt{LetCC} an die aktuelle Continuation \texttt{k} binden. Da
\texttt{k} den Typ \texttt{Value\ =\textgreater{}\ Nothing}, die
Umgebung aber den Typ \texttt{Map{[}String,Value{]}} besitzt, können wir
die Continuation nicht direkt in der Umgebung binden. Stattdessen
erweitern wir \texttt{Value} um den Fall \texttt{ContV}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class} \FunctionTok{ContV}\NormalTok{(k: Value =\textgreater{} Nothing) }\KeywordTok{extends}\NormalTok{ Value}
\end{Highlighting}
\end{Shaded}

Nun sind Continations eine Werte-Art und können wie andere Werte an
Identifier gebunden werden, wordurch wir den \texttt{LetCC}-Fall
verfassen können:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \FunctionTok{LetCC}\NormalTok{(p,b) =\textgreater{} }\FunctionTok{eval}\NormalTok{(b, env+(p {-}\textgreater{} }\FunctionTok{ContV}\NormalTok{(k)))}
\end{Highlighting}
\end{Shaded}

Es fehlt noch die Applikation von Continuations, hierzu überladen wir
das \texttt{App}-Konstrukt, so dass damit sowohl Funktionen als auch
Continuations angewendet werden können. Im \texttt{App}-Fall müssen wir
nun die Fallunterscheidung um einen \texttt{ContV}-Fall neben dem
\texttt{ClosureV}-Fall erweitern:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f, env, fv =\textgreater{} fv }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{ClosureV}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(p,b),cEnv) =\textgreater{}}
    \FunctionTok{eval}\NormalTok{(a, env, av =\textgreater{} }\FunctionTok{eval}\NormalTok{(b, cEnv+(p {-}\textgreater{} av), k))}
  \KeywordTok{case} \FunctionTok{ContV}\NormalTok{(k2) =\textgreater{} }\FunctionTok{eval}\NormalTok{(a, env, av =\textgreater{} }\FunctionTok{k2}\NormalTok{(av))}
  \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Im \texttt{ContV}-Zweig werten wir das Argument aus und übergeben dabei
eine Continuation, die das Ergebnis an \texttt{av} bindet und dann der
aufzurufenden Continuation \texttt{k2} aus dem \texttt{ContV}-Objekt
\texttt{av} überreicht. Dabei wird die aktuelle Continuation \texttt{k}
ignoriert, die Auswertung ``springt'' ohne zurückzukehren. Der Wechsel
zur Continuation \texttt{k2} kann als ein Austauschen des Call-Stacks
aufgefasst werden.

Durch das ``Wrappen'' der Interpreter-Continuations (auf Ebene der
Metasprache) können wir diese also als Continuations für die
Objektsprache verwenden.

\hypertarget{delimited-continuations}{%
\section{Delimited Continuations}\label{delimited-continuations}}

Die (\emph{Undelimited}) Continuations, die wir bisher kennen gelernt
haben, führen bei einem Aufruf zu einem ``Sprung'' (ähnlich zu einer
\texttt{GOTO}-Anweisung), wobei die Auswertung nicht mehr zur Stelle des
Aufrufs zurückkehrt. Somit ist keine Komposition (d.h.
``Nacheinanderschalten'' und damit Kombinieren) von Continuations
möglich.

Dies ist mit \emph{Delimited Continuation} möglich, sie repräsentieren
nur einen Ausschnitt des Call-Stacks (während \emph{Undelimited
Continuations} den gesamten Call-Stack repräsentieren) und kehren wie
gewöhnliche Funktionen zurück. Dadurch ist die Komposition von Delimited
Continuations möglich, sie werden deshalb auch als \emph{Composable
Continuations} bezeichnet.

Delimited Continuations sind ein sehr mächtiges Sprachkonstrukt und
erlauben bspw. die Programmierung von fortgeschrittenem Exception
Handling oder Backtracking-Algorithmen.

In der Racket-Bibliothek \texttt{racket/control} gibt es die zwei
Funktionen \texttt{shift} und \texttt{reset}, mit denen Delimited
Continuations erzeugt werden können. Dabei verhält sich \texttt{shift}
ähnlich wie \texttt{let/cc}, wobei aber nur die Continuation ab dem (im
AST) nächstliegenden Aufruf von \texttt{reset} gebunden wird, die
Continuation wird also durch \texttt{reset} begrenzt
(\emph{delimitiert}) und repräsentiert nur den Ausschnitt des
Call-Stacks zwischen \texttt{reset} und \texttt{shift}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\OperatorTok{*} \DecValTok{2}\NormalTok{ (reset (}\OperatorTok{+} \DecValTok{1}\NormalTok{ (shift k (k }\DecValTok{5}\NormalTok{)))))}
\end{Highlighting}
\end{Shaded}

Im obigen Beispiel wird die Continuation, die durch \texttt{shift} an
\texttt{k} gebunden wird, durch \texttt{reset} auf den Aufruf von
\texttt{+} mit \texttt{1} beschränkt. Wird \texttt{k} auf \texttt{5}
aufgerufen, so wird nur die Addition auf \texttt{5} durchgeführt, die
Multiplikation vor \texttt{reset} gehört nicht zur Continuation. Somit
entspricht die Berechnung \texttt{(*\ 2\ (+\ 1\ 5))} und das Ergebnis
ist \texttt{12}. Da es sich bei \texttt{k} um eine Delimited
Continuation handelt, ist auch Continuation-Komposition möglich:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\OperatorTok{*} \DecValTok{2}\NormalTok{ (reset (}\OperatorTok{+} \DecValTok{1}\NormalTok{ (shift k (k (k }\DecValTok{5}\NormalTok{))))))}
\end{Highlighting}
\end{Shaded}

In diesem Fall wird \texttt{k} zwei Mal auf \texttt{5} angewendet, die
Berechnung entspricht also \texttt{(*\ 2\ (+\ 1\ (+\ 1\ 5)))} und das
Ergebnis ist \texttt{14}.

\hypertarget{interpreter-mit-delimited-continuations}{%
\subsection{Interpreter mit Delimited
Continuations}\label{interpreter-mit-delimited-continuations}}

Wir können im CPS-transformierten Interpreter mit wenig Aufwand
Sprachkonstrukte hinzufügen, die \texttt{shift} und \texttt{reset} aus
Racket entsprechen. Wir ergänzen dazu \texttt{Exp} um die zwei neuen
Cases \texttt{Shift} und \texttt{Reset}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Shift}\NormalTok{(param: String, body: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Reset}\NormalTok{(body: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\end{Highlighting}
\end{Shaded}

Wir müssen den Typ des Interpreters ändern, da Aufrufe von Delimited
Continuations zurückkehren und die Berechnung nicht abbrechen. Dadurch
haben Continuations den Typ \texttt{Value\ =\textgreater{}\ Value} und
der Interpreter gibt einen \texttt{Value} zurück. Im Interpreter
ergänzen wir die entsprechenden Fälle und passen den \texttt{App}-Fall
an (Änderungen mit \texttt{\textless{}-\/-} markiert):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp, env: Env, k: Value =\textgreater{} Value) : Value = e }\KeywordTok{match}\NormalTok{ \{}
  \CommentTok{// ...}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f, env, fv =\textgreater{} fv }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{ClosureV}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(p,b),cEnv) =\textgreater{}}
      \FunctionTok{eval}\NormalTok{(a, env, av =\textgreater{} }\FunctionTok{eval}\NormalTok{(b, cEnv+(p {-}\textgreater{} av), k))}
    \KeywordTok{case} \FunctionTok{ContV}\NormalTok{(k2) =\textgreater{} }\FunctionTok{eval}\NormalTok{(a, env, av =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{k2}\NormalTok{(av))) }\CommentTok{// \textless{}{-}{-}}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{  \})}
  \KeywordTok{case} \FunctionTok{Reset}\NormalTok{(e) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{eval}\NormalTok{(e,env,x=\textgreater{}x)) }\CommentTok{// \textless{}{-}{-}}
  \KeywordTok{case} \FunctionTok{Shift}\NormalTok{(p,b) =\textgreater{} }\FunctionTok{eval}\NormalTok{(b, env+(p {-}\textgreater{} }\FunctionTok{ContV}\NormalTok{(k)), x=\textgreater{}x) }\CommentTok{// \textless{}{-}{-}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Im \texttt{Reset}-Fall wird die aktuelle Continuation zurückgesetzt,
indem die Identitätsfunktion anstelle von \texttt{k} weitergereicht
wird. Im \texttt{Shift}-Fall wird wie im \texttt{LetCC}-Fall die
aktuelle Continuation ``umhüllt'' und in der Umgebung an den Identifier
gebunden. Außerdem wird hier auch die Continuation zurückgesetzt (weil
dies dem Verhalten in Racket entspricht).

Im \texttt{App}-Fall wird bei der Applikation von Continuations die
aktuelle Continuation nun nicht mehr verworfen, sondern wird mit dem
Ergebnis der Continuation-Applikation aufgerufen, d.h. es findet eine
Komposition der aktuellen Continuation nach der aufgerufenen
Continuation statt.

\hypertarget{monaden}{%
\section{Monaden}\label{monaden}}

In unseren bisherigen Interpretern haben wir bereits einige verschiedene
``Rekursions-Patterns'' gesehen: - Im
\protect\hyperlink{erster-interpreter-ae}{ersten Interpreter} haben wir
direkte Rekursion, bei der die \texttt{eval}-Funktion rekursiv auf den
Unterausdrücken aufgerufen wird. Die rekursive Auswertung entspricht
exakt der rekursiven Datenstruktur, in denen die Programme repräsentiert
sind (\emph{strukturelle Rekursion}).

\begin{itemize}
\item
  Bei der Einführung von Environments in
  \protect\hyperlink{identifier-mit-umgebung-aeid}{AEId} oder in
  \protect\hyperlink{closures}{FAE} wird die Environment bei der
  rekursiven Auswertung im abstrakten Syntaxbaum (AST) nach unten
  weitergereicht, d.h. der zusätzliche Parameter \texttt{env} wird
  entlang der Datenstruktur propagiert.
\item
  Bei der Ergänzung von mutierbaren Boxen in
  \protect\hyperlink{interpreter}{BCFAE} haben wir den
  \texttt{Store}-Parameter hinzugefügt, der immer von der aktuellen
  Auswertungsposition zur nächsten Auswertungsposition gereicht (und
  dazwischen potentiell modifizert) wird.
\item
  Der
  \protect\hyperlink{fae-mit-first-class-continuations}{CPS-transformierte
  Interpreter} entspricht dem Continuation Passing Style, den wir
  bereits ausführlich besprochen haben.
\end{itemize}

\emph{Monaden} sind eine Möglichkeit, über solche (und noch viel mehr)
Funktionskompositions-Patterns zu abstrahieren. Durch Monaden ist es
möglich, einmalig verfassten Code in all diese Stile zu übersetzen.

Zur Einführung von Monaden wollen wir aber vorerst einen anderen Stil
betrachten.

\hypertarget{einfuxfchrung-mit-option-monade}{%
\subsection{Einführung mit
Option-Monade}\label{einfuxfchrung-mit-option-monade}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ expr = }\FunctionTok{h}\NormalTok{(!}\FunctionTok{g}\NormalTok{(}\FunctionTok{f}\NormalTok{(}\DecValTok{27}\NormalTok{)+}\StringTok{"z"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Angenommen, die Funktionen \texttt{f} und \texttt{h}, die im obigen
Ausdruck aufgerufen werden, können in manchen Fällen keine Ausgabe
liefern (was bspw. daran liegen könnte, dass sie intern Anfragen über
ein Netzwerk schicken). In solch einem Fall wäre es sinnvoll, den
\texttt{Option}-Datentyp zu verwenden, um auch bei fehlgeschlagener
Auswertung \texttt{None} ausgeben zu können. Bei erfolgreicher
Auswertung wird das Ergebnis mit \texttt{Some()} umhüllt:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{f}\NormalTok{(n: Int) : Option[String] = }\KeywordTok{if}\NormalTok{ (n \textless{} }\DecValTok{100}\NormalTok{) Some(}\StringTok{"x"}\NormalTok{) }\KeywordTok{else}\NormalTok{ None}
\KeywordTok{def} \FunctionTok{g}\NormalTok{(x: String) : Option[Boolean] = Some(x == }\StringTok{"x"}\NormalTok{)}
\KeywordTok{def} \FunctionTok{h}\NormalTok{(b: Boolean) : Option[Int] = }\KeywordTok{if}\NormalTok{ (b) Some(}\DecValTok{27}\NormalTok{) }\KeywordTok{else}\NormalTok{ None}
\end{Highlighting}
\end{Shaded}

Da aber Aufrufe der Funktionen potentiell \texttt{None} anstelle eines
Ergebnisses liefern, muss \texttt{expr} modifiziert werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ expr = }\FunctionTok{f}\NormalTok{(}\DecValTok{27}\NormalTok{) }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case}\NormalTok{ Some(x) =\textgreater{} }\FunctionTok{g}\NormalTok{(x+}\StringTok{"z"}\NormalTok{) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ Some(y) =\textgreater{} }\FunctionTok{h}\NormalTok{(!y)}
        \KeywordTok{case}\NormalTok{ None =\textgreater{} None}
\NormalTok{  \}}
    \KeywordTok{case}\NormalTok{ None =\textgreater{} None}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Bei jedem Aufruf muss anschließend ein Pattern-Match genutzt werden, um
die zwei Fälle (\texttt{None} und \texttt{Some()}) zu unterscheiden und
im \texttt{Some()}-Fall die Auswertung mit dem Ergebnis fortzusetzen. Es
ist erkennbar, dass dieses Pattern bei jedem Aufruf einer Funktion mit
Rückgabetyp \texttt{Option{[}T{]}} auftritt, wir abstrahieren also über
das Pattern mit der folgenden Funktion:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ bindOption[A,B](a: Option[A], f: A =\textgreater{} Option[B]) : Option[B] = a }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case}\NormalTok{ Some(x) =\textgreater{} }\FunctionTok{f}\NormalTok{(x)}
  \KeywordTok{case}\NormalTok{ None =\textgreater{} None}
\NormalTok{\}}

\KeywordTok{def}\NormalTok{ expr = }
  \FunctionTok{bindOption}\NormalTok{(}\FunctionTok{f}\NormalTok{(}\DecValTok{27}\NormalTok{), (x: String) =\textgreater{} }
    \FunctionTok{bindOption}\NormalTok{(}\FunctionTok{g}\NormalTok{(x+}\StringTok{"z"}\NormalTok{), (y: Boolean) =\textgreater{}}
      \FunctionTok{h}\NormalTok{(!y)))}
\end{Highlighting}
\end{Shaded}

Mit \texttt{bindOption} können wir jeden Ausdruck im ``Option-Stil''
vereinfachen und die Redundanz des wiederholten, gleichartigen
Pattern-Matchings vermeiden.

Angenommen, auf das verneinte Ergebnis von \texttt{g} wird nicht mehr
\texttt{h} angewendet:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ expr2 = !}\FunctionTok{g}\NormalTok{(}\FunctionTok{f}\NormalTok{(}\DecValTok{27}\NormalTok{)+}\StringTok{"z"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Dann muss das Ergebnis vor der Ausgabe wieder mit \texttt{Some()}
``verpackt'' werden, damit der Rückgabetyp \texttt{Option} (und damit
der Option-Stil) erfüllt bleibt. Dies ist aber nicht mit
\texttt{bindOption} möglich, sondern wir müssten \texttt{Some()}
explizit aufrufen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ expr2 =}
  \FunctionTok{bindOption}\NormalTok{(}\FunctionTok{f}\NormalTok{(}\DecValTok{27}\NormalTok{), (x: String) =\textgreater{}}
    \FunctionTok{bindOption}\NormalTok{(}\FunctionTok{g}\NormalTok{(x+}\StringTok{"z"}\NormalTok{), (y: Boolean) =\textgreater{}}
\NormalTok{      Some(!y)))}
\end{Highlighting}
\end{Shaded}

Da wir aber über das Pattern der Funktionskomposition abstrahieren
wollen, soll der \texttt{Option}-Datentyp nicht sichtbar sein. Wir fügen
also unserem Funktionskompositions-Interface stattdessen neben
\texttt{bindOption} eine zweite Funktion \texttt{unitOption} hinzu:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ bindOption[A,B](a: Option[A], f: A =\textgreater{} Option[B]) : Option[B] = a }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case}\NormalTok{ Some(x) =\textgreater{} }\FunctionTok{f}\NormalTok{(x)}
  \KeywordTok{case}\NormalTok{ None =\textgreater{} None}
\NormalTok{\}}

\KeywordTok{def}\NormalTok{ unitOption[A](a: A) : Option[A] = Some(a)}
\end{Highlighting}
\end{Shaded}

Mit \texttt{unitOption} können wir \texttt{expr2} folgendermaßen
ausdrücken:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ expr2 =}
  \FunctionTok{bindOption}\NormalTok{(}\FunctionTok{f}\NormalTok{(}\DecValTok{27}\NormalTok{), (x: String) =\textgreater{}}
    \FunctionTok{bindOption}\NormalTok{(}\FunctionTok{g}\NormalTok{(x+}\StringTok{"z"}\NormalTok{), (y: Boolean) =\textgreater{}}
      \FunctionTok{unitOption}\NormalTok{(!y)))}
\end{Highlighting}
\end{Shaded}

Nun haben wir den Option-Stil abstrahiert, wir können aber einen Schritt
weiter gehen und über den Typ \texttt{Option} abstrahieren, um beliebige
Patterns auszudrücken. Dabei erhalten wir das \emph{Monad-Interface}.

\hypertarget{definition}{%
\subsection{Definition}\label{definition}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ Monad[M[\_]] \{}
  \KeywordTok{def} \DataTypeTok{unit}\NormalTok{[A](a: A) : M[A]}
  \KeywordTok{def}\NormalTok{ bind[A,B](m: M[A], f: A =\textgreater{} M[B]) : M[B]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Eine Monade ist ein Tripel aus einem Typkonstruktor (\texttt{M{[}\_{]}})
und zwei Funktionen, nämlich \texttt{unit} und \texttt{bind}. Es müssen
zudem die folgenden \emph{Monadengesetze} gelten: -
\texttt{bind(unit(x),f)\ ==\ f(x)} -
\texttt{bind(x,\ y\ =\textgreater{}\ unit(y))\ ==\ x} -
\texttt{bind(bind(x,f),g)\ ==\ bind(x,\ y\ =\textgreater{}\ bind(f(y),g))}

D.h. \texttt{unit} ist eine Art ``neutrales Element'' und \texttt{bind}
ist eine assoziative Operation.

Monaden dienen zur Funktionskomposition für Fälle, in denen der
Rückgabetyp einer Funktion nicht dem Parametertyp der danach
anzuwendenden Funktion entspricht, sondern ein ``Zwischenschritt''
notwendig ist.

Mit dem Monad-Interface kann das Einführungsbeispiel folgendermaßen
ausgedrückt werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{object}\NormalTok{ OptionMonad }\KeywordTok{extends}\NormalTok{ Monad[Option] \{}
  \KeywordTok{override} \KeywordTok{def} \DataTypeTok{unit}\NormalTok{[A](a: A) : Option[A] = Some(a)}
  \KeywordTok{override} \KeywordTok{def}\NormalTok{ bind[A,B](m: Option[A], f: A =\textgreater{} Option[B]) : Option[B] = m }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ Some(y) =\textgreater{} }\FunctionTok{f}\NormalTok{(y)}
    \KeywordTok{case}\NormalTok{ None =\textgreater{} None}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{expr2}\NormalTok{(m: Monad[Option]) =}
\NormalTok{  m.}\FunctionTok{bind}\NormalTok{(}\FunctionTok{f}\NormalTok{(}\DecValTok{27}\NormalTok{), (x: String) =\textgreater{}}
\NormalTok{    m.}\FunctionTok{bind}\NormalTok{(}\FunctionTok{g}\NormalTok{(x+}\StringTok{"z"}\NormalTok{), (y: Boolean) =\textgreater{}}
\NormalTok{      m.}\FunctionTok{unit}\NormalTok{(!y)))}
      
\KeywordTok{val}\NormalTok{ expr2Res = }\FunctionTok{expr2}\NormalTok{(OptionMonad)}
\end{Highlighting}
\end{Shaded}

\hypertarget{for-comprehension-syntax}{%
\subsection{For-Comprehension-Syntax}\label{for-comprehension-syntax}}

Die geschachtelten Aufrufe von \texttt{bind} sind bei komplexeren
Beispielen etwas unleserlich, es kann aber die sogenannte
\emph{Monad-Comprehension}-Notation verwendet werden, um die Ausdrücke
einfacher auszudrücken. Monad Comprehensions werden in Haskell und
manchen anderen Sprachen nativ unterstützt, in Scala müssen wir
stattdessen die \emph{For-Comprehension}-Syntax für diese Zwecke
``hijacken''.

Diese Syntax wird im Normalfall für Listen und andere
\texttt{Collection}-Datentypen verwendet:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ l = List(List(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{),List(}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{))}

\KeywordTok{val}\NormalTok{ res = }\KeywordTok{for}\NormalTok{ \{}
\NormalTok{  x \textless{}{-} l; }
\NormalTok{  y \textless{}{-} x \} }\KeywordTok{yield}\NormalTok{ y+}\DecValTok{1} \CommentTok{// == List(2,3,4,5)}
\end{Highlighting}
\end{Shaded}

Durch Desugaring werden For-Comprehensions in Aufrufe von
\texttt{flatMap} und \texttt{map} umgewandelt:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ res = l.}\FunctionTok{flatMap}\NormalTok{(x =\textgreater{} x.}\FunctionTok{map}\NormalTok{(y =\textgreater{} y+}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Diese Syntax kann für alle Datentypen angewendet werden, für die
\texttt{map} und \texttt{flatMap} definiert ist. Mit der folgenden
Funktionsdefinition kann somit die Syntax der For-Comprehensions für das
Programmieren mit Monaden genutzt werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{implicit} \KeywordTok{def}\NormalTok{ monadicSyntax[A, M[\_]](m: M[A])(}\KeywordTok{implicit}\NormalTok{ mm: Monad[M]) = }\KeywordTok{new}\NormalTok{ \{}
  \KeywordTok{def}\NormalTok{ map[B](f: A =\textgreater{} B): Any = mm.}\FunctionTok{bind}\NormalTok{(m, (x: A) =\textgreater{} mm.}\FunctionTok{unit}\NormalTok{(}\FunctionTok{f}\NormalTok{(x)))}
  \KeywordTok{def}\NormalTok{ flatMap[B](f: A =\textgreater{} M[B]): M[B] = mm.}\FunctionTok{bind}\NormalTok{(m, f)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Durch die obige implizite Definition, in der wir \texttt{map} und
\texttt{flatMap} so definieren, dass \texttt{map} der Kombination von
\texttt{bind} und \texttt{unit} entspricht und \texttt{flatMap} der
\texttt{bind}-Operation entspricht, sorgen wir dafür, dass die
For-Comprehension-Syntax für die \texttt{Monad}-Klasse genutzt werden
kann.

Unser Option-Monad-Beispiel kann mit dieser Syntax wie folgt ausgedrückt
werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{expr2}\NormalTok{(m: Monad[Option]) = }\KeywordTok{for}\NormalTok{ \{}
\NormalTok{  x \textless{}{-} }\FunctionTok{f}\NormalTok{(}\DecValTok{27}\NormalTok{);}
\NormalTok{  y \textless{}{-} }\FunctionTok{g}\NormalTok{(x+}\StringTok{"z"}\NormalTok{) }
\NormalTok{\} }\KeywordTok{yield}\NormalTok{ !y}
\end{Highlighting}
\end{Shaded}

\hypertarget{operationen-auf-monaden}{%
\subsection{Operationen auf Monaden}\label{operationen-auf-monaden}}

Es lassen sich einige nützliche Operationen generisch für beliebige
Monaden definieren:

\texttt{fmap} wandelt jede Funktion mit Typ
\texttt{A\ =\textgreater{}\ B} in eine Funktion vom Typ
\texttt{M{[}A{]}\ =\textgreater{}\ M{[}B{]}} um.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ fmap[M[\_],A,B](f: A =\textgreater{} B)(}\KeywordTok{implicit}\NormalTok{ m: Monad[M]): M[A] =\textgreater{} M[B] = }
\NormalTok{  a =\textgreater{} m.}\FunctionTok{bind}\NormalTok{(a, (x: A) =\textgreater{} m.}\FunctionTok{unit}\NormalTok{(}\FunctionTok{f}\NormalTok{(x)))}

\FunctionTok{assert}\NormalTok{( }\FunctionTok{fmap}\NormalTok{((n: Int) =\textgreater{} n.}\FunctionTok{toString}\NormalTok{)(OptionMonad)(Some(}\DecValTok{1}\NormalTok{)) == Some(}\StringTok{"1"}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\texttt{sequence} verknüpft eine Liste monadischer Werte zu einem
einzelnen monadischen Wert, der eine Liste ist, aus einem Wert des Typs
\texttt{List{[}M{[}A{]}{]}} wird ein Wert des Typs
\texttt{M{[}List{[}A{]}{]}}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ sequence[M[\_],A](l: List[M[A]])(}\KeywordTok{implicit}\NormalTok{ m: Monad[M]) : M[List[A]] = l }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case}\NormalTok{ x :: xs =\textgreater{} }
\NormalTok{      m.}\FunctionTok{bind}\NormalTok{(x, (y: A) =\textgreater{} }
\NormalTok{        m.}\FunctionTok{bind}\NormalTok{(}\FunctionTok{sequence}\NormalTok{(xs), (ys : List[A]) =\textgreater{}}
\NormalTok{          m.}\FunctionTok{unit}\NormalTok{(y :: ys)))}
  \KeywordTok{case}\NormalTok{ Nil =\textgreater{} m.}\FunctionTok{unit}\NormalTok{(List.}\FunctionTok{empty}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{ex}\NormalTok{(}\KeywordTok{implicit}\NormalTok{ m: Monad[Option]) =}
\NormalTok{  List(m.}\FunctionTok{unit}\NormalTok{(}\DecValTok{1}\NormalTok{),m.}\FunctionTok{unit}\NormalTok{(}\DecValTok{2}\NormalTok{),m.}\FunctionTok{unit}\NormalTok{(}\DecValTok{3}\NormalTok{))}

\CommentTok{// List[Option[Int]] =\textgreater{} Option[List[Int]]}
\FunctionTok{assert}\NormalTok{( }\FunctionTok{sequence}\NormalTok{(}\FunctionTok{ex}\NormalTok{(OptionMonad))(OptionMonad) == Some(List(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)) )}
\end{Highlighting}
\end{Shaded}

\texttt{mapM} verknüpft \texttt{sequence} und \texttt{map}. Es wird also
aus \texttt{List{[}A{]}} erst \texttt{List{[}M{[}B{]}{]}} (durch
\texttt{map}) und anschließend aus \texttt{List{[}M{[}B{]}{]}} (durch
\texttt{sequence}) \texttt{M{[}List{[}B{]}{]}}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ mapM[M[\_],A,B](f : A =\textgreater{} M[B], l: List[A])(}\KeywordTok{implicit}\NormalTok{ m: Monad[M]) : M[List[B]] =}
  \FunctionTok{sequence}\NormalTok{(l.}\FunctionTok{map}\NormalTok{(f))}

\FunctionTok{assert}\NormalTok{( mapM[Option,Int,String](n =\textgreater{} Some(n.}\FunctionTok{toString}\NormalTok{), List(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{))(OptionMonad) }
\NormalTok{    == Some(List(}\StringTok{"1"}\NormalTok{,}\StringTok{"2"}\NormalTok{,}\StringTok{"3"}\NormalTok{)) )}
\end{Highlighting}
\end{Shaded}

\texttt{join} kann verwendet werden, um einen zweifach in einer Monade
``verpackten'' Wert zu ``entpacken''. Der Eingabetyp ist also
\texttt{M{[}M{[}A{]}{]}}, der Ausgabetyp \texttt{M{[}A{]}}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ join[M[\_],A](x : M[M[A]])(}\KeywordTok{implicit}\NormalTok{ m: Monad[M]) : M[A] = }
\NormalTok{  m.}\FunctionTok{bind}\NormalTok{(x, (y : M[A]) =\textgreater{} y)}

\FunctionTok{assert}\NormalTok{( join[Option,Int](Some(Some(}\DecValTok{1}\NormalTok{)))(OptionMonad) == Some(}\DecValTok{1}\NormalTok{) )}
\end{Highlighting}
\end{Shaded}

\hypertarget{weitere-monaden}{%
\subsection{Weitere Monaden}\label{weitere-monaden}}

\underline{\textbf{Option-Monade:}} Die \emph{Option-Monade} (auch
\emph{Maybe-Monade} genannt) haben wir bereits in der
\protect\hyperlink{einfuxfchrung-mit-option-monade}{Einführung}
kennengelernt.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{object}\NormalTok{ OptionMonad }\KeywordTok{extends}\NormalTok{ Monad[Option] \{}
  \KeywordTok{override} \KeywordTok{def}\NormalTok{ bind[A,B](a: Option[A], f: A =\textgreater{} Option[B]) : Option[B] = a }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ Some(x) =\textgreater{} }\FunctionTok{f}\NormalTok{(x)}
    \KeywordTok{case}\NormalTok{ None =\textgreater{} None}
\NormalTok{  \}}
  \KeywordTok{override} \KeywordTok{def} \DataTypeTok{unit}\NormalTok{[A](a: A) = Some(a)}
\NormalTok{\}   }
\end{Highlighting}
\end{Shaded}

\underline{\textbf{Identitäts-Monade:}} Die \emph{Identitäts-Monade} ist die
einfachste Monade und entspricht normaler Funktionsapplikation. Die
Übergabe der Identitäts-Monade an monadischen Code liefert den Code im
gewöhnlichen Programmierstil.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ Id[X] = X   }
\KeywordTok{object}\NormalTok{ IdentityMonad }\KeywordTok{extends}\NormalTok{ Monad[Id] \{}
  \KeywordTok{def}\NormalTok{ bind[A,B](x: A, f: A =\textgreater{} B) : B = }\FunctionTok{f}\NormalTok{(x) }
  \KeywordTok{def} \DataTypeTok{unit}\NormalTok{[A](a: A) : A = a}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Für diese Monade wird leider nicht die Syntax der For-Comprehensions
unterstützt.

\underline{\textbf{Reader-Monade:}} Die \emph{Reader-Monade} kodiert den
``Environment Passing Style'', den wir bspw. im FAE-Interpreter gesehen
haben.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ ReaderMonad[R] }\KeywordTok{extends}\NormalTok{ Monad[(\{}\KeywordTok{type}\NormalTok{ M[A] = R =\textgreater{} A\})\#M] \{}
  \KeywordTok{override} \KeywordTok{def}\NormalTok{ bind[A,B](x: R =\textgreater{} A, f: A =\textgreater{} R =\textgreater{} B) : R =\textgreater{} B = r =\textgreater{} }\FunctionTok{f}\NormalTok{(}\FunctionTok{x}\NormalTok{(r))(r)}
  \KeywordTok{override} \KeywordTok{def} \DataTypeTok{unit}\NormalTok{[A](a: A) : R =\textgreater{} A = \_ =\textgreater{} a}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Beim Typparameter
\texttt{(\{type\ M{[}A{]}\ =\ R\ =\textgreater{}\ A\})\#M} handelt es
sich um eine Funktion auf Typ-Ebene, d.h. \texttt{M{[}A{]}} wird über
die Gleichung \texttt{M{[}A{]}\ =\ R\ =\textgreater{}\ A} definiert,
wobei \texttt{R} ein zusätzlicher Typparameter der Monade ist.
\texttt{R} wird bei jedem Funktionsaufruf als zusätzliches Argument
weitergereicht, was in \texttt{M{[}A{]}\ =\ R\ =\textgreater{}\ A} durch
Currying ausgedrückt wird.

\underline{\textbf{State-Monade:}} Bei der \emph{State-Monade} sind Berechnungen
abhängig von einem Zustand \texttt{S}, der von Berechnung zu Berechnung
gereicht wird. \texttt{S} wird also beim Aufruf übergeben und mit dem
Ergebnis in einem Tupel ausgegeben, was mit Currying in der Gleichung
\texttt{M{[}A{]}\ =\ S\ =\textgreater{}\ (A,S)} ausgedrückt wird.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ StateMonad[S] }\KeywordTok{extends}\NormalTok{ Monad[(\{}\KeywordTok{type}\NormalTok{ M[A] = S =\textgreater{} (A,S)\})\#M] \{}
  \KeywordTok{override} \KeywordTok{def}\NormalTok{ bind[A,B](x: S =\textgreater{} (A,S), f: A =\textgreater{} S =\textgreater{} (B,S)) : S =\textgreater{} (B,S) = }
\NormalTok{      s =\textgreater{} }\FunctionTok{x}\NormalTok{(s) }\KeywordTok{match}\NormalTok{ \{ }\KeywordTok{case}\NormalTok{ (a,s2) =\textgreater{} }\FunctionTok{f}\NormalTok{(a)(s2) \}}
  \KeywordTok{override} \KeywordTok{def} \DataTypeTok{unit}\NormalTok{[A](a: A) : S =\textgreater{} (A,S) = s =\textgreater{} (a,s)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\underline{\textbf{Listen-Monade:}} Bei der \emph{Listen-Monade} erzeugen
Berechnungen Listen von Ergebnissen, \texttt{bind} fügt jeweils alle
Ergebnisse in einer Liste zusammen. In \texttt{bind} wird die Funktion
\texttt{f} auf jedes Element der Liste angewendet und die Ergebnisse vom
Typ \texttt{List{[}B{]}} werden zu einer Liste konkateniert.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{object}\NormalTok{ ListMonad }\KeywordTok{extends}\NormalTok{ Monad[List] \{}
  \KeywordTok{override} \KeywordTok{def}\NormalTok{ bind[A,B](x: List[A], f: A =\textgreater{} List[B]) : List[B] = x.}\FunctionTok{flatMap}\NormalTok{(f)}
  \KeywordTok{override} \KeywordTok{def} \DataTypeTok{unit}\NormalTok{[A](a: A) = List(a)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\underline{\textbf{Continuation-Monade:}} Die \emph{Continuation-Monade} kodiert
CPS, es gilt
\texttt{M{[}A{]}\ =\ (A\ =\textgreater{}\ R)\ =\textgreater{}\ R}, wobei
\texttt{R} ein zusätzlicher Typparameter ist, der den Rückgabetyp von
Continuations angibt.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ ContinuationMonad[R] }\KeywordTok{extends}\NormalTok{ Monad[(\{}\KeywordTok{type}\NormalTok{ M[A] = (A =\textgreater{} R) =\textgreater{} R\})\#M] \{}
  \KeywordTok{type}\NormalTok{ Cont[X] = (X =\textgreater{} R) =\textgreater{} R}
  \KeywordTok{override} \KeywordTok{def}\NormalTok{ bind[A,B](x: Cont[A], f: A =\textgreater{} Cont[B]) : Cont[B] = }
\NormalTok{     k =\textgreater{} }\FunctionTok{x}\NormalTok{( a =\textgreater{} }\FunctionTok{f}\NormalTok{(a)(k) )}
  \KeywordTok{override} \KeywordTok{def} \DataTypeTok{unit}\NormalTok{[A](a: A) : Cont[A] = k =\textgreater{} }\FunctionTok{k}\NormalTok{(a)}
  \KeywordTok{def}\NormalTok{ callcc[A,B](f: (A =\textgreater{} Cont[B]) =\textgreater{} Cont[A]) : Cont[A] = }
\NormalTok{    k =\textgreater{} }\FunctionTok{f}\NormalTok{( (a:A) =\textgreater{} (\_:B=\textgreater{}R) =\textgreater{} }\FunctionTok{k}\NormalTok{(a))(k)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{monadentransformer}{%
\subsection{Monadentransformer}\label{monadentransformer}}

In der praktischen Programmierung will man oft die Eigenschaften
verschiedener Monaden kombinieren, etwa um gleichzeitig die
Option-Monade und die Listen-Monade zu nutzen. Mit
\emph{Monadentransformern} ist die Komposition von Monaden möglich.
Dabei handelt es sich um eine zusätzliche Fassung von jeder Monade, die
mit einer weiteren Monade parametrisiert ist.

Wir verwenden wieder die Option-Monade als Beispiel und erweitern diese
um eine äußere Monade:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ OptionT[M[\_]] = \{ }\KeywordTok{type}\NormalTok{ x[A] = M[Option[A]] \}}

\KeywordTok{class}\NormalTok{ OptionTMonad[M[\_]](}\KeywordTok{val}\NormalTok{ m: Monad[M]) }\KeywordTok{extends}\NormalTok{ Monad[OptionT[M]\#x] \{}
  \KeywordTok{override} \KeywordTok{def}\NormalTok{ bind[A,B](x: M[Option[A]], f: A =\textgreater{} M[Option[B]]) : M[Option[B]] =}
\NormalTok{    m.}\FunctionTok{bind}\NormalTok{(x, (z: Option[A]) =\textgreater{} z }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case}\NormalTok{ Some(y) =\textgreater{} }\FunctionTok{f}\NormalTok{(y)}
      \KeywordTok{case}\NormalTok{ None =\textgreater{} m.}\FunctionTok{unit}\NormalTok{(None)}
\NormalTok{    \})}
  \KeywordTok{override} \KeywordTok{def} \DataTypeTok{unit}\NormalTok{[A](a: A) : M[Option[A]] = m.}\FunctionTok{unit}\NormalTok{(Some(a))}
  
  \KeywordTok{def}\NormalTok{ lift[A](x: M[A]) : M[Option[A]] = m.}\FunctionTok{bind}\NormalTok{(x, (a: A) =\textgreater{} m.}\FunctionTok{unit}\NormalTok{(Some(a)))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{lift} nimmt einen Wert vom Typ \texttt{M{[}A{]}} und macht
daraus einen Wert vom Typ \texttt{M{[}Option{[}A{]}{]}}, umhüllt also
den inneren Datentyp von \texttt{M} mit \texttt{Option}.

\hypertarget{monadischer-interpreter}{%
\section{Monadischer Interpreter}\label{monadischer-interpreter}}

\hypertarget{monadenbibliothek}{%
\subsection{Monadenbibliothek}\label{monadenbibliothek}}

Bevor wir verschiedene Bausteine für Interpreter anlegen, wollen wir
erst eine Bibliothek von Monaden und Monadenkompositionen anlegen. Dabei
orientieren wir uns an dem Stil von Standardbibliotheken für Scala oder
Haskell.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ Monad \{}
  \KeywordTok{type}\NormalTok{ M[\_]}
  \KeywordTok{def} \DataTypeTok{unit}\NormalTok{[A](a: A) : M[A]}
  \KeywordTok{def}\NormalTok{ bind[A,B](m: M[A], f: A =\textgreater{} M[B]) : M[B]}
  \KeywordTok{implicit} \KeywordTok{def}\NormalTok{ monadicSyntax[A](m:M[A]) = }\KeywordTok{new}\NormalTok{ \{}
      \KeywordTok{def}\NormalTok{ map[B](f: A =\textgreater{} B) = }\FunctionTok{bind}\NormalTok{(m, (x:A) =\textgreater{} }\DataTypeTok{unit}\NormalTok{(}\FunctionTok{f}\NormalTok{(x)))}
      \KeywordTok{def}\NormalTok{ flatMap[B](f: A =\textgreater{} M[B]) : M[B] = }\FunctionTok{bind}\NormalTok{(m,f)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Wir definieren den Typkonstruktor \texttt{M} innerhalb der Klasse und
nicht als Typparameter, da die ``Typgleichungen'' somit leichter
ausgedrückt werden können.

Zuerst legen wir Interfaces für die Monaden an, in denen wir jeweils die
Typgleichung für \texttt{M} und ggf. weitere benötigte Typen definieren.
In den Interfaces legen wir auch zusätzlich benötigte Funktion neben
\texttt{bind} und \texttt{unit} in abstrakter Form an. Wir definieren
dann alle Monaden bis auf die Identitäts-Monade in Form von
Monadentransformern, diesmal mit einer zusätzlichen inneren Monade.
Dabei implementieren wir alle abstrakten Funktionen nun (unter
Berücksichtigung der inneren Monade) konkret. Durch Komposition mit der
Identitäts-Monade erzeugen wir effektiv eine Fassung ohne innere Monade,
wodurch wir diese nicht getrennt definieren müssen.

\hypertarget{defunktionalisierung}{%
\section{Defunktionalisierung}\label{defunktionalisierung}}

\textbf{Defunktionalisierung} bezeichnet die Umwandlung von
Higher-Order-Funktionen in First-Order-Funktionen. Diese Umwandlung ist
sowohl eine Compilertechnik als auch eine Programmiertechnik.

Eine \textbf{abstrakte Maschine} bezeichnet in der theoretischen
Informatik einen endlichen Automaten dessen Zustandsmenge unendlich groß
sein kann.

In einem zu defunktionalisierenden Programm dürfen keine anonymen
Funktionen auftreten. Um das Programm ohne anonyme Funktionen
umzuschreiben, wird \emph{Lambda Lifting} (auch \emph{Closure
Conversion} genannt) verwendet.

\hypertarget{lambda-lifting}{%
\subsection{Lambda Lifting}\label{lambda-lifting}}

Ziel von \emph{Lambda Lifting} ist es, lokale Funktionen in
Top-Level-Funktionen umzuwandeln. Lambda-Lifting kommt auch häufig in
Compilern zum Einsatz, bspw. findet man im Bytecode, der beim
Kompilieren von Scala-Programmen erzeugt wird, globale
Funktionsdefinition für alle anonymen Funktionen im Programm.

Im folgenden Programm gibt es zwei anonyme Funktionen, nämlich
\texttt{y\ =\textgreater{}\ y*n} und \texttt{y\ =\textgreater{}\ y+n}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{map}\NormalTok{(f: Int =\textgreater{} Int, l: List[Int]) : List[Int] = l }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case}\NormalTok{ List() =\textgreater{} List()}
  \KeywordTok{case}\NormalTok{ x::xs =\textgreater{} }\FunctionTok{f}\NormalTok{(x)::}\FunctionTok{map}\NormalTok{(f,xs)}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{addAndMulNToList}\NormalTok{(n: Int, l: List[Int]) : List[Int] = }
  \FunctionTok{map}\NormalTok{(y =\textgreater{} y*n, }\FunctionTok{map}\NormalTok{(y =\textgreater{} y+n, l))}
\end{Highlighting}
\end{Shaded}

Diese müssen extrahiert und als Top-Level-Funktionen definiert werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ f = (n: Int) =\textgreater{} (y: Int) =\textgreater{} y+n}
\KeywordTok{val}\NormalTok{ g = (n: Int) =\textgreater{} (y: Int) =\textgreater{} y*n}
\end{Highlighting}
\end{Shaded}

Dadurch lässt sich die Funktion \texttt{addAndMultNToList}
folgendermaßen ohne anonyme Funktionen umschreiben:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{addAndMulNToListLL}\NormalTok{(n: Int, l: List[Int]) : List[Int] = }
  \FunctionTok{map}\NormalTok{(}\FunctionTok{g}\NormalTok{(n), }\FunctionTok{map}\NormalTok{(}\FunctionTok{f}\NormalTok{(n), l))}
\end{Highlighting}
\end{Shaded}

\textbf{Vorgehensweise:} 1. Anonyme Funktionen im Programm suchen und
benennen 2. Den anonymen Funktionen entsprechende Top-Level-Funktionen
anlegen 3. Code aus der ursprünglichen anonymen Funktion in die neue
Funktion kopieren, freie Variablen suchen und als Parameter hinzufügen.
4. Eingabe der ursprünglichen anonymen Funktion durch Currying als
weiteren Parameter ergänzen. 5. Anonyme Funktion im Programm durch
Aufruf der neuen Top-Level-Funktion ersetzen 6. Lambda-Lifting im Rumpf
der neuen Top-Level-Funktion fortsetzen, falls dort anonyme Funktionen
auftreten

Nun wenden wir dieses Verfahren auf unseren CPS-transformierten
Interpreter an. Hier ist die ursprüngliche Fassung des Interpreters,
wobei alle anonymen Funktionen durch Kommentare benannt sind:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{object}\NormalTok{ CPSTransformed \{}
  \KeywordTok{def}\NormalTok{ eval[T](e: Exp, env: Env, k: Value =\textgreater{} T) : T = e }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n: Int) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{NumV}\NormalTok{(n))}
    \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x: String) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{env}\NormalTok{(x))}
    \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l: Exp, r: Exp) =\textgreater{}}
      \FunctionTok{eval}\NormalTok{(l, env, lVal =\textgreater{} }\CommentTok{/* addC1 */} 
        \FunctionTok{eval}\NormalTok{(r, env, rVal =\textgreater{} }\CommentTok{/* addC2 */}\NormalTok{ (lVal,rVal) }\KeywordTok{match}\NormalTok{ \{}
        \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(a),}\FunctionTok{NumV}\NormalTok{(b)) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{NumV}\NormalTok{(a+b))}
        \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{      \}))}
    \KeywordTok{case}\NormalTok{ f@}\FunctionTok{Fun}\NormalTok{(\_,\_) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{ClosureV}\NormalTok{(f,env))}
    \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{}}
      \FunctionTok{eval}\NormalTok{(f, env, fVal =\textgreater{} }\CommentTok{/* appC1 */}\NormalTok{ fVal }\KeywordTok{match}\NormalTok{ \{}
        \KeywordTok{case} \FunctionTok{ClosureV}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(p,b),cEnv) =\textgreater{} }\FunctionTok{eval}\NormalTok{(a, cEnv, aVal =\textgreater{} }\CommentTok{/* appC2 */} 
          \FunctionTok{eval}\NormalTok{(b, env+(p {-}\textgreater{} aVal), k))}
        \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{      \})}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Wir extrahieren die vier anonymen Funktionen und ersetzen ihre
Verwendung durch Aufrufe der neuen Top-Level-Funktionen (entsprechend
der obigen Schritte). Dadurch erhalten wir eine semantisch
gleichbedeutende Fassung des Interpreters, in der aber keine anonymen
Funktionen auftreten:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{object}\NormalTok{ LambdaLifted \{}
  \KeywordTok{def}\NormalTok{ addC1[T](r: Exp, env: Env, k: Value =\textgreater{} T)(lVal: Value): T =}
    \FunctionTok{eval}\NormalTok{(r, env, }\FunctionTok{addC2}\NormalTok{(lVal,k))}
  \KeywordTok{def}\NormalTok{ addC2[T](lVal: Value, k: Value =\textgreater{} T)(rVal: Value): T = (lVal,rVal) }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(a),}\FunctionTok{NumV}\NormalTok{(b)) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{NumV}\NormalTok{(a+b))}
      \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{    \}}
  \KeywordTok{def}\NormalTok{ appC1[T](a: Exp, env: Env, k: Value =\textgreater{} T)(fVal: Value) : T  = fVal }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case} \FunctionTok{ClosureV}\NormalTok{(}\FunctionTok{Fun}\NormalTok{(p,b),cEnv) =\textgreater{} }\FunctionTok{eval}\NormalTok{(a, cEnv, }\FunctionTok{appC2}\NormalTok{(b,p,env,k))}
      \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{    \}}
  \KeywordTok{def}\NormalTok{ appC2[T](b: Exp, p: String, env: Env, k: Value =\textgreater{} T)(aVal: Value) : T =}
    \FunctionTok{eval}\NormalTok{(b, env+(p {-}\textgreater{} aVal), k)}

  \KeywordTok{def}\NormalTok{ eval[T](e: Exp, env: Env, k: Value =\textgreater{} T) : T = e }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{Num}\NormalTok{(n: Int) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{NumV}\NormalTok{(n))}
    \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x: String) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{env}\NormalTok{(x))}
    \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l: Exp, r: Exp) =\textgreater{}}
      \FunctionTok{eval}\NormalTok{(l, env, }\FunctionTok{addC1}\NormalTok{(r,env,k))}
    \KeywordTok{case}\NormalTok{ f@}\FunctionTok{Fun}\NormalTok{(\_,\_) =\textgreater{} }\FunctionTok{k}\NormalTok{(}\FunctionTok{ClosureV}\NormalTok{(f,env))}
    \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{}}
      \FunctionTok{eval}\NormalTok{(f, env, }\FunctionTok{appC1}\NormalTok{(a,env,k))}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{defunktionalisierungsschritt}{%
\subsection{Defunktionalisierungsschritt}\label{defunktionalisierungsschritt}}

In unserem ersten Beispiel liegen nach dem Lambda-Lifting noch
Higher-Order-Funktionen vor, nämlich \texttt{f} und \texttt{g}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ f = (n: Int) =\textgreater{} (y: Int) =\textgreater{} y + n}
\KeywordTok{val}\NormalTok{ g = (n: Int) =\textgreater{} (y: Int) =\textgreater{} y * n}

\KeywordTok{def} \FunctionTok{addAndMulNToListLL}\NormalTok{(n: Int, l: List[Int]) : List[Int] =}
  \FunctionTok{map}\NormalTok{(}\FunctionTok{g}\NormalTok{(n), }\FunctionTok{map}\NormalTok{(}\FunctionTok{f}\NormalTok{(n), l))}
\end{Highlighting}
\end{Shaded}

Das Programm soll nun so umgeformt werden, dass nur
First-Order-Funktionen auftreten. Um den Closure nach dem ersten
Currying-Schritt zu repräsentieren, legen wir einen Datencontainer an,
der für beide Funktionen den Wert von \texttt{n} halten kann.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ FunctionValue}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{F}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ FunctionValue}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{G}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ FunctionValue}
\end{Highlighting}
\end{Shaded}

Außerdem legen wir eine Funktion \texttt{apply} an, die mit Instanzen
von \texttt{FunctionValue} zusammen mit dem zweiten Argument aufgerufen
werden kann, um den zweiten Schritt des Currying durchzuführen.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{apply}\NormalTok{(f: FunctionValue, y: Int) : Int = f }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{F}\NormalTok{(n) =\textgreater{} y + n}
  \KeywordTok{case} \FunctionTok{G}\NormalTok{(n) =\textgreater{} y * n}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{map}\NormalTok{(f: FunctionValue, l: List[Int]) : List[Int] = l }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case}\NormalTok{ List() =\textgreater{} List()}
  \KeywordTok{case}\NormalTok{ x::xs =\textgreater{} }\FunctionTok{apply}\NormalTok{(f,x)::}\FunctionTok{map}\NormalTok{(f,xs)}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{addAndMulNToList}\NormalTok{(n: Int, l: List[Int]) : List[Int] =}
  \FunctionTok{map}\NormalTok{(}\FunctionTok{G}\NormalTok{(n), }\FunctionTok{map}\NormalTok{(}\FunctionTok{F}\NormalTok{(n), l))}
\end{Highlighting}
\end{Shaded}

\textbf{Vorgehensweise:} 1. Lege für jede Art von Higher-Order-Funktion
(d.h. für jede Signatur aus Eingabe und Ausgabe) abstrakte Oberklasse an
mit Unterklassen für jede verwendete Funktion des entsprechenden Typs.
2. Lege \texttt{apply}-Funktion für jede Funktionsart mit Fällen für
alle Unterklassen an, kopiere Rümpfe der Top-Level-Funktionen in die
Fälle. 3. Ersetze Typ von Higher-Order-Parametern mit entsprechendem
Function-Value-Typ. 4. Forme Aufrufe der Higher-Order-Funktionen mit
\texttt{apply} um (\texttt{f(x)} wird zu \texttt{apply(f,x)})

\hypertarget{typsysteme}{%
\section{Typsysteme}\label{typsysteme}}

Ziel von Typsystemen ist es, bestimmte Arten semantischer Fehler (bspw.
Addition von Funktionen oder Applikation einer Zahl) in einem
syntaktisch korrekten Programm bereits vor dessen Ausführung zu
erkennen. Ein Typsystem kann für die Fehler, die es erkennen soll,
garantieren, dass diese bei keiner Ausführung eines Programms auftreten.
Im Gegensatz dazu kann ein Test nur die fehlerfreie Ausführung eines
Programms für eine bestimmte Eingabe garantieren.

Im Kontext von Typsystemen und Typecheckern spricht man von den
Eigenschaften \emph{Soundness} und \emph{Completeness}.

Ein Typsystem ist \emph{sound}, wenn es jeden bei der Ausführung
auftretenden Typfehler vor der Ausführung meldet, und \emph{complete},
wenn es nur Fehler meldet, die tatsächlich bei der Ausführung auftreten.
Anders ausgedrückt: Einen Typecheck, der sound ist, bestehen \textbf{nur
echt typsichere} Programme und einen Typecheck, der complete ist,
bestehen \textbf{alle typsicheren} Programme.

Im Fall von Soundness bestehen evtl. \textbf{echt typsichere} Programme
den Typecheck nicht, im Fall von Completeness bestehen evtl.
\textbf{nicht typsichere} Programme den Typecheck.

Aus dem \emph{Satz von Rice} folgt, dass es für eine Turing-vollständige
Sprache kein perfektes Typsystem, das Soundness und Completeness
erfüllt, geben kann.

\textbf{Satz von Rice:} Sei \(\mathcal{P}\) die Menge aller
Turing-berechenbaren Funktionen und
\(\mathcal{S} \subsetneq \mathcal{P}\) eine nicht-leere, echte Teilmenge
davon, so ist die Menge der Turingmaschinen, deren berechnete Funktion
in \(\mathcal{S}\) liegt, nicht entscheidbar.

Damit sind alle semantischen Eigenschaften von Programmen in
Turing-vollständigen Sprachen nicht entscheidbar (d.h. es gibt keinen
Algorithmus, der für jedes Programm entscheiden kann, ob die Eigenschaft
zutrifft).

Dies wird bereits an folgendem Beispiel deutlich:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f}\NormalTok{()}
\NormalTok{((x: Int) =\textgreater{} x+}\DecValTok{1}\NormalTok{) + }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

Um entscheiden zu können, ob im obigen Programm ein Fehler durch die
Addition einer Funktion und einer Zahl entsteht, müsste entschieden
werden, ob \texttt{f} terminiert -- dazu müsste das Halteproblem
entscheidbar sein. Da das Halteproblem unentscheidbar ist, ist durch
Widerspruch bewiesen, dass kein perfektes Typsystem existieren kann. Es
ist nämlich in jeder Turing-vollständigen Sprache möglich,
nicht-terminierende Programme zu formulieren.

Es sind aber durchaus Typsysteme möglich, die entweder Completeness oder
Soundness erfüllen. Dabei ist Soundness meist die interessantere
Eigenschaft, weil damit das Typsystem die Typsicherheit garantieren kann
(was für Completeness nicht der Fall ist). Es werden jedoch manche
Programme abgelehnt, die in Wahrheit ohne Typfehler ausgeführt werden
könnten. Es handelt sich also um eine \emph{konservative} Abschätzung
bzw. eine \emph{Überapproximation}, da in manchen Fällen Programme
``sicherheitshalber'' abgelehnt werden, wenn die Typsicherheit nicht
garantiert werden kann.

Für unsere Sprachen wird die Syntax jeweils durch eine
\emph{kontextfreie Grammatik} in Form der Case Classes definiert.
Typkorrektheit ist aber keine kontextfreie Eigenschaft, was etwa an
folgendem Programm deutlich wird:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{wth}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\FunctionTok{Add}\NormalTok{(}\StringTok{"x"}\NormalTok{,}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Um hier feststellen zu können, ob \texttt{"x"} im inneren
\texttt{Add}-Ausdruck gebunden ist und ob es sich dabei um eine Zahl
handelt, muss der Kontext (also der \texttt{wth}-Ausdruck) betrachtet
werden. Typkorrektheit ist in diesem Fall also offensichtlich eine
\emph{kontextsensitive} Eigenschaft und kann deshalb nicht direkt in der
Grammatik der Sprache definiert werden. Aus diesem Grund ist ein
Typsystem als zusätzlicher ``Filter'' notwendig, um Typkorrektheit zu
garantieren. Dies gilt für die meisten Programmiersprachen.

Ein wichtiger Gesichtspunkt von Typsystemen ist auch deren
Nachvollziehbarkeit für Programmierer, es muss verständlich sein, wann
und warum Fehler erkannt werden. Um diese Nachvollziehbarkeit zu
gewährleisten sind Typchecker meist kompositional, d.h. der Typ eines
Ausdrucks ergibt sich durch die Typen seiner Unterausdrücke.

\hypertarget{interpreter-mit-typsystem}{%
\subsection{Interpreter mit Typsystem}\label{interpreter-mit-typsystem}}

In unseren bisherigen Interpretern haben wir beim Auftreten von
Typfehlern (bspw. Addition von zwei Funktionen) einen Laufzeitfehler
geworfen, wie etwa hier im FAE-Interpreter:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// ...}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{eval}\NormalTok{(l,env),}\FunctionTok{eval}\NormalTok{(r,env)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumV}\NormalTok{(a),}\FunctionTok{NumV}\NormalTok{(b)) =\textgreater{} }\FunctionTok{NumV}\NormalTok{(a+b)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{  \}}
\CommentTok{// ...}
\end{Highlighting}
\end{Shaded}

Nun wollen wir für die folgende Sprache ein Typsystem definieren, so
dass bereits vor der Auswertung eines Programms überprüft werden kann,
ob dieses typsicher ist.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Num}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Bool}\NormalTok{(b: Boolean) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Add}\NormalTok{(l: Exp, r: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{If}\NormalTok{(c: Exp, t: Exp, f: Exp) }\KeywordTok{extends}\NormalTok{ Exp}

\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp) : Exp = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{eval}\NormalTok{(l), }\FunctionTok{eval}\NormalTok{(r)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{Num}\NormalTok{(x),}\FunctionTok{Num}\NormalTok{(y)) =\textgreater{} }\FunctionTok{Num}\NormalTok{(x+y)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{If}\NormalTok{(c,t,f) =\textgreater{} }\FunctionTok{eval}\NormalTok{(c) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{Bool}\NormalTok{(}\KeywordTok{true}\NormalTok{) =\textgreater{} }\FunctionTok{eval}\NormalTok{(t)}
    \KeywordTok{case} \FunctionTok{Bool}\NormalTok{(}\KeywordTok{false}\NormalTok{) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Condition must be a boolean"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case}\NormalTok{ \_ =\textgreater{} e}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Am Interpreter ist bereits erkennbar, welche Typfehler auftreten können:
Eine Additionsoperation, bei der nicht beide Summanden Zahlen sind, oder
ein \texttt{If}-Ausdruck, dessen Bedingung nicht zu einem \texttt{Bool}
auswertet. Um diese Fehler zu erkennen, wollen wir Werte nach Typ
klassifizieren. Wir entscheiden uns dazu, zwischen Zahlen und Booleans
unterscheiden.

Wir definieren eine neue abstrakte Klasse \texttt{Type} mit den zwei
konkreten Unterklassen \texttt{NumType} und \texttt{BoolType}. Diese
entsprechen den zwei Wertetypen, die die Auswertung eines Ausdrucks
ergeben kann.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Type}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{BoolType}\NormalTok{() }\KeywordTok{extends}\NormalTok{ Type}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{NumType}\NormalTok{() }\KeywordTok{extends}\NormalTok{ Type}
\end{Highlighting}
\end{Shaded}

Um Typechecking auf Programmen bzw. Ausdrücken unserer Sprache
durchzuführen, definieren wir eine Funktion \texttt{typeCheck}. Bei
einem Typechecker handelt es sich um eine kompositionale Zuweisung von
Typen zu Ausdrücken im Programm, der Typ eines Ausdrucks wird also durch
seine Unterausdrücke bestimmt. Unsere \texttt{typeCheck}-Funktion ist
dementsprechend strukturell rekursiv:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{typeCheck}\NormalTok{(e: Exp) : Type = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(\_) =\textgreater{} }\FunctionTok{NumType}\NormalTok{()}
  \KeywordTok{case} \FunctionTok{Bool}\NormalTok{(\_) =\textgreater{} }\FunctionTok{BoolType}\NormalTok{()}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{typeCheck}\NormalTok{(l),}\FunctionTok{typeCheck}\NormalTok{(r)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumType}\NormalTok{(),}\FunctionTok{NumType}\NormalTok{()) =\textgreater{} }\FunctionTok{NumType}\NormalTok{()}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error in Add"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{If}\NormalTok{(c,t,f) =\textgreater{} (}\FunctionTok{typeCheck}\NormalTok{(c),}\FunctionTok{typeCheck}\NormalTok{(t),}\FunctionTok{typeCheck}\NormalTok{(f)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{BoolType}\NormalTok{(),tType,fType) =\textgreater{}}
      \KeywordTok{if}\NormalTok{ (tType == fType) tType }\KeywordTok{else}\NormalTok{ sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error in If"}\NormalTok{)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error in If"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Der \texttt{Num}- und \texttt{Bool}-Fall sind trivial, hier ist
offensichtlich um welchen Typ es sich handelt. Im \texttt{Add}-Fall muss
\texttt{typeCheck} auf beiden Unterausdrücken \texttt{NumType()}
ergeben, da in unserer Sprache nur Addition von Zahlen erfolgreich
ausgewertet werden kann. Sind die Summanden nicht beide vom Typ
\texttt{NumType()}, so geben wir eine Fehlermeldung aus. Im
\texttt{If}-Fall ist klar, dass der Typechecker auf der Bedingung
\texttt{BoolType} ergeben muss, der Typ des \texttt{If}-Ausdrucks selbst
lässt sich aber nicht ohne weiteres feststellen. Je nachdem, welcher
Zweig betreten wird, müsste entweder der Typ von \texttt{t} oder von
\texttt{f} rekursiv bestimmt und ausgegeben werden.

Um zu entscheiden, welcher Zweig betreten wird, müsste die Bedingung
ausgewertet werden. Würde man diese Auswertung im Typechecker
durchführen, so verliert dieser aber gewissermaßen seinen Nutzen, denn
wenn er bei Typfehlern in einer \texttt{If}-Bedingung die gleichen
Laufzeitfehler liefert wie der Interpreter, so bietet der Typechecker
keinen Vorteil gegenüber einer Ausführung des Programms.

In einer komplexeren Sprache (z.B. der Turing-vollständigen FAE-Sprache)
wäre es nicht möglich, die Bedingung ohne den Kontext des
\texttt{If}-Ausdrucks auszuwerten, zudem könnte die Auswertung der
Bedingung evtl. nicht terminieren, wodurch der Typechecker kein Ergebnis
liefern würde. In jedem Fall verliert der Typechecker seinen Nutzen als
Prüfmittel vor der eigentlichen Auswertung, sobald er Teile des
Programms auswertet.

Aus diesen Gründen bleibt nur die Möglichkeit, den Typ beider Zweige zu
bestimmen und auf Gleichheit zu prüfen, falls \texttt{t} und \texttt{f}
den gleichen Typ besitzen, kann dieser ausgegeben werden. Dadurch wird
aber bei gewissen Programmen ein Typfehler gefunden, obwohl diese
fehlerfrei auswerten:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{val}\NormalTok{ ex1 = }\FunctionTok{If}\NormalTok{(}\KeywordTok{false}\NormalTok{,}\KeywordTok{true}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\KeywordTok{val}\NormalTok{ ex2 = }\FunctionTok{Add}\NormalTok{(}\DecValTok{2}\NormalTok{, }\FunctionTok{If}\NormalTok{(}\KeywordTok{true}\NormalTok{,}\DecValTok{3}\NormalTok{,}\KeywordTok{true}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Bei der Prüfung auf Gleichheit handelt es sich um eine konservative
Abschätzung des Programmverhaltens -- Ausdrücke, in denen im
\texttt{then}- und \texttt{else}-Zweig verschiedene Typen vorliegen,
werden abgelehnt, da die Typsicherheit nicht gewährleistet werden kann.

Wir können unsere Definition von Soundness für Typechecking noch etwas
verfeinern: Soundness bedeutet auch, dass der Typecheck den Typ des
Auswertungsergebnisses korrekt vorhersagt.

\textbf{Soundness des Typsystems:}

Für alle \texttt{e:\ Exp}, \texttt{v:\ Exp} und \texttt{t:\ Type} gilt:
Falls \texttt{typeCheck(e)\ ==\ t}, so gilt \texttt{eval(e)\ ==\ v} mit
\texttt{typeCheck(v)\ ==\ t} ++oder++ \texttt{eval(e)} führt zu einem
Laufzeitfehler, der nicht vom Typsystem abgedeckt wird, ++oder++
\texttt{eval(e)} terminiert nicht.

\hypertarget{simply-typed-lambda-calculus-stlc}{%
\subsection{Simply-Typed Lambda Calculus
(STLC)}\label{simply-typed-lambda-calculus-stlc}}

Wir beginnen mit dem substitutionsbasierten Interpreter für den
ungetypten Lambda-Kalkül (FAE), da ohne getrennte Werte (\texttt{Value})
und Closures die Implementation eines Typsystem deutlich einfacher
möglich ist. Wir ergänzen Funktionen um eine Annotation des
Parametertyps, die vom Interpreter ignoriert wird. Diese Sprache ist die
einfachste Form des \emph{Simply-Typed Lambda Calculus} (\emph{STLC}).

Zusätzlich fügen wir einige gängige Erweiterungen für den STLC hinzu,
nämlich ein Sprachkonstrukt \texttt{JUnit}, Bindungen mit \texttt{Let}
(ohne Typannotationen), Typ-Annotationen für beliebige Ausdrücke,
Produkttypen (Tupel) und Summentypen (mit zwei Alternativen):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Type}

\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Num}\NormalTok{(n: Int) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Id}\NormalTok{(name: String) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Add}\NormalTok{(lhs: Exp, rhs: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Fun}\NormalTok{(param: String, t: Type, body: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{App}\NormalTok{ (fun: Exp, arg: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{JUnit}\NormalTok{() }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Let}\NormalTok{(x: String, xDef: Exp, body: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{TypeAscription}\NormalTok{(e: Exp, t: Type) }\KeywordTok{extends}\NormalTok{ Exp}

\KeywordTok{case} \KeywordTok{class} \FunctionTok{Product}\NormalTok{(left: Exp, right: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Fst}\NormalTok{(e: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Snd}\NormalTok{(e: Exp) }\KeywordTok{extends}\NormalTok{ Exp}

\KeywordTok{case} \KeywordTok{class} \FunctionTok{SumLeft}\NormalTok{(left: Exp, right: Type) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{SumRight}\NormalTok{(left: Type, right: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{EliminateSum}\NormalTok{(e: Exp, funLeft: Exp, funRight: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\end{Highlighting}
\end{Shaded}

Wir erweitern den
\protect\hyperlink{substitutionsbasierter-interpreter-a}{substitutionsbasierten
FAE-Interpreter} um die zusätzlichen Fälle, wobei wir auch die
Hilfsfunktionen \texttt{freshName}, \texttt{freeVars} und \texttt{subst}
erweitern müssen.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{freeVars}\NormalTok{(e: Exp) : Set[String] =  e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} Set(x)}
  \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(p,\_,b) =\textgreater{} }\FunctionTok{freeVars}\NormalTok{(b){-}x}
  \CommentTok{// ...}
  \KeywordTok{case} \FunctionTok{JUnit}\NormalTok{() =\textgreater{} Set.}\FunctionTok{empty}
  \KeywordTok{case} \FunctionTok{Let}\NormalTok{(x,xDef,b) =\textgreater{} }\FunctionTok{freeVars}\NormalTok{(xDef)++(}\FunctionTok{freeVars}\NormalTok{(b) {-} x)}
  \KeywordTok{case} \FunctionTok{Product}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{freeVars}\NormalTok{(l)++}\FunctionTok{freeVars}\NormalTok{(r)}
  \KeywordTok{case} \FunctionTok{SumLeft}\NormalTok{(e,\_) =\textgreater{} }\FunctionTok{freeVars}\NormalTok{(e)}
  \KeywordTok{case} \FunctionTok{SumRight}\NormalTok{(\_,e) =\textgreater{} }\FunctionTok{freeVars}\NormalTok{(e)}
  \KeywordTok{case} \FunctionTok{EliminateSum}\NormalTok{(e,fl,fr) =\textgreater{} }\FunctionTok{freeVars}\NormalTok{(e)++}\FunctionTok{freeVars}\NormalTok{(fl)++}\FunctionTok{freeVars}\NormalTok{(fr)}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{subst}\NormalTok{(e : Exp, x: String, xDef: Exp) : Exp = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(y) =\textgreater{} }\KeywordTok{if}\NormalTok{ (x == y) xDef }\KeywordTok{else} \FunctionTok{Id}\NormalTok{(y)}
  \CommentTok{// ...}
  \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(param,t,body) =\textgreater{}}
    \KeywordTok{if}\NormalTok{ (param == x) e }\KeywordTok{else}\NormalTok{ \{}
      \KeywordTok{val}\NormalTok{ fvs = }\FunctionTok{freeVars}\NormalTok{(body) ++ }\FunctionTok{freeVars}\NormalTok{(xDef)}
      \KeywordTok{val}\NormalTok{ newvar = }\FunctionTok{freshName}\NormalTok{(fvs, param)}
      \FunctionTok{Fun}\NormalTok{(newvar, t,}\FunctionTok{subst}\NormalTok{(}\FunctionTok{subst}\NormalTok{(body, param, }\FunctionTok{Id}\NormalTok{(newvar)), x, xDef))}
\NormalTok{    \}}
  \KeywordTok{case} \FunctionTok{Let}\NormalTok{(y,ydef,body) =\textgreater{}}
    \KeywordTok{if}\NormalTok{ (x == y) }\FunctionTok{Let}\NormalTok{(y,}\FunctionTok{subst}\NormalTok{(ydef,x,xDef),body) }\KeywordTok{else}\NormalTok{ \{}
      \KeywordTok{val}\NormalTok{ fvs = }\FunctionTok{freeVars}\NormalTok{(body) ++ }\FunctionTok{freeVars}\NormalTok{(xDef)}
      \KeywordTok{val}\NormalTok{ newvar = }\FunctionTok{freshName}\NormalTok{(fvs,y)}
      \FunctionTok{Let}\NormalTok{(newvar,}\FunctionTok{subst}\NormalTok{(ydef,x,xDef),}\FunctionTok{subst}\NormalTok{(}\FunctionTok{subst}\NormalTok{(body,y,}\FunctionTok{Id}\NormalTok{(newvar)),x,xDef))}
\NormalTok{    \}}
  \KeywordTok{case} \FunctionTok{JUnit}\NormalTok{() =\textgreater{} e}
  \CommentTok{// ...}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{eval}\NormalTok{(e: Exp) : Exp = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Unbound identifier: "}\NormalTok{ + x)}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{eval}\NormalTok{(l), }\FunctionTok{eval}\NormalTok{(r)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{Num}\NormalTok{(x),}\FunctionTok{Num}\NormalTok{(y)) =\textgreater{} }\FunctionTok{Num}\NormalTok{(x+y)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only add numbers"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{eval}\NormalTok{(f) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(x,\_,body) =\textgreater{} }\FunctionTok{eval}\NormalTok{( }\FunctionTok{subst}\NormalTok{(body,x, }\FunctionTok{eval}\NormalTok{(a)))}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only apply functions"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{TypeAscription}\NormalTok{(e,\_) =\textgreater{} }\FunctionTok{eval}\NormalTok{(e)}
  \KeywordTok{case} \FunctionTok{Let}\NormalTok{(x,xdef,body) =\textgreater{} }\FunctionTok{eval}\NormalTok{(}\FunctionTok{subst}\NormalTok{(body,x,}\FunctionTok{eval}\NormalTok{(xdef)))}
  \KeywordTok{case} \FunctionTok{Product}\NormalTok{(a,b) =\textgreater{} }\FunctionTok{Product}\NormalTok{(}\FunctionTok{eval}\NormalTok{(a),}\FunctionTok{eval}\NormalTok{(b))}
  \KeywordTok{case} \FunctionTok{Fst}\NormalTok{(e) =\textgreater{} }\FunctionTok{eval}\NormalTok{(e) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{Product}\NormalTok{(a,b) =\textgreater{} a}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only select first from products"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Snd}\NormalTok{(e) =\textgreater{} }\FunctionTok{eval}\NormalTok{(e) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{Product}\NormalTok{(a,b) =\textgreater{} b}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only select second from products"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{SumLeft}\NormalTok{(e,t) =\textgreater{} }\FunctionTok{SumLeft}\NormalTok{(}\FunctionTok{eval}\NormalTok{(e),t)}
  \KeywordTok{case} \FunctionTok{SumRight}\NormalTok{(t,e) =\textgreater{} }\FunctionTok{SumRight}\NormalTok{(t,}\FunctionTok{eval}\NormalTok{(e))}
  \KeywordTok{case} \FunctionTok{EliminateSum}\NormalTok{(e,fl,fr) =\textgreater{} }\FunctionTok{eval}\NormalTok{(e) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{SumLeft}\NormalTok{(e2,\_) =\textgreater{} }\FunctionTok{eval}\NormalTok{(}\FunctionTok{App}\NormalTok{(fl,e2))}
    \KeywordTok{case} \FunctionTok{SumRight}\NormalTok{(\_,e2) =\textgreater{} }\FunctionTok{eval}\NormalTok{(}\FunctionTok{App}\NormalTok{(fr,e2))}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Can only eliminate sums"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case}\NormalTok{ \_ =\textgreater{} e }\CommentTok{// Num, Fun \& JUnit}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Wir legen ein Typsystem an, das Zahlen, Funktionen, JUnit, Produkttypen
und Summentypen unterscheidet:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class} \FunctionTok{NumType}\NormalTok{() }\KeywordTok{extends}\NormalTok{ Type}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{FunType}\NormalTok{(from: Type, to: Type) }\KeywordTok{extends}\NormalTok{ Type}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{JUnitType}\NormalTok{() }\KeywordTok{extends}\NormalTok{ Type}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{ProductType}\NormalTok{(left: Type, right: Type) }\KeywordTok{extends}\NormalTok{ Type}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{SumType}\NormalTok{(left: Type, right: Type) }\KeywordTok{extends}\NormalTok{ Type}
\end{Highlighting}
\end{Shaded}

\texttt{FunType()}, \texttt{ProductType()} und \texttt{SumType()} sind
dabei rekursiv definiert und enthalten selbst jeweils zwei
\texttt{Type}-Felder. Im Fall von Funktionen sind das der Parameter- und
Ausgabetyp. Die Ergänzung der Annotation für den Argumenttyp bei
Funktionen sorgt dafür, dass wir den \texttt{from}-Typ von Funktionen
nicht ``erraten'' müssen. Der \texttt{to}-Typ kann unter Angabe des
\texttt{from}-Typs problemlos durch Typechecking des Funktionsrumpfes
bestimmt werden.

Um mit Identifiern umzugehen, benötigt unser Typechecker ein zweites
Argument, nämlich eine Typumgebung (die meist mit \(\Gamma\) oder
\emph{Symbol Table} bezeichnet wird), in der der Typ von Identifiern
hinterlegt wird, damit er im \texttt{Id}-Fall ausgelesen werden kann.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{typeCheck}\NormalTok{(e: Exp, gamma: Map[String,Type]) : Type = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(\_) =\textgreater{} }\FunctionTok{NumType}\NormalTok{()}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} gamma.}\FunctionTok{get}\NormalTok{(x) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ Some(t) =\textgreater{} t}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error: Unbound identifier "}\NormalTok{+x)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{typeCheck}\NormalTok{(l,gamma),}\FunctionTok{typeCheck}\NormalTok{(r,gamma)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumType}\NormalTok{(),}\FunctionTok{NumType}\NormalTok{()) =\textgreater{} }\FunctionTok{NumType}\NormalTok{()}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error: Can only add numbers"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(p,t,b) =\textgreater{} }\FunctionTok{FunType}\NormalTok{(t, }\FunctionTok{typeCheck}\NormalTok{(b,gamma+(p {-}\textgreater{} t)))}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{} }\FunctionTok{typeCheck}\NormalTok{(f,gamma) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{FunType}\NormalTok{(from,to) =\textgreater{}}
      \KeywordTok{if}\NormalTok{ (from == }\FunctionTok{typeCheck}\NormalTok{(a,gamma)) to}
      \KeywordTok{else}\NormalTok{ sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error: Arg does not match expected type"}\NormalTok{)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error: Left expression must be a function"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{JUnit}\NormalTok{() =\textgreater{} }\FunctionTok{JUnitType}\NormalTok{()}
  \KeywordTok{case} \FunctionTok{Let}\NormalTok{(x,xDef,b) =\textgreater{} }\FunctionTok{typeCheck}\NormalTok{(b,gamma+(x {-}\textgreater{} }\FunctionTok{typeCheck}\NormalTok{(xDef,gamma)))}
  \KeywordTok{case} \FunctionTok{TypeAscription}\NormalTok{(e,t) =\textgreater{}}
    \KeywordTok{if}\NormalTok{ (}\FunctionTok{typeCheck}\NormalTok{(e,gamma)==t) t}
    \KeywordTok{else}\NormalTok{ sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error: Type does not match"}\NormalTok{)}
  \KeywordTok{case} \FunctionTok{Product}\NormalTok{(l,r) =\textgreater{} }\FunctionTok{ProductType}\NormalTok{(}\FunctionTok{typeCheck}\NormalTok{(l,gamma),}\FunctionTok{typeCheck}\NormalTok{(r,gamma))}
  \KeywordTok{case} \FunctionTok{Fst}\NormalTok{(e) =\textgreater{} }\FunctionTok{typeCheck}\NormalTok{(e,gamma) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{ProductType}\NormalTok{(l,\_) =\textgreater{} l}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error: Can only project products"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Snd}\NormalTok{(e) =\textgreater{} }\FunctionTok{typeCheck}\NormalTok{(e,gamma) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{ProductType}\NormalTok{(\_,r) =\textgreater{} r}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error: Can only project products"}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{SumLeft}\NormalTok{(l,t) =\textgreater{} }\FunctionTok{SumType}\NormalTok{(}\FunctionTok{typeCheck}\NormalTok{(l,gamma),t)}
  \KeywordTok{case} \FunctionTok{SumRight}\NormalTok{(t,r) =\textgreater{} }\FunctionTok{SumType}\NormalTok{(t,}\FunctionTok{typeCheck}\NormalTok{(r,gamma))}
  \KeywordTok{case} \FunctionTok{EliminateSum}\NormalTok{(c,fl,fr) =\textgreater{} }\FunctionTok{typeCheck}\NormalTok{(c,gamma) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{SumType}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{typeCheck}\NormalTok{(fl,gamma),}\FunctionTok{typeCheck}\NormalTok{(fr,gamma)) }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case}\NormalTok{ (}\FunctionTok{FunType}\NormalTok{(lf,lt),}\FunctionTok{FunType}\NormalTok{(rf,rt)) }\KeywordTok{if}\NormalTok{ l==lf \&\& r==rf \&\& lt==rt =\textgreater{}}
        \KeywordTok{if}\NormalTok{ (lTo==rTo) lTo}
        \KeywordTok{else}\NormalTok{ sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error: Functions must have same return type"}\NormalTok{)}
      \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error: 2nd and 3rd arg must be functions"}\NormalTok{)}
\NormalTok{    \}}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Type error: Can only eliminate sums"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Soundness und Terminierung von STLC:} Für \texttt{e:\ Exp} mit
\texttt{typeCheck(e)\ ==\ t} gilt: \texttt{eval(e)} terminiert und
\texttt{typeCheck(eval(e),Map())\ ==\ t}.

STLC ist nicht Turing-vollständig und in STLC können nur terminierende
Programme verfasst werden. Aus diesem Grund wird STLC bei der
Implementation von Programmiersprachen häufig auf Typ-Level verwendet,
da man bspw. Typfunktionen und deren Applikation formulieren will, aber
nicht-terminierende Ausdrücke auf Typ-Level verhindern muss, da sonst
der Typechecker nicht mehr zwingend terminiert.

\hypertarget{hindley-milner-typinferenz}{%
\section{Hindley-Milner-Typinferenz}\label{hindley-milner-typinferenz}}

Zuletzt wollen wir noch ein Typsystem betrachten, das ohne jegliche
Typannotationen auskommt und bei dem Typen \emph{inferiert} werden
können. Dazu wird beim Typechecking eine Liste von \emph{Constraints}
erzeugt und ähnlich wie bei einem linearen Gleichungssystem nach einer
Belegung mit Typen gesucht, die alle Constraints erfüllt.

Wir kehren dazu zum nicht-erweiterten STLC zurück, wobei wir wieder den
substitutionsbasierten Interpreter verwenden. Wir unterscheiden die
Typen \texttt{FunType()} und \texttt{NumType()}, außerdem ergänzen wir
Typvariablen.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sealed} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Type}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{FunType}\NormalTok{(from: Type, to: Type) }\KeywordTok{extends}\NormalTok{ Type}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{NumType}\NormalTok{() }\KeywordTok{extends}\NormalTok{ Type}
\KeywordTok{case} \KeywordTok{class} \FunctionTok{TypeVar}\NormalTok{(x: String) }\KeywordTok{extends}\NormalTok{ Type}
\end{Highlighting}
\end{Shaded}

Da der Typ von Identifiern (d.h. Funktionsparametern) erst bei deren
Verwendung bestimmt werden kann, wird Identifiern bei ihrem ersten
Auftreten eine Typvariable zugeordnet. Bei der Auswertung von
Ausdrücken, in dem ein Identifier genutzt wird, können dann Constraints
für die Typvariable erzeugt werden -- wird ein Identifier bspw. mit
einer Zahl addiert, so muss er den Typ \texttt{NumType()} besitzen.

Bei den Constraints handelt es sich um Typgleichungen, bei denen der
linke und rechte Typ übereinstimmen müssen. Diese werden als Tupel der
Form \texttt{(Type,Type)} repräsentiert. Die Ausgabe von
\texttt{typeCheck} ist eine Liste solcher Constraint-Tupel zusammen mit
dem Typen des Ausdrucks \texttt{e}, bei dem es sich auch um eine
Typvariable handeln kann.

Um Identifier mit ihrer jeweiligen Typvariable zu assoziieren, verwenden
wir wieder eine Typumgebung \(\Gamma\) (\texttt{g}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ typeVarCount: Int = }\DecValTok{0}
\KeywordTok{def} \FunctionTok{freshTypeVar}\NormalTok{() : Type = \{}
\NormalTok{  typeVarCount += }\DecValTok{1}
  \FunctionTok{TypeVar}\NormalTok{(}\StringTok{"X"}\NormalTok{+typeVarCount.}\FunctionTok{toString}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{typeCheck}\NormalTok{(e: Exp, g: Map[String,Type]) : (List[(Type,Type)],Type) = e }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{Num}\NormalTok{(\_) =\textgreater{} (List(),}\FunctionTok{NumType}\NormalTok{())}
  \KeywordTok{case} \FunctionTok{Id}\NormalTok{(x) =\textgreater{} g.}\FunctionTok{get}\NormalTok{(x) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ Some(t) =\textgreater{} (List(),t)}
    \KeywordTok{case}\NormalTok{ \_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(}\StringTok{"Unbound identifier: "}\NormalTok{+x)}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Add}\NormalTok{(l,r) =\textgreater{} (}\FunctionTok{typeCheck}\NormalTok{(l,g),}\FunctionTok{typeCheck}\NormalTok{(r,g)) }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case}\NormalTok{ ((lEqs,lt),(rEqs,rt)) =\textgreater{} }
\NormalTok{      (lt{-}\textgreater{}}\FunctionTok{NumType}\NormalTok{() :: rt{-}\textgreater{}}\FunctionTok{NumType}\NormalTok{() :: lEqs ++ rEqs, }\FunctionTok{NumType}\NormalTok{())}
\NormalTok{  \}}
  \KeywordTok{case} \FunctionTok{Fun}\NormalTok{(p,b) =\textgreater{}}
    \KeywordTok{val}\NormalTok{ xt = }\FunctionTok{freshTypeVar}\NormalTok{()}
    \KeywordTok{val}\NormalTok{ resBody = }\FunctionTok{typeCheck}\NormalTok{(b,g+(p{-}\textgreater{}xt))}
\NormalTok{    (resBody.}\FunctionTok{\_1}\NormalTok{, }\FunctionTok{FunType}\NormalTok{(xt,resBody.}\FunctionTok{\_2}\NormalTok{))}
  \KeywordTok{case} \FunctionTok{App}\NormalTok{(f,a) =\textgreater{}}
    \KeywordTok{val}\NormalTok{ toType = }\FunctionTok{freshTypeVar}\NormalTok{()}
\NormalTok{    (}\FunctionTok{typeCheck}\NormalTok{(f,g),}\FunctionTok{typeCheck}\NormalTok{(a,g)) }\KeywordTok{match}\NormalTok{ \{}
      \KeywordTok{case}\NormalTok{ ((fEqs, ft), (aEqs, at)) =\textgreater{} }
\NormalTok{        ((ft, }\FunctionTok{FunType}\NormalTok{(at, toType)) :: fEqs ++ aEqs, toType)}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Im \texttt{Num}-Fall wird eine leere Constraint-Liste und der Typ
\texttt{NumType()} zurückgegeben. Im \texttt{Id}-Fall wird der
Identifier \texttt{x} in der Typumgebung nachgeschlagen, wird ein
Eintrag gefunden, so wird der entsprechende Typ und eine leere
Constraint-Liste ausgegeben, ansonsten wird ein Fehler geworfen.

Im \texttt{Add}-Fall wird erst Typechecking auf den Unterausdrücken
durchgeführt, die Constraint-Liste wird um zwei Gleichungen erweitert:
Der Typ beider Unterausdrücke muss mit \texttt{NumType()}
übereinstimmen, da nur Zahlen addiert werden können. Es wird der Typ
\texttt{NumType()} ausgegeben.

Im \texttt{Fun}-Fall wird eine ``frische'' Typvariable für den
\texttt{param}-Identifier erzeugt, \texttt{typeCheck} wird rekursiv auf
dem Rumpf aufgerufen, wobei in der Typumgebung der Parameter an die neue
Typvariable gebunden wird. Das Typechecking des Rumpfes ergibt die
Constraint-Liste und den \texttt{to}-Typ der Funktion, für den
\texttt{from}-Typ wird die neue Typvariable eingesetzt.

Im \texttt{App}-Fall wird eine neue Typvariable \texttt{toType} für das
Ergebnis der Funktionsapplikation erzeugt, anschließend wird rekursiv
Typechecking auf beiden Unterausdrücken durchgeführt. Die
Constraint-Liste wird erweitert um die Bedingung, dass der Typ der
Funktion \texttt{FunType()} ist, wobei der \texttt{from}-Typ mit dem Typ
des Arguments und der \texttt{to}-Typ mit \texttt{toType} übereinstimmt.
Es wird \texttt{toType} ausgegeben.

\hypertarget{unifikationsalgorithmus-von-robinson}{%
\subsection{Unifikationsalgorithmus von
Robinson}\label{unifikationsalgorithmus-von-robinson}}

Die \texttt{typeCheck}-Funktion trifft im Gegensatz zu der im
\protect\hyperlink{simply-typed-lambda-calculus-stlc}{STLC-Typsystem}
(bis auf das Erkennen ungebundener Identifier) noch gar keine Aussage
darüber, ob ein Ausdruck typkorrekt ist. Dazu muss für die von
\texttt{typeCheck} ausgegebene Liste von Typgleichungen geprüft werden,
ob sich alle Gleichungen \emph{unifizieren} lassen. Dazu verwenden wir
den \emph{Unifikationsalgorithmus nach
\href{https://de.wikipedia.org/wiki/John_Alan_Robinson}{Robinson}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{substitution}\NormalTok{(x: String, s: Type): Type =\textgreater{} Type = }\KeywordTok{new}\NormalTok{ Function[Type,Type] \{}
  \KeywordTok{def} \FunctionTok{apply}\NormalTok{(t: Type) : Type = t }\KeywordTok{match}\NormalTok{ \{}
    \KeywordTok{case} \FunctionTok{FunType}\NormalTok{(from, to) =\textgreater{} }\FunctionTok{FunType}\NormalTok{(}\KeywordTok{this}\NormalTok{(from), }\KeywordTok{this}\NormalTok{(to))}
    \KeywordTok{case} \FunctionTok{NumType}\NormalTok{() =\textgreater{} }\FunctionTok{NumType}\NormalTok{()}
    \KeywordTok{case} \FunctionTok{TypeVar}\NormalTok{(y) =\textgreater{} }\KeywordTok{if}\NormalTok{ (x==y) s }\KeywordTok{else}\NormalTok{ t}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{freeTypeVars}\NormalTok{(t: Type) : Set[String] = t }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case} \FunctionTok{FunType}\NormalTok{(f,t) =\textgreater{} }\FunctionTok{freeTypeVars}\NormalTok{(f)++}\FunctionTok{freeTypeVars}\NormalTok{(t)}
  \KeywordTok{case} \FunctionTok{NumType}\NormalTok{() =\textgreater{} Set()}
  \KeywordTok{case} \FunctionTok{TypeVar}\NormalTok{(x) =\textgreater{} Set(x)}
\NormalTok{\}}

\KeywordTok{def} \FunctionTok{unify}\NormalTok{(eq: List[(Type,Type)]) : Type =\textgreater{} Type = eq }\KeywordTok{match}\NormalTok{ \{}
  \KeywordTok{case}\NormalTok{ List() =\textgreater{} identity}
  \KeywordTok{case}\NormalTok{ (}\FunctionTok{NumType}\NormalTok{(),}\FunctionTok{NumType}\NormalTok{())::rest =\textgreater{} }\FunctionTok{unify}\NormalTok{(rest)}
  \KeywordTok{case}\NormalTok{ (}\FunctionTok{FunType}\NormalTok{(f1,t1),}\FunctionTok{FunType}\NormalTok{(f2,t2))::rest =\textgreater{} }\FunctionTok{unify}\NormalTok{(f1{-}\textgreater{}f2::t1{-}\textgreater{}t2::rest)}
  \KeywordTok{case}\NormalTok{ (}\FunctionTok{TypeVar}\NormalTok{(x1),}\FunctionTok{TypeVar}\NormalTok{(x2))::rest }\KeywordTok{if}\NormalTok{ x1==x2 =\textgreater{} }\FunctionTok{unify}\NormalTok{(rest)}
  \KeywordTok{case}\NormalTok{ (}\FunctionTok{TypeVar}\NormalTok{(x),t)::rest =\textgreater{}}
    \KeywordTok{if}\NormalTok{ (}\FunctionTok{freeTypeVars}\NormalTok{(t)(x)) sys.}\FunctionTok{error}\NormalTok{(s}\StringTok{"Occurs check: $x occurs in $t"}\NormalTok{)}
    \KeywordTok{val}\NormalTok{ s = }\FunctionTok{substitution}\NormalTok{(x,t)}
\NormalTok{    s.}\FunctionTok{andThen}\NormalTok{(}\FunctionTok{unify}\NormalTok{(rest.}\FunctionTok{map}\NormalTok{(tup =\textgreater{} (}\FunctionTok{s}\NormalTok{(tup.}\FunctionTok{\_1}\NormalTok{),}\FunctionTok{s}\NormalTok{(tup.}\FunctionTok{\_2}\NormalTok{)))))}
  \KeywordTok{case}\NormalTok{ (t,}\FunctionTok{TypeVar}\NormalTok{(x))::rest =\textgreater{} }\FunctionTok{unify}\NormalTok{((}\FunctionTok{TypeVar}\NormalTok{(x),t)::rest)}
  \KeywordTok{case}\NormalTok{ (t1,t2)::\_ =\textgreater{} sys.}\FunctionTok{error}\NormalTok{(s}\StringTok{"Cannot unify $t1 and $t2"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{unify} bestimmt die einfachste Belegung der Typvariablen, die
alle durch \texttt{typeCheck} generierten Gleichungen erfüllt, und gibt
eine Funktion aus, die alle Typvariablen entsprechend dieser Belegung
substituiert.

Stimmen im ersten Tupel der Liste von Gleichungen die linke und rechte
Seite bereits überein, so wird \texttt{unify} einfach auf der Restliste
aufgerufen. Steht links und rechts der Typ \texttt{FunType()}, so wird
die Liste um zwei Bedingungen erweitert, nämlich dass der \texttt{from}-
und \texttt{to}-Typ jeweils übereinstimmen. Hierbei handelt es sich um
\emph{generative Rekursion}.

Steht im ersten Tupel links eine Typvariable und rechts ein anderer Typ,
so wird mittels \texttt{freeTypeVars} geprüft, ob die Typvariable
innerhalb des anderen Typs auftritt. Ist dies der Fall, so ist die
Gleichung ``selbstbezüglich'' und kann unmöglich erfüllt werden (bspw.
gibt es keinen Typ \texttt{X}, für den \texttt{X} und
\texttt{FunType(X,X)} gleichbedeutend sind). In diesem Fall wird also
ein Fehler geworfen.

Andernfalls wird mit \texttt{substitution} eine Funktion angelegt, die
alle Vorkommen der (linken) Typvariable durch den anderen (rechten) Typ
ersetzt. Mit \texttt{andThen} wird eine Komposition der Substitution
nach der Ergebnisfunktion des rekursiven Aufrufs von \texttt{unify}
angelegt, wobei \texttt{unify} auf der Restliste aufgerufen wird, in der
die Substitution mit \texttt{map} auf alle Tupel angewendet wurde.

Steht die Typvariable rechts und ein anderer Typ links, so werden die
Einträge im Tupel vertauscht, in allen anderen Fällen können die zwei
Typen im Tupel nicht unifiziert werden und es wird ein Fehler geworfen.

Erreicht \texttt{unify} das Ende der Liste, so wird die
Identitätsfunktion ausgegeben, durch die Komposition der
Substitutionsfunktionen gibt \texttt{unify} also eine Funktion aus, die
die einen Typ akzeptiert darin der unifizierenden Belegung entsprechend
alle Typvariablen substituiert. Es kann also der gesamte Typecheck mit
der folgenden Funktion durchgeführt werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{doTypeCheck}\NormalTok{(e: Exp): Type = \{}
  \KeywordTok{val}\NormalTok{ (eqs,t) = }\FunctionTok{typeCheck}\NormalTok{(e,Map())}
  \FunctionTok{unify}\NormalTok{(eqs)(t)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Completeness der Typinferenz:} Gibt es für ein Programm
Typannotationen, mit denen es vom STLC-Typechecker akzeptiert wird, so
akzeptiert der Typecheck mit Typinferenz auch die nicht-typannotierte
Variante des Programms.

\textbf{Soundness:} Für alle \texttt{e:\ Exp} gilt: Falls
\texttt{doTypeCheck(e)\ ==\ t}, dann gilt \texttt{eval(e)\ ==\ v} mit
\texttt{doTypeCheck(v)\ ==\ t} (unter \(\alpha\)-Konversion, d.h.
Umbennenung der Typvariablen ohne Veränderung der Bedeutung).

\hypertarget{let-polymorphismus}{%
\subsection{Let-Polymorphismus}\label{let-polymorphismus}}

Mit der bisherigen Definition der Sprache und des Typsystems ist es
nicht möglich, \emph{polymorphe} Funktionen auszudrücken, die für
mehrere Argumenttypen genutzt werden können. Bspw. müsste man die
Identitätsfunktion oder die Kompositionsfunktion für jeden Eingabetyp
getrennt anlegen.

Wir ermöglichen polymorphe Funktionen durch lokale Bindungen mit
\texttt{Let}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{case} \KeywordTok{class} \FunctionTok{Let}\NormalTok{(x: String, xDef: Exp, body: Exp) }\KeywordTok{extends}\NormalTok{ Exp}
\end{Highlighting}
\end{Shaded}

In \texttt{typeCheck} ergänzen wir den folgenden Fall für \texttt{Let}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \FunctionTok{typeCheck}\NormalTok{(e: Exp, g: Map[String,Type]) : (List[(Type,Type)],Type) = e }\KeywordTok{match}\NormalTok{ \{}
  \CommentTok{// ...}
  \KeywordTok{case} \FunctionTok{Let}\NormalTok{(x,xDef,b) =\textgreater{}}
    \KeywordTok{val}\NormalTok{ (eqs1,\_) = }\FunctionTok{typeCheck}\NormalTok{(xDef,g)}
    \KeywordTok{val}\NormalTok{ (eqs2,t) = }\FunctionTok{typeCheck}\NormalTok{(}\FunctionTok{subst}\NormalTok{(b,x,xDef),g)}
\NormalTok{    (eqs1++eqs2,t)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Erst wird \texttt{typeCheck} rekursiv auf \texttt{xDef} aufgerufen,
anschließend rufen wir \texttt{typeCheck} rekursiv auf dem Rumpf des
\texttt{Let}-Ausdrucks auf. Dabei verwenden wir aber (innerhalb von
\texttt{typeCheck}!) die \texttt{subst}-Funktion des Interpreters, um
alle Vorkommen von \texttt{x} im Rumpf durch \texttt{xDef} zu ersetzen.
Es werden die Constraints von \texttt{typeCheck} auf \texttt{xDef} und
auf dem Rumpf konkateniert und mit dem Ergebnistyp von
\texttt{typeCheck} auf dem Rumpf ausgegeben.

Durch die Substitution vor der Durchführung des Typechecks wird jedes
Vorkommen von \texttt{x} unabhängig von den anderen Vorkommen auf
Typkorrektheit geprüft und die Typen der Vorkommen müssen nicht zwingend
übereinstimmen.

Bspw. würde also beim Typechecking des Ausdrucks
\texttt{Let("id",Fun("x","x"),...)} das Typechecking für jedes Vorkommen
der Identitätsfunktion unabhängig voneinander durchgeführt werden.
Dadurch kann die Funktion polymorph für jeden beliebigen Argumenttyp
genutzt werden, da für alle Vorkommen jeweils der korrekte Typ (etwa
\texttt{FunType(NumType(),NumType())}) inferiert wird.

\end{document}
