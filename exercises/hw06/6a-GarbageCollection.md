1. **What was the reason why garbage collectors were invented in the first place?**
Garbage collection plays a key role in automatic memory management, since it removes memory entries that are no longer required and therefore prevents memory overflows. In PLs with no garbage collection, memory management must be performed by the programmer. They must manually dereference objects to free up memory. Automating the memory management leads to fewer mistakes and makes programming simpler.

2. **What does it mean for a garbage collector to be _safe_?**
A garbage collector is considered _safe_ if it is provable that the garbage collection algorithm will never dereference objects that are still required by the program. A datum used in subsequent computations should not be reclaimed, as this would lead to (potentially fatal) memory access errors. Garbage collectors are typically safe, but it is rarely provable that a garbage collector removes _all_ memory entries that are no longer needed.

3. **What is a _generational_ garbage collection algorithm and why is it useful?**
Generational garbage collection is based around empirical evidence showing that the age of objects is linked to their likelihood of becoming unreachable. Objects created very recently are more likely to become unreachable than objects created earlier during the runtime. Therefore categorization of objects by age can be used to perform garbage collection on younger objects more frequently and free up memory more efficiently.

4. **What is _reference counting_ and what is its disadvantage?**
Garbage collection is typically implemented by determining _reachability_, i.e. whether an object can be reached from the addresses in the current call stack. _Reference counting_ is an alternative approach in which each object holds the number of references to itself. Whenever references are added or removed, the numbers in the affected objects must be updated. If the counter for an object hits zero, the object can be removed immediately (and hence, the program does not need to be suspended for garbage collection cycles). If there are cyclical reference structures between objects (e.g. two objects which reference each other) the counters of the objects may never decrease to zero, even when they are no longer reachable. Reference counting must be paired with cycle detection algorithms to find and remove such objects.
